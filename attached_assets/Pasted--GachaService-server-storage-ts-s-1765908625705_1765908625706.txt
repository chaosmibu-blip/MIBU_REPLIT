好的，GachaService 已创建。现在它需要一些新的函式来跟资料库沟通。

请打开 `server/storage.ts` 档案，并在档案的末尾**新增**以下这四个函式。
需要添加到 server/storage.ts 末尾的程式码
code
TypeScript
import { sql } from 'drizzle-orm';
import { places, coupons, userCoupons, userCollection } from '../shared/schema';

// ... (檔案中其他现有的函式) ...

/**
 * 根据城市随机获取指定数量的地点（行程卡）
 * @param {string} cityId - 城市ID (此参数未来可能需要调整为你资料库中的实际栏位)
 * @param {number} limit - 需要获取的数量
 * @returns {Promise<Place[]>}
 */
export const getRandomPlacesByCity = async (cityId: string, limit: number): Promise<Place[]> => {
  // 注意：'cityId' 需要替换为你 places 表中代表城市的真实栏位名
  // 目前使用 ORDER BY random()，在资料量大时效能可能较低，但对于中小型应用足够
  const result = await db
    .select()
    .from(places)
    // .where(eq(places.cityId, cityId)) // 示例：如果需要根据城市筛选，请取消此行注释并修改栏位名
    .orderBy(sql`RANDOM()`)
    .limit(limit);
  return result;
};

/**
 * 获取某个地点所有当前有效的优惠券
 * @param {number} placeId - 地点ID
 * @returns {Promise<Coupon[]>}
 */
export const getActiveCouponsForPlace = async (placeId: number): Promise<Coupon[]> => {
  const now = new Date();
  return await db
    .select()
    .from(coupons)
    .where(
      and(
        eq(coupons.placeId, placeId),
        eq(coupons.isActive, true),
        gte(coupons.expiryDate, now)
      )
    );
};

/**
 * 将一张优惠券实例添加到用户的道具箱
 * @param {number} userId - 使用者ID
 * @param {number} couponId - 优惠券模板ID
 * @returns {Promise<void>}
 */
export const addUserCoupon = async (userId: number, couponId: number): Promise<void> => {
  await db.insert(userCoupons).values({
    userId,
    couponId,
    status: 'active',
  });
};

/**
 * 将一个地点添加到用户的图鉴中 (如果已存在则不处理)
 * "UPSERT" = UPDATE or INSERT
 * @param {number} userId - 使用者ID
 * @param {number} placeId - 地点ID
 * @returns {Promise<void>}
 */
export const upsertUserCollectionEntry = async (userId: number, placeId: number): Promise<void> => {
  // 使用 Drizzle 的 onConflictDoNothing 来避免插入重复的图鉴条目
  await db
    .insert(userCollection)
    .values({
      userId,
      placeId,
      isNew: true, // 每次都标记为新，前端可以处理是否真的要显示红点
    })
    .onConflictDoNothing({
      target: [userCollection.userId, userCollection.placeId] // 定义唯一性冲突的栏位
    });
};