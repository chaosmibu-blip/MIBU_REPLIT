
=== File: package.json ===

{
  "name": "rest-express",
  "version": "1.0.0",
  "type": "module",
  "license": "MIT",
  "scripts": {
    "dev:client": "vite dev --port 5000",
    "dev": "NODE_ENV=development tsx server/index.ts",
    "build": "tsx script/build.ts",
    "start": "NODE_ENV=production node dist/index.cjs",
    "check": "tsc",
    "db:push": "drizzle-kit push"
  },
  "dependencies": {
    "@google/genai": "^1.32.0",
    "@hookform/resolvers": "^3.10.0",
    "@jridgewell/trace-mapping": "^0.3.25",
    "@mapbox/mapbox-gl-language": "^1.0.1",
    "@radix-ui/react-accordion": "^1.2.12",
    "@radix-ui/react-alert-dialog": "^1.1.15",
    "@radix-ui/react-aspect-ratio": "^1.1.8",
    "@radix-ui/react-avatar": "^1.1.11",
    "@radix-ui/react-checkbox": "^1.3.3",
    "@radix-ui/react-collapsible": "^1.1.12",
    "@radix-ui/react-context-menu": "^2.2.16",
    "@radix-ui/react-dialog": "^1.1.15",
    "@radix-ui/react-dropdown-menu": "^2.1.16",
    "@radix-ui/react-hover-card": "^1.1.15",
    "@radix-ui/react-label": "^2.1.8",
    "@radix-ui/react-menubar": "^1.1.16",
    "@radix-ui/react-navigation-menu": "^1.2.14",
    "@radix-ui/react-popover": "^1.1.15",
    "@radix-ui/react-progress": "^1.1.8",
    "@radix-ui/react-radio-group": "^1.3.8",
    "@radix-ui/react-scroll-area": "^1.2.10",
    "@radix-ui/react-select": "^2.2.6",
    "@radix-ui/react-separator": "^1.1.8",
    "@radix-ui/react-slider": "^1.3.6",
    "@radix-ui/react-slot": "^1.2.4",
    "@radix-ui/react-switch": "^1.2.6",
    "@radix-ui/react-tabs": "^1.1.13",
    "@radix-ui/react-toast": "^1.2.7",
    "@radix-ui/react-toggle": "^1.1.10",
    "@radix-ui/react-toggle-group": "^1.1.11",
    "@radix-ui/react-tooltip": "^1.2.8",
    "@tanstack/react-query": "^5.60.5",
    "@twilio/conversations": "^2.6.5",
    "@types/cookie-parser": "^1.4.10",
    "@types/cors": "^2.8.19",
    "@types/jsonwebtoken": "^9.0.10",
    "@types/leaflet": "^1.9.21",
    "@types/mapbox-gl": "^3.4.1",
    "@types/memoizee": "^0.4.12",
    "apple-signin-auth": "^2.0.0",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "cmdk": "^1.1.1",
    "connect-pg-simple": "^10.0.0",
    "cookie-parser": "^1.4.7",
    "cors": "^2.8.5",
    "date-fns": "^3.6.0",
    "drizzle-orm": "^0.39.3",
    "drizzle-zod": "^0.7.0",
    "embla-carousel-react": "^8.6.0",
    "express": "^4.21.2",
    "express-session": "^1.18.1",
    "framer-motion": "^12.23.24",
    "input-otp": "^1.4.2",
    "jsonwebtoken": "^9.0.3",
    "leaflet": "^1.9.4",
    "lucide-react": "^0.545.0",
    "mapbox-gl": "^3.17.0",
    "memoizee": "^0.4.17",
    "memorystore": "^1.6.7",
    "next-themes": "^0.4.6",
    "openid-client": "^6.8.1",
    "passport": "^0.7.0",
    "passport-local": "^1.0.0",
    "pg": "^8.16.3",
    "react": "^19.2.0",
    "react-day-picker": "^9.11.1",
    "react-dom": "^19.2.0",
    "react-hook-form": "^7.66.0",
    "react-leaflet": "^5.0.0",
    "react-resizable-panels": "^2.1.9",
    "recharts": "^2.15.4",
    "socket.io": "^4.8.1",
    "sonner": "^2.0.7",
    "stripe": "^20.0.0",
    "stripe-replit-sync": "^0.0.12",
    "tailwind-merge": "^3.3.1",
    "tailwindcss-animate": "^1.0.7",
    "tw-animate-css": "^1.4.0",
    "twilio": "^5.10.7",
    "vaul": "^1.1.2",
    "wouter": "^3.3.5",
    "ws": "^8.18.0",
    "zod": "^3.25.76",
    "zod-validation-error": "^3.4.0"
  },
  "devDependencies": {
    "@replit/vite-plugin-cartographer": "^0.4.4",
    "@replit/vite-plugin-dev-banner": "^0.1.1",
    "@replit/vite-plugin-runtime-error-modal": "^0.0.4",
    "@tailwindcss/vite": "^4.1.14",
    "@types/connect-pg-simple": "^7.0.3",
    "@types/express": "4.17.21",
    "@types/express-session": "^1.18.0",
    "@types/node": "^20.19.0",
    "@types/passport": "^1.0.16",
    "@types/passport-local": "^1.0.38",
    "@types/react": "^19.2.0",
    "@types/react-dom": "^19.2.0",
    "@types/ws": "^8.5.13",
    "@vitejs/plugin-react": "^5.0.4",
    "autoprefixer": "^10.4.21",
    "drizzle-kit": "^0.31.4",
    "esbuild": "^0.25.0",
    "postcss": "^8.5.6",
    "tailwindcss": "^4.1.14",
    "tsx": "^4.20.5",
    "typescript": "5.6.3",
    "vite": "^7.1.9"
  },
  "optionalDependencies": {
    "bufferutil": "^4.0.8"
  }
}


=== File: drizzle.config.ts ===

import { defineConfig } from "drizzle-kit";

if (!process.env.DATABASE_URL) {
  throw new Error("DATABASE_URL, ensure the database is provisioned");
}

export default defineConfig({
  out: "./migrations",
  schema: "./shared/schema.ts",
  dialect: "postgresql",
  dbCredentials: {
    url: process.env.DATABASE_URL,
  },
});


=== File: shared/errors.ts ===

/**
 * 統一錯誤代碼表 (Global Error Code Enum)
 * 
 * 用途：前後端共用錯誤代碼，確保一致性
 * - 後端回傳 { errorCode: ErrorCode.AUTH_TOKEN_EXPIRED, message: '...' }
 * - 前端根據 errorCode 顯示對應的翻譯文案
 * 
 * 注意：此檔案必須是純 TypeScript，不依賴任何 Node.js 專用庫
 * 這樣 Expo 前端可以直接複製使用
 */

// ============ Error Code Enum ============
export enum ErrorCode {
  // Auth 認證相關 (E1xxx)
  AUTH_REQUIRED = 'E1001',
  AUTH_TOKEN_EXPIRED = 'E1002',
  AUTH_TOKEN_INVALID = 'E1003',
  INVALID_CREDENTIALS = 'E1004',
  EMAIL_ALREADY_EXISTS = 'E1005',
  PENDING_APPROVAL = 'E1006',
  ROLE_MISMATCH = 'E1007',
  ROLE_NOT_ACCESSIBLE = 'E1008',
  INVALID_ROLE = 'E1009',
  
  // Gacha 扭蛋相關 (E2xxx)
  GACHA_NO_CREDITS = 'E2001',
  GACHA_RATE_LIMITED = 'E2002',
  GACHA_GENERATION_FAILED = 'E2003',
  
  // Location 地點相關 (E3xxx)
  MISSING_LOCATION_ID = 'E3001',
  NO_DISTRICT_FOUND = 'E3002',
  REGION_NOT_FOUND = 'E3003',
  CITY_REQUIRED = 'E3004',
  NO_PLACES_AVAILABLE = 'E3005',
  COUNTRY_NOT_FOUND = 'E3006',
  
  // Merchant 商家相關 (E4xxx)
  MERCHANT_REQUIRED = 'E4001',
  MERCHANT_NOT_FOUND = 'E4002',
  NO_CODE_SET = 'E4003',
  CODE_EXPIRED = 'E4004',
  INVALID_CODE = 'E4005',
  COUPON_NOT_FOUND = 'E4006',
  COUPON_EXPIRED = 'E4007',
  COUPON_ALREADY_USED = 'E4008',
  
  // Validation 驗證相關 (E5xxx)
  VALIDATION_ERROR = 'E5001',
  INVALID_PARAMS = 'E5002',
  MISSING_REQUIRED_FIELD = 'E5003',
  
  // Resource 資源相關 (E6xxx)
  RESOURCE_NOT_FOUND = 'E6001',
  USER_NOT_FOUND = 'E6002',
  COLLECTION_NOT_FOUND = 'E6003',
  INVENTORY_ITEM_NOT_FOUND = 'E6004',
  
  // Payment 支付相關 (E7xxx)
  PAYMENT_FAILED = 'E7001',
  SUBSCRIPTION_EXPIRED = 'E7002',
  INSUFFICIENT_BALANCE = 'E7003',
  
  // Server 伺服器相關 (E9xxx)
  SERVER_ERROR = 'E9001',
  INTERNAL_ERROR = 'E9002',
  SERVICE_UNAVAILABLE = 'E9003',
  RATE_LIMITED = 'E9004',
}

// ============ Error Messages (Backend Default) ============
// 後端預設訊息，前端可選擇使用或覆蓋
export const ErrorMessages: Record<ErrorCode, string> = {
  // Auth
  [ErrorCode.AUTH_REQUIRED]: '請先登入',
  [ErrorCode.AUTH_TOKEN_EXPIRED]: '登入已過期，請重新登入',
  [ErrorCode.AUTH_TOKEN_INVALID]: '無效的登入憑證',
  [ErrorCode.INVALID_CREDENTIALS]: '電子郵件或密碼錯誤',
  [ErrorCode.EMAIL_ALREADY_EXISTS]: '此電子郵件已被註冊',
  [ErrorCode.PENDING_APPROVAL]: '帳號審核中，請等待管理員核准',
  [ErrorCode.ROLE_MISMATCH]: '帳號類型不符',
  [ErrorCode.ROLE_NOT_ACCESSIBLE]: '您沒有權限切換到此角色',
  [ErrorCode.INVALID_ROLE]: '無效的角色',
  
  // Gacha
  [ErrorCode.GACHA_NO_CREDITS]: '扭蛋次數不足',
  [ErrorCode.GACHA_RATE_LIMITED]: '操作過於頻繁，請稍後再試',
  [ErrorCode.GACHA_GENERATION_FAILED]: '行程生成失敗，請稍後再試',
  
  // Location
  [ErrorCode.MISSING_LOCATION_ID]: '請提供 regionId 或 countryId',
  [ErrorCode.NO_DISTRICT_FOUND]: '找不到可用的區域',
  [ErrorCode.REGION_NOT_FOUND]: '找不到指定的縣市',
  [ErrorCode.CITY_REQUIRED]: '請選擇城市',
  [ErrorCode.NO_PLACES_AVAILABLE]: '該區域暫無景點資料',
  [ErrorCode.COUNTRY_NOT_FOUND]: '找不到指定的國家',
  
  // Merchant
  [ErrorCode.MERCHANT_REQUIRED]: '需要商家帳號',
  [ErrorCode.MERCHANT_NOT_FOUND]: '商家不存在',
  [ErrorCode.NO_CODE_SET]: '商家尚未設定核銷碼',
  [ErrorCode.CODE_EXPIRED]: '核銷碼已過期',
  [ErrorCode.INVALID_CODE]: '核銷碼錯誤',
  [ErrorCode.COUPON_NOT_FOUND]: '找不到優惠券',
  [ErrorCode.COUPON_EXPIRED]: '優惠券已過期',
  [ErrorCode.COUPON_ALREADY_USED]: '優惠券已使用',
  
  // Validation
  [ErrorCode.VALIDATION_ERROR]: '輸入資料格式錯誤',
  [ErrorCode.INVALID_PARAMS]: '無效的參數',
  [ErrorCode.MISSING_REQUIRED_FIELD]: '缺少必要欄位',
  
  // Resource
  [ErrorCode.RESOURCE_NOT_FOUND]: '找不到資源',
  [ErrorCode.USER_NOT_FOUND]: '找不到用戶資料',
  [ErrorCode.COLLECTION_NOT_FOUND]: '找不到收藏',
  [ErrorCode.INVENTORY_ITEM_NOT_FOUND]: '找不到道具',
  
  // Payment
  [ErrorCode.PAYMENT_FAILED]: '付款失敗',
  [ErrorCode.SUBSCRIPTION_EXPIRED]: '訂閱已過期',
  [ErrorCode.INSUFFICIENT_BALANCE]: '餘額不足',
  
  // Server
  [ErrorCode.SERVER_ERROR]: '伺服器錯誤，請稍後再試',
  [ErrorCode.INTERNAL_ERROR]: '內部錯誤',
  [ErrorCode.SERVICE_UNAVAILABLE]: '服務暫時無法使用',
  [ErrorCode.RATE_LIMITED]: '請求過於頻繁，請稍後再試',
};

// ============ Helper Functions ============

/**
 * 建立標準化的錯誤回應物件
 */
export function createErrorResponse(
  code: ErrorCode, 
  customMessage?: string,
  details?: unknown
): { errorCode: ErrorCode; message: string; details?: unknown } {
  const response: { errorCode: ErrorCode; message: string; details?: unknown } = {
    errorCode: code,
    message: customMessage || ErrorMessages[code],
  };
  if (details !== undefined) {
    response.details = details;
  }
  return response;
}

/**
 * 取得錯誤代碼的預設訊息
 */
export function getErrorMessage(code: ErrorCode): string {
  return ErrorMessages[code] || '未知錯誤';
}

/**
 * 檢查錯誤代碼是否為認證相關錯誤
 */
export function isAuthError(code: ErrorCode): boolean {
  return code.startsWith('E1');
}

/**
 * 檢查錯誤代碼是否為伺服器錯誤
 */
export function isServerError(code: ErrorCode): boolean {
  return code.startsWith('E9');
}

// ============ API Response Types ============

/**
 * 標準化的 API 錯誤回應格式
 */
export interface ApiErrorResponse {
  errorCode: ErrorCode;
  message: string;
  details?: unknown;
}

/**
 * 標準化的 API 成功回應格式
 */
export interface ApiSuccessResponse<T = unknown> {
  success: true;
  data: T;
}


=== File: shared/schema.ts ===

import { sql } from "drizzle-orm";
import { pgTable, text, varchar, serial, timestamp, integer, boolean, jsonb, index, doublePrecision, date } from "drizzle-orm/pg-core";
import { relations } from "drizzle-orm";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";

// ============ Location Hierarchy Tables ============

// Countries table
export const countries = pgTable("countries", {
  id: serial("id").primaryKey(),
  code: varchar("code", { length: 10 }).notNull().unique(),
  nameEn: text("name_en").notNull(),
  nameZh: text("name_zh").notNull(),
  nameJa: text("name_ja"),
  nameKo: text("name_ko"),
  isActive: boolean("is_active").default(true).notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

// Regions table (e.g., 北部, 中部, 南部, 東部 for Taiwan)
export const regions = pgTable("regions", {
  id: serial("id").primaryKey(),
  countryId: integer("country_id").references(() => countries.id).notNull(),
  code: varchar("code", { length: 50 }).notNull(),
  nameEn: text("name_en").notNull(),
  nameZh: text("name_zh").notNull(),
  nameJa: text("name_ja"),
  nameKo: text("name_ko"),
  isActive: boolean("is_active").default(true).notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
}, (table) => [
  index("IDX_regions_country").on(table.countryId),
]);

// Districts table (行政區 e.g., 信義區, 大安區)
export const districts = pgTable("districts", {
  id: serial("id").primaryKey(),
  regionId: integer("region_id").references(() => regions.id).notNull(),
  code: varchar("code", { length: 50 }).notNull(),
  nameEn: text("name_en").notNull(),
  nameZh: text("name_zh").notNull(),
  nameJa: text("name_ja"),
  nameKo: text("name_ko"),
  isActive: boolean("is_active").default(true).notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
}, (table) => [
  index("IDX_districts_region").on(table.regionId),
]);

// ============ Category Hierarchy Tables ============

// Main categories (食, 宿, 生態文化教育, 遊程體驗, 娛樂設施, 活動, 景點, 購物)
export const categories = pgTable("categories", {
  id: serial("id").primaryKey(),
  code: varchar("code", { length: 50 }).notNull().unique(),
  nameEn: text("name_en").notNull(),
  nameZh: text("name_zh").notNull(),
  nameJa: text("name_ja"),
  nameKo: text("name_ko"),
  colorHex: varchar("color_hex", { length: 7 }).default('#6366f1'),
  sortOrder: integer("sort_order").default(0),
  isActive: boolean("is_active").default(true).notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

// Subcategories (e.g., 火鍋, 鐵板燒, 排餐 under 食)
// preferredTimeSlot: morning, lunch, afternoon, dinner, evening, anytime
export const subcategories = pgTable("subcategories", {
  id: serial("id").primaryKey(),
  categoryId: integer("category_id").references(() => categories.id).notNull(),
  code: varchar("code", { length: 100 }).notNull(),
  nameEn: text("name_en").notNull(),
  nameZh: text("name_zh").notNull(),
  nameJa: text("name_ja"),
  nameKo: text("name_ko"),
  searchKeywords: text("search_keywords"),
  preferredTimeSlot: varchar("preferred_time_slot", { length: 20 }).default('anytime'),
  isActive: boolean("is_active").default(true).notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
}, (table) => [
  index("IDX_subcategories_category").on(table.categoryId),
]);

// ============ Session Storage ============

// Session storage table for Replit Auth
export const sessions = pgTable(
  "sessions",
  {
    sid: varchar("sid").primaryKey(),
    sess: jsonb("sess").notNull(),
    expire: timestamp("expire").notNull(),
  },
  (table) => [index("IDX_session_expire").on(table.expire)],
);

// User roles: traveler (default), merchant, specialist, admin
export type UserRole = 'traveler' | 'merchant' | 'specialist' | 'admin';

// Users table - supports Replit Auth, guest login, and email/password auth
export const users = pgTable("users", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  email: varchar("email"),
  password: text("password"), // Hashed password for email auth (null for OAuth users)
  firstName: varchar("first_name"),
  lastName: varchar("last_name"),
  profileImageUrl: varchar("profile_image_url"),
  role: varchar("role", { length: 20 }).default('traveler').notNull(),
  provider: varchar("provider", { length: 20 }), // 'replit' | 'guest' | 'email'
  isApproved: boolean("is_approved").default(false).notNull(), // Requires admin approval for certain roles
  stripeCustomerId: varchar("stripe_customer_id"),
  sosSecretKey: varchar("sos_secret_key", { length: 64 }), // Long-lived SOS webhook key
  isActive: boolean("is_active").default(true).notNull(),
  // 個人資料擴展欄位
  gender: varchar("gender", { length: 10 }), // 'male' | 'female' | 'other'
  birthDate: date("birth_date"),
  phone: varchar("phone", { length: 20 }),
  dietaryRestrictions: text("dietary_restrictions").array(), // 飲食禁忌 (標籤陣列)
  medicalHistory: text("medical_history").array(), // 疾病史 (標籤陣列)
  emergencyContactName: varchar("emergency_contact_name", { length: 100 }),
  emergencyContactPhone: varchar("emergency_contact_phone", { length: 20 }),
  emergencyContactRelation: varchar("emergency_contact_relation", { length: 50 }),
  preferredLanguage: varchar("preferred_language", { length: 10 }).default('zh-TW'), // 'zh-TW' | 'en' | 'ja' | 'ko'
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

// Merchants (商家)
export type MerchantStatus = 'pending' | 'approved' | 'rejected';
export type MerchantLevel = 'free' | 'pro' | 'premium';

export const merchants = pgTable("merchants", {
  id: serial("id").primaryKey(),
  userId: varchar("user_id").references(() => users.id).notNull(),
  // 基本資料
  ownerName: text("owner_name"), // 負責人姓名 (nullable for backward compat)
  businessName: text("business_name"), // 商家名稱 (nullable for backward compat)
  taxId: varchar("tax_id", { length: 20 }), // 統一編號 (選填)
  businessCategory: varchar("business_category", { length: 50 }), // 營業類別
  address: text("address"), // 地點
  phone: varchar("phone", { length: 20 }), // 電話
  mobile: varchar("mobile", { length: 20 }), // 手機
  email: text("email").notNull(),
  // 舊欄位 (保留向下相容)
  name: text("name"), // 保留舊欄位
  subscriptionPlan: text("subscription_plan").default('free').notNull(),
  dailySeedCode: text("daily_seed_code"),
  codeUpdatedAt: timestamp("code_updated_at"),
  creditBalance: integer("credit_balance").default(0).notNull(),
  // 審核與等級
  status: varchar("status", { length: 20 }).default('pending').notNull(), // 'pending' | 'approved' | 'rejected'
  merchantLevel: varchar("merchant_level", { length: 20 }).default('free').notNull(), // 'free' | 'pro' | 'premium'
  rejectionReason: text("rejection_reason"), // 審核拒絕原因
  approvedAt: timestamp("approved_at"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
}, (table) => [
  index("IDX_merchants_user").on(table.userId),
  index("IDX_merchants_status").on(table.status),
]);

// Specialists (專員)
export const specialists = pgTable("specialists", {
  id: serial("id").primaryKey(),
  userId: varchar("user_id").references(() => users.id).notNull(),
  name: text("name").notNull(),
  serviceRegion: text("service_region").notNull(), // 服務地區 (e.g., "taipei", "taichung")
  isAvailable: boolean("is_available").default(true).notNull(), // 是否可接案
  maxTravelers: integer("max_travelers").default(5).notNull(), // 最大同時服務人數
  currentTravelers: integer("current_travelers").default(0).notNull(), // 目前服務人數
  createdAt: timestamp("created_at").defaultNow().notNull(),
}, (table) => [
  index("IDX_specialists_region").on(table.serviceRegion),
]);

// Transactions (交易記錄)
export type PaymentStatus = 'pending' | 'paid' | 'failed' | 'refunded';

export type PaymentProvider = 'stripe' | 'recur';

export const transactions = pgTable("transactions", {
  id: serial("id").primaryKey(),
  merchantId: integer("merchant_id").references(() => merchants.id).notNull(),
  amount: integer("amount").notNull(), // 金額（點數）
  price: integer("price"), // 實際支付金額（TWD）
  provider: varchar("provider", { length: 20 }), // 金流提供者: 'stripe' | 'recur'
  paymentStatus: varchar("payment_status", { length: 20 }).default('pending').notNull(),
  paymentMethod: varchar("payment_method", { length: 50 }), // 付款方式
  externalOrderId: text("external_order_id"), // 外部金流訂單編號
  createdAt: timestamp("created_at").defaultNow().notNull(),
  paidAt: timestamp("paid_at"), // 付款完成時間
}, (table) => [
  index("IDX_transactions_merchant").on(table.merchantId),
]);

// Service Relations (專員-旅客服務關係)
export const serviceRelations = pgTable("service_relations", {
  id: serial("id").primaryKey(),
  specialistId: integer("specialist_id").references(() => specialists.id).notNull(),
  travelerId: varchar("traveler_id").references(() => users.id).notNull(),
  twilioChannelSid: text("twilio_channel_sid"), // Twilio 聊天室 SID
  region: text("region").notNull(), // 服務地區
  status: varchar("status", { length: 20 }).default('active').notNull(), // active, completed, cancelled
  createdAt: timestamp("created_at").defaultNow().notNull(),
  endedAt: timestamp("ended_at"),
}, (table) => [
  index("IDX_service_relations_specialist").on(table.specialistId),
  index("IDX_service_relations_traveler").on(table.travelerId),
]);

// Place cache for AI-generated content
export const placeCache = pgTable("place_cache", {
  id: serial("id").primaryKey(),
  subCategory: text("sub_category").notNull(),
  district: text("district").notNull(),
  city: text("city").notNull(),
  country: text("country").notNull(),
  placeName: text("place_name").notNull(),
  description: text("description").notNull(),
  category: text("category").notNull(),
  suggestedTime: text("suggested_time"),
  duration: text("duration"),
  searchQuery: text("search_query"),
  rarity: text("rarity"),
  colorHex: text("color_hex"),
  placeId: text("place_id"),
  verifiedName: text("verified_name"),
  verifiedAddress: text("verified_address"),
  googleRating: text("google_rating"),
  googleTypes: text("google_types"),
  primaryType: text("primary_type"),
  locationLat: text("location_lat"),
  locationLng: text("location_lng"),
  isLocationVerified: boolean("is_location_verified").default(false),
  businessStatus: varchar("business_status", { length: 50 }),
  lastVerifiedAt: timestamp("last_verified_at"),
  aiReviewed: boolean("ai_reviewed").default(false),
  aiReviewedAt: timestamp("ai_reviewed_at"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
}, (table) => [
  index("IDX_place_cache_lookup").on(table.subCategory, table.district, table.city, table.country),
]);

// Place feedback for exclusion tracking (per-user)
export const placeFeedback = pgTable("place_feedback", {
  id: serial("id").primaryKey(),
  userId: varchar("user_id", { length: 255 }).references(() => users.id),
  placeCacheId: integer("place_cache_id").references(() => placeCache.id),
  placeName: text("place_name").notNull(),
  district: text("district").notNull(),
  city: text("city").notNull(),
  penaltyScore: integer("penalty_score").default(1).notNull(),
  lastInteractedAt: timestamp("last_interacted_at").defaultNow().notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
}, (table) => [
  index("IDX_place_feedback_lookup").on(table.userId, table.placeName, table.district, table.city),
]);

// Gacha Rarity Types
export type GachaRarity = 'SP' | 'SSR' | 'SR' | 'S' | 'R';

// Places - 正式行程卡池 (Google 驗證過的地點)
export const places = pgTable("places", {
  id: serial("id").primaryKey(),
  placeName: text("place_name").notNull(),
  country: text("country").notNull(),
  city: text("city").notNull(),
  district: text("district").notNull(),
  address: text("address"),
  locationLat: doublePrecision("location_lat"),
  locationLng: doublePrecision("location_lng"),
  googlePlaceId: text("google_place_id").unique(),
  rating: doublePrecision("rating"),
  photoReference: text("photo_reference"),
  category: text("category").notNull(),
  subcategory: text("subcategory"),
  description: text("description"),
  merchantId: integer("merchant_id").references(() => merchants.id),
  isPromoActive: boolean("is_promo_active").default(false),
  createdAt: timestamp("created_at").defaultNow().notNull(),
}, (table) => [
  index("IDX_places_google_place_id").on(table.googlePlaceId),
  index("IDX_places_city_district").on(table.city, table.district),
  index("IDX_places_category").on(table.category),
  index("IDX_places_merchant").on(table.merchantId),
]);

// Merchant-Place Links (ownership/claim system) - 單一認領制 / 行程卡
export type CardLevel = 'free' | 'pro' | 'premium';

export const merchantPlaceLinks = pgTable("merchant_place_links", {
  id: serial("id").primaryKey(),
  merchantId: integer("merchant_id").references(() => merchants.id).notNull(),
  officialPlaceId: integer("official_place_id").references(() => places.id).unique(),
  placeCacheId: integer("place_cache_id").references(() => placeCache.id),
  googlePlaceId: text("google_place_id"),
  placeName: text("place_name").notNull(),
  district: text("district").notNull(),
  city: text("city").notNull(),
  country: text("country").notNull(),
  // 行程卡基本資料
  description: text("description"), // 基本介紹
  categoryId: integer("category_id"), // 八大種類 (參照 categories 表)
  googleMapUrl: text("google_map_url"), // Google 地圖連結
  // 審核狀態
  status: varchar("status", { length: 50 }).default('pending').notNull(), // 'pending' | 'approved' | 'rejected'
  rejectionReason: text("rejection_reason"),
  submittedAt: timestamp("submitted_at"),
  approvedAt: timestamp("approved_at"),
  // 行程卡等級與特效
  cardLevel: varchar("card_level", { length: 20 }).default('free').notNull(), // 'free' | 'pro' | 'premium'
  cardFrameEnabled: boolean("card_frame_enabled").default(false), // 是否顯示外框 (Pro+)
  specialEffectEnabled: boolean("special_effect_enabled").default(false), // 抽中時特效 (Premium)
  // 優惠資訊
  couponDropRate: doublePrecision("coupon_drop_rate").default(0.1),
  promoTitle: text("promo_title"),
  promoDescription: text("promo_description"),
  promoImageUrl: text("promo_image_url"),
  inventoryImageUrl: text("inventory_image_url"), // 道具箱圖片 (Pro+)
  isPromoActive: boolean("is_promo_active").default(false),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
}, (table) => [
  index("IDX_merchant_place_links_lookup").on(table.placeName, table.district, table.city),
  index("IDX_merchant_place_links_merchant").on(table.merchantId),
  index("IDX_merchant_place_links_google_place_id").on(table.googlePlaceId),
  index("IDX_merchant_place_links_official").on(table.officialPlaceId),
  index("IDX_merchant_place_links_status").on(table.status),
]);

// Merchant coupons
export const coupons = pgTable("coupons", {
  id: serial("id").primaryKey(),
  merchantId: integer("merchant_id").references(() => merchants.id).notNull(),
  merchantPlaceLinkId: integer("merchant_place_link_id").references(() => merchantPlaceLinks.id),
  placeId: integer("place_id").references(() => places.id),
  placeName: text("place_name").notNull(),
  title: text("title").notNull(),
  code: text("code").notNull(),
  terms: text("terms"),
  rarity: varchar("rarity", { length: 10 }),
  dropRate: doublePrecision("drop_rate"),
  remainingQuantity: integer("remaining_quantity").default(0).notNull(),
  redeemedCount: integer("redeemed_count").default(0).notNull(),
  impressionCount: integer("impression_count").default(0).notNull(),
  isActive: boolean("is_active").default(true).notNull(),
  archived: boolean("archived").default(false).notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

// User's collected places (圖鑑/背包)
export const collections = pgTable("collections", {
  id: serial("id").primaryKey(),
  userId: varchar("user_id").references(() => users.id).notNull(),
  officialPlaceId: integer("official_place_id").references(() => places.id),
  placeName: text("place_name").notNull(),
  country: text("country").notNull(),
  city: text("city").notNull(),
  district: text("district"),
  category: text("category"),
  subcategory: text("subcategory"),
  description: text("description"),
  address: text("address"),
  placeId: text("place_id"),
  rating: text("rating"),
  locationLat: text("location_lat"),
  locationLng: text("location_lng"),
  googleTypes: text("google_types"),
  isCoupon: boolean("is_coupon").default(false),
  couponData: jsonb("coupon_data"),
  wonCouponId: integer("won_coupon_id").references(() => coupons.id),
  collectedAt: timestamp("collected_at").defaultNow().notNull(),
}, (table) => [
  index("IDX_collections_user_place").on(table.userId, table.placeName, table.district),
  index("IDX_collections_official_place").on(table.officialPlaceId),
]);

// ============ Relations ============

// Location hierarchy relations
export const countriesRelations = relations(countries, ({ many }) => ({
  regions: many(regions),
}));

export const regionsRelations = relations(regions, ({ one, many }) => ({
  country: one(countries, {
    fields: [regions.countryId],
    references: [countries.id],
  }),
  districts: many(districts),
}));

export const districtsRelations = relations(districts, ({ one }) => ({
  region: one(regions, {
    fields: [districts.regionId],
    references: [regions.id],
  }),
}));

// Category hierarchy relations
export const categoriesRelations = relations(categories, ({ many }) => ({
  subcategories: many(subcategories),
}));

export const subcategoriesRelations = relations(subcategories, ({ one }) => ({
  category: one(categories, {
    fields: [subcategories.categoryId],
    references: [categories.id],
  }),
}));

// User relations
export const usersRelations = relations(users, ({ many }) => ({
  collections: many(collections),
  merchants: many(merchants),
}));

export const collectionsRelations = relations(collections, ({ one }) => ({
  user: one(users, {
    fields: [collections.userId],
    references: [users.id],
  }),
}));

export const merchantsRelations = relations(merchants, ({ one, many }) => ({
  user: one(users, {
    fields: [merchants.userId],
    references: [users.id],
  }),
  coupons: many(coupons),
}));

export const couponsRelations = relations(coupons, ({ one }) => ({
  merchant: one(merchants, {
    fields: [coupons.merchantId],
    references: [merchants.id],
  }),
  place: one(places, {
    fields: [coupons.placeId],
    references: [places.id],
  }),
}));

// Places relations
export const placesRelations = relations(places, ({ one, many }) => ({
  merchant: one(merchants, {
    fields: [places.merchantId],
    references: [merchants.id],
  }),
  coupons: many(coupons),
}));

// Insert/Upsert schemas
export const upsertUserSchema = createInsertSchema(users);

// Registration schema for email/password signup
export const registerUserSchema = z.object({
  email: z.string().email("請輸入有效的電子郵件"),
  password: z.string().min(8, "密碼至少需要 8 個字元"),
  firstName: z.string().optional(),
  lastName: z.string().optional(),
  role: z.enum(['traveler', 'merchant', 'specialist', 'admin']).default('traveler'),
});

// Profile update schema (for settings page)
export const updateProfileSchema = z.object({
  firstName: z.string().optional(),
  lastName: z.string().optional(),
  gender: z.enum(['male', 'female', 'other']).optional(),
  birthDate: z.string().optional(), // ISO date string
  phone: z.string().optional(),
  dietaryRestrictions: z.array(z.string()).optional(),
  medicalHistory: z.array(z.string()).optional(),
  emergencyContactName: z.string().optional(),
  emergencyContactPhone: z.string().optional(),
  emergencyContactRelation: z.string().optional(),
  preferredLanguage: z.enum(['zh-TW', 'en', 'ja', 'ko']).optional(),
});

export type UpdateProfileInput = z.infer<typeof updateProfileSchema>;

export const insertCollectionSchema = createInsertSchema(collections).omit({
  id: true,
  collectedAt: true,
});

export const insertMerchantSchema = createInsertSchema(merchants).omit({
  id: true,
  status: true,
  approvedAt: true,
  createdAt: true,
  updatedAt: true,
}).extend({
  // Make new fields optional for backwards compatibility
  ownerName: z.string().optional(),
  businessName: z.string().optional(),
});

// 商家註冊 Schema (送審用)
export const merchantRegisterSchema = z.object({
  ownerName: z.string().min(1, "請輸入負責人姓名"),
  businessName: z.string().min(1, "請輸入商家名稱"),
  taxId: z.string().optional(), // 統一編號 (選填)
  businessCategory: z.string().min(1, "請選擇營業類別"),
  address: z.string().min(1, "請輸入地點"),
  phone: z.string().optional(),
  mobile: z.string().min(1, "請輸入手機號碼"),
  email: z.string().email("請輸入有效的 Email"),
});

export type MerchantRegisterInput = z.infer<typeof merchantRegisterSchema>;

export const insertSpecialistSchema = createInsertSchema(specialists).omit({
  id: true,
  createdAt: true,
});

export const insertTransactionSchema = createInsertSchema(transactions).omit({
  id: true,
  createdAt: true,
});

export const insertServiceRelationSchema = createInsertSchema(serviceRelations).omit({
  id: true,
  createdAt: true,
});

export const insertCouponSchema = createInsertSchema(coupons).omit({
  id: true,
  createdAt: true,
});

export const insertMerchantPlaceLinkSchema = createInsertSchema(merchantPlaceLinks).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const insertPlaceCacheSchema = createInsertSchema(placeCache).omit({
  id: true,
  createdAt: true,
});

export const insertPlaceFeedbackSchema = createInsertSchema(placeFeedback).omit({
  id: true,
  createdAt: true,
});

export const insertPlaceSchema = createInsertSchema(places).omit({
  id: true,
  createdAt: true,
});

// Location schemas
export const insertCountrySchema = createInsertSchema(countries).omit({
  id: true,
  createdAt: true,
});

export const insertRegionSchema = createInsertSchema(regions).omit({
  id: true,
  createdAt: true,
});

export const insertDistrictSchema = createInsertSchema(districts).omit({
  id: true,
  createdAt: true,
});

// Category schemas
export const insertCategorySchema = createInsertSchema(categories).omit({
  id: true,
  createdAt: true,
});

export const insertSubcategorySchema = createInsertSchema(subcategories).omit({
  id: true,
  createdAt: true,
});

// Types
export type UpsertUser = typeof users.$inferInsert;
export type User = typeof users.$inferSelect;

export type InsertCollection = z.infer<typeof insertCollectionSchema>;
export type Collection = typeof collections.$inferSelect;

export type InsertMerchant = z.infer<typeof insertMerchantSchema>;
export type Merchant = typeof merchants.$inferSelect;

export type InsertSpecialist = z.infer<typeof insertSpecialistSchema>;
export type Specialist = typeof specialists.$inferSelect;

export type InsertTransaction = z.infer<typeof insertTransactionSchema>;
export type Transaction = typeof transactions.$inferSelect;

export type InsertServiceRelation = z.infer<typeof insertServiceRelationSchema>;
export type ServiceRelation = typeof serviceRelations.$inferSelect;

export type InsertCoupon = z.infer<typeof insertCouponSchema>;
export type Coupon = typeof coupons.$inferSelect;

export type InsertMerchantPlaceLink = z.infer<typeof insertMerchantPlaceLinkSchema>;
export type MerchantPlaceLink = typeof merchantPlaceLinks.$inferSelect;

export type InsertPlaceCache = z.infer<typeof insertPlaceCacheSchema>;
export type PlaceCache = typeof placeCache.$inferSelect;

export type InsertPlaceFeedback = z.infer<typeof insertPlaceFeedbackSchema>;
export type PlaceFeedback = typeof placeFeedback.$inferSelect;

export type InsertPlace = z.infer<typeof insertPlaceSchema>;
export type Place = typeof places.$inferSelect;

// Location types
export type InsertCountry = z.infer<typeof insertCountrySchema>;
export type Country = typeof countries.$inferSelect;

export type InsertRegion = z.infer<typeof insertRegionSchema>;
export type Region = typeof regions.$inferSelect;

export type InsertDistrict = z.infer<typeof insertDistrictSchema>;
export type District = typeof districts.$inferSelect;

// Category types
export type InsertCategory = z.infer<typeof insertCategorySchema>;
export type Category = typeof categories.$inferSelect;

export type InsertSubcategory = z.infer<typeof insertSubcategorySchema>;
export type Subcategory = typeof subcategories.$inferSelect;

// ============ Trip Planner Module Tables ============

export const tripPlans = pgTable("trip_plans", {
  id: serial("id").primaryKey(),
  userId: varchar("user_id").references(() => users.id).notNull(),
  title: text("title").notNull(),
  destination: text("destination").notNull(),
  destinationDistrict: text("destination_district"),
  destinationCity: text("destination_city"),
  destinationCountry: text("destination_country"),
  startDate: text("start_date").notNull(),
  endDate: text("end_date").notNull(),
  status: varchar("status", { length: 20 }).default('draft').notNull(),
  coverImageUrl: text("cover_image_url"),
  notes: text("notes"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
}, (table) => [
  index("IDX_trip_plans_user").on(table.userId),
  index("IDX_trip_plans_status").on(table.status),
]);

export const tripDays = pgTable("trip_days", {
  id: serial("id").primaryKey(),
  tripPlanId: integer("trip_plan_id").references(() => tripPlans.id).notNull(),
  dayNumber: integer("day_number").notNull(),
  date: text("date").notNull(),
  title: text("title"),
  notes: text("notes"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
}, (table) => [
  index("IDX_trip_days_plan").on(table.tripPlanId),
]);

export const tripActivities = pgTable("trip_activities", {
  id: serial("id").primaryKey(),
  tripDayId: integer("trip_day_id").references(() => tripDays.id).notNull(),
  orderIndex: integer("order_index").default(0).notNull(),
  timeSlot: varchar("time_slot", { length: 20 }).default('morning').notNull(),
  placeName: text("place_name").notNull(),
  placeId: text("place_id"),
  category: text("category"),
  subcategory: text("subcategory"),
  description: text("description"),
  address: text("address"),
  locationLat: text("location_lat"),
  locationLng: text("location_lng"),
  duration: integer("duration"),
  notes: text("notes"),
  isFromGacha: boolean("is_from_gacha").default(false),
  createdAt: timestamp("created_at").defaultNow().notNull(),
}, (table) => [
  index("IDX_trip_activities_day").on(table.tripDayId),
]);

export const tripPlansRelations = relations(tripPlans, ({ one, many }) => ({
  user: one(users, {
    fields: [tripPlans.userId],
    references: [users.id],
  }),
  days: many(tripDays),
}));

export const tripDaysRelations = relations(tripDays, ({ one, many }) => ({
  tripPlan: one(tripPlans, {
    fields: [tripDays.tripPlanId],
    references: [tripPlans.id],
  }),
  activities: many(tripActivities),
}));

export const tripActivitiesRelations = relations(tripActivities, ({ one }) => ({
  tripDay: one(tripDays, {
    fields: [tripActivities.tripDayId],
    references: [tripDays.id],
  }),
}));

export const insertTripPlanSchema = createInsertSchema(tripPlans).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const insertTripDaySchema = createInsertSchema(tripDays).omit({
  id: true,
  createdAt: true,
});

export const insertTripActivitySchema = createInsertSchema(tripActivities).omit({
  id: true,
  createdAt: true,
});

export type TripPlan = typeof tripPlans.$inferSelect;
export type InsertTripPlan = z.infer<typeof insertTripPlanSchema>;
export type TripDay = typeof tripDays.$inferSelect;
export type InsertTripDay = z.infer<typeof insertTripDaySchema>;
export type TripActivity = typeof tripActivities.$inferSelect;
export type InsertTripActivity = z.infer<typeof insertTripActivitySchema>;

// ============ Planner Service Tables ============

// Planners - 旅程策劃師
export const planners = pgTable("planners", {
  id: serial("id").primaryKey(),
  userId: varchar("user_id").references(() => users.id).notNull(),
  displayName: text("display_name").notNull(),
  bio: text("bio"),
  profileImageUrl: text("profile_image_url"),
  specialties: text("specialties").array(),
  languages: text("languages").array(),
  rating: integer("rating").default(0),
  totalOrders: integer("total_orders").default(0),
  isAvailable: boolean("is_available").default(true).notNull(),
  isVerified: boolean("is_verified").default(false).notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
}, (table) => [
  index("IDX_planners_user").on(table.userId),
  index("IDX_planners_available").on(table.isAvailable),
]);

// Service Plans - 服務方案
export const servicePlans = pgTable("service_plans", {
  id: serial("id").primaryKey(),
  code: varchar("code", { length: 50 }).notNull().unique(),
  nameZh: text("name_zh").notNull(),
  nameEn: text("name_en").notNull(),
  description: text("description"),
  features: text("features").array(),
  priceNtd: integer("price_ntd").notNull(),
  priceUsd: integer("price_usd"),
  durationDays: integer("duration_days").default(7),
  maxMessages: integer("max_messages"),
  sortOrder: integer("sort_order").default(0),
  isActive: boolean("is_active").default(true).notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

// Service Orders - 服務訂單
export type OrderStatus = 'pending' | 'paid' | 'assigned' | 'in_progress' | 'completed' | 'cancelled' | 'refunded';
export type PaymentMethod = 'stripe' | 'payuni' | 'manual';

export const serviceOrders = pgTable("service_orders", {
  id: serial("id").primaryKey(),
  orderNumber: varchar("order_number", { length: 50 }).notNull().unique(),
  userId: varchar("user_id").references(() => users.id).notNull(),
  servicePlanId: integer("service_plan_id").references(() => servicePlans.id).notNull(),
  plannerId: integer("planner_id").references(() => planners.id),
  status: varchar("status", { length: 20 }).default('pending').notNull(),
  paymentMethod: varchar("payment_method", { length: 20 }),
  paymentId: varchar("payment_id", { length: 100 }),
  amountPaid: integer("amount_paid"),
  currency: varchar("currency", { length: 10 }).default('TWD'),
  conversationSid: varchar("conversation_sid", { length: 50 }),
  notes: text("notes"),
  paidAt: timestamp("paid_at"),
  assignedAt: timestamp("assigned_at"),
  completedAt: timestamp("completed_at"),
  expiresAt: timestamp("expires_at"),
  verificationCode: varchar("verification_code", { length: 8 }),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
}, (table) => [
  index("IDX_orders_user").on(table.userId),
  index("IDX_orders_planner").on(table.plannerId),
  index("IDX_orders_status").on(table.status),
]);

// Relations
export const plannersRelations = relations(planners, ({ one, many }) => ({
  user: one(users, {
    fields: [planners.userId],
    references: [users.id],
  }),
  orders: many(serviceOrders),
}));

export const servicePlansRelations = relations(servicePlans, ({ many }) => ({
  orders: many(serviceOrders),
}));

export const serviceOrdersRelations = relations(serviceOrders, ({ one }) => ({
  user: one(users, {
    fields: [serviceOrders.userId],
    references: [users.id],
  }),
  servicePlan: one(servicePlans, {
    fields: [serviceOrders.servicePlanId],
    references: [servicePlans.id],
  }),
  planner: one(planners, {
    fields: [serviceOrders.plannerId],
    references: [planners.id],
  }),
}));

// Insert schemas
export const insertPlannerSchema = createInsertSchema(planners).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const insertServicePlanSchema = createInsertSchema(servicePlans).omit({
  id: true,
  createdAt: true,
});

export const insertServiceOrderSchema = createInsertSchema(serviceOrders).omit({
  id: true,
  orderNumber: true,
  createdAt: true,
  updatedAt: true,
});

// Types
export type Planner = typeof planners.$inferSelect;
export type InsertPlanner = z.infer<typeof insertPlannerSchema>;
export type ServicePlan = typeof servicePlans.$inferSelect;
export type InsertServicePlan = z.infer<typeof insertServicePlanSchema>;
export type ServiceOrder = typeof serviceOrders.$inferSelect;
export type InsertServiceOrder = z.infer<typeof insertServiceOrderSchema>;

// ============ Travel Companions Tables ============

// Travel Companions - 已確認的旅伴
export type CompanionRole = 'owner' | 'companion';
export type CompanionStatus = 'active' | 'removed';

export const travelCompanions = pgTable("travel_companions", {
  id: serial("id").primaryKey(),
  orderId: integer("order_id").references(() => serviceOrders.id).notNull(),
  userId: varchar("user_id").references(() => users.id).notNull(),
  role: varchar("role", { length: 20 }).default('companion').notNull(),
  status: varchar("status", { length: 20 }).default('active').notNull(),
  joinedAt: timestamp("joined_at").defaultNow().notNull(),
}, (table) => [
  index("IDX_companions_order").on(table.orderId),
  index("IDX_companions_user").on(table.userId),
]);

// Companion Invites - 待確認的邀請
export type InviteStatus = 'pending' | 'accepted' | 'declined' | 'expired' | 'revoked';

export const companionInvites = pgTable("companion_invites", {
  id: serial("id").primaryKey(),
  orderId: integer("order_id").references(() => serviceOrders.id).notNull(),
  inviterUserId: varchar("inviter_user_id").references(() => users.id).notNull(),
  inviteeEmail: varchar("invitee_email", { length: 255 }),
  inviteeUserId: varchar("invitee_user_id").references(() => users.id),
  inviteCode: varchar("invite_code", { length: 50 }).notNull().unique(),
  status: varchar("status", { length: 20 }).default('pending').notNull(),
  expiresAt: timestamp("expires_at").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
}, (table) => [
  index("IDX_invites_order").on(table.orderId),
  index("IDX_invites_code").on(table.inviteCode),
]);

// Relations
export const travelCompanionsRelations = relations(travelCompanions, ({ one }) => ({
  order: one(serviceOrders, {
    fields: [travelCompanions.orderId],
    references: [serviceOrders.id],
  }),
  user: one(users, {
    fields: [travelCompanions.userId],
    references: [users.id],
  }),
}));

export const companionInvitesRelations = relations(companionInvites, ({ one }) => ({
  order: one(serviceOrders, {
    fields: [companionInvites.orderId],
    references: [serviceOrders.id],
  }),
  inviter: one(users, {
    fields: [companionInvites.inviterUserId],
    references: [users.id],
  }),
}));

// Chat Invites - 聊天室邀請連結
export const chatInvites = pgTable("chat_invites", {
  id: serial("id").primaryKey(),
  conversationSid: varchar("conversation_sid", { length: 100 }).notNull(),
  inviterUserId: varchar("inviter_user_id").references(() => users.id).notNull(),
  inviteCode: varchar("invite_code", { length: 50 }).notNull().unique(),
  status: varchar("status", { length: 20 }).default('pending').notNull(),
  usedByUserId: varchar("used_by_user_id").references(() => users.id),
  expiresAt: timestamp("expires_at").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
}, (table) => [
  index("IDX_chat_invites_code").on(table.inviteCode),
  index("IDX_chat_invites_conversation").on(table.conversationSid),
]);

// ============ User Locations (位置共享) ============

export const userLocations = pgTable("user_locations", {
  id: serial("id").primaryKey(),
  userId: varchar("user_id").references(() => users.id).notNull().unique(),
  lat: doublePrecision("lat").notNull(),
  lon: doublePrecision("lon").notNull(),
  isSharingEnabled: boolean("is_sharing_enabled").default(true).notNull(),
  sosMode: boolean("sos_mode").default(false).notNull(), // Emergency SOS mode - forces location sharing
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
}, (table) => [
  index("IDX_user_locations_user").on(table.userId),
  index("IDX_user_locations_sharing").on(table.isSharingEnabled),
]);

export const userLocationsRelations = relations(userLocations, ({ one }) => ({
  user: one(users, {
    fields: [userLocations.userId],
    references: [users.id],
  }),
}));

export const insertUserLocationSchema = createInsertSchema(userLocations).omit({
  id: true,
  updatedAt: true,
});

export type UserLocation = typeof userLocations.$inferSelect;
export type InsertUserLocation = z.infer<typeof insertUserLocationSchema>;

// Insert schemas
export const insertTravelCompanionSchema = createInsertSchema(travelCompanions).omit({
  id: true,
  joinedAt: true,
});

export const insertCompanionInviteSchema = createInsertSchema(companionInvites).omit({
  id: true,
  inviteCode: true,
  createdAt: true,
});

export const insertChatInviteSchema = createInsertSchema(chatInvites).omit({
  id: true,
  inviteCode: true,
  createdAt: true,
});

// Types
export type TravelCompanion = typeof travelCompanions.$inferSelect;
export type InsertTravelCompanion = z.infer<typeof insertTravelCompanionSchema>;
export type CompanionInvite = typeof companionInvites.$inferSelect;
export type InsertCompanionInvite = z.infer<typeof insertCompanionInviteSchema>;
export type ChatInvite = typeof chatInvites.$inferSelect;
export type InsertChatInvite = z.infer<typeof insertChatInviteSchema>;

// =====================================================
// 聊天商務系統 (In-Chat Commerce)
// =====================================================

// Place Products - 商家商品/服務
export const placeProducts = pgTable("place_products", {
  id: serial("id").primaryKey(),
  placeCacheId: integer("place_cache_id").references(() => placeCache.id),
  merchantId: integer("merchant_id").references(() => merchants.id),
  name: varchar("name", { length: 200 }).notNull(),
  description: text("description"),
  price: integer("price").notNull(),
  currency: varchar("currency", { length: 10 }).default('TWD').notNull(),
  category: varchar("category", { length: 50 }),
  imageUrl: text("image_url"),
  stripeProductId: varchar("stripe_product_id", { length: 100 }),
  stripePriceId: varchar("stripe_price_id", { length: 100 }),
  isActive: boolean("is_active").default(true).notNull(),
  stock: integer("stock"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
}, (table) => [
  index("IDX_place_products_place").on(table.placeCacheId),
  index("IDX_place_products_merchant").on(table.merchantId),
]);

// Cart Items - 購物車項目
export const cartItems = pgTable("cart_items", {
  id: serial("id").primaryKey(),
  userId: varchar("user_id").references(() => users.id).notNull(),
  productId: integer("product_id").references(() => placeProducts.id).notNull(),
  quantity: integer("quantity").default(1).notNull(),
  addedAt: timestamp("added_at").defaultNow().notNull(),
}, (table) => [
  index("IDX_cart_items_user").on(table.userId),
]);

// Commerce Orders - 商務訂單
export const commerceOrders = pgTable("commerce_orders", {
  id: serial("id").primaryKey(),
  userId: varchar("user_id").references(() => users.id).notNull(),
  stripeSessionId: varchar("stripe_session_id", { length: 200 }),
  stripePaymentIntentId: varchar("stripe_payment_intent_id", { length: 200 }),
  status: varchar("status", { length: 30 }).default('pending').notNull(),
  totalAmount: integer("total_amount").notNull(),
  currency: varchar("currency", { length: 10 }).default('TWD').notNull(),
  items: jsonb("items").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
}, (table) => [
  index("IDX_commerce_orders_user").on(table.userId),
  index("IDX_commerce_orders_session").on(table.stripeSessionId),
]);

// Insert schemas for commerce
export const insertPlaceProductSchema = createInsertSchema(placeProducts).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const insertCartItemSchema = createInsertSchema(cartItems).omit({
  id: true,
  addedAt: true,
});

export const insertCommerceOrderSchema = createInsertSchema(commerceOrders).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

// Commerce types
export type PlaceProduct = typeof placeProducts.$inferSelect;
export type InsertPlaceProduct = z.infer<typeof insertPlaceProductSchema>;
export type CartItem = typeof cartItems.$inferSelect;
export type InsertCartItem = z.infer<typeof insertCartItemSchema>;
export type CommerceOrder = typeof commerceOrders.$inferSelect;
export type InsertCommerceOrder = z.infer<typeof insertCommerceOrderSchema>;

// =====================================================
// KLOOK INTEGRATION TABLES
// =====================================================

// Klook Products Cache - Klook 商品快取
export const klookProducts = pgTable("klook_products", {
  id: serial("id").primaryKey(),
  name: text("name").notNull(),
  nameNormalized: text("name_normalized").notNull(),
  klookUrl: text("klook_url").notNull(),
  category: text("category"),
  region: text("region"),
  isActive: boolean("is_active").default(true).notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
}, (table) => [
  index("IDX_klook_products_name").on(table.nameNormalized),
  index("IDX_klook_products_region").on(table.region),
]);

// Message Highlights - 訊息中的 Klook 商品標記
export const messageHighlights = pgTable("message_highlights", {
  id: serial("id").primaryKey(),
  conversationSid: varchar("conversation_sid", { length: 100 }).notNull(),
  messageSid: varchar("message_sid", { length: 100 }).notNull(),
  productName: text("product_name").notNull(),
  productUrl: text("product_url").notNull(),
  startIndex: integer("start_index").notNull(),
  endIndex: integer("end_index").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
}, (table) => [
  index("IDX_message_highlights_conversation").on(table.conversationSid),
  index("IDX_message_highlights_message").on(table.messageSid),
]);

// Klook insert schemas
export const insertKlookProductSchema = createInsertSchema(klookProducts).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const insertMessageHighlightSchema = createInsertSchema(messageHighlights).omit({
  id: true,
  createdAt: true,
});

// Klook types
export type KlookProduct = typeof klookProducts.$inferSelect;
export type InsertKlookProduct = z.infer<typeof insertKlookProductSchema>;
export type MessageHighlight = typeof messageHighlights.$inferSelect;
export type InsertMessageHighlight = z.infer<typeof insertMessageHighlightSchema>;

// =====================================================
// 商家地點申請系統 (Place Application System)
// =====================================================

// Place Drafts - 草稿地點（待審核）
export type PlaceDraftStatus = 'pending' | 'approved' | 'rejected';

export type DraftSource = 'ai' | 'merchant';
export type DraftStatus = 'pending' | 'approved' | 'rejected';

export const placeDrafts = pgTable("place_drafts", {
  id: serial("id").primaryKey(),
  merchantId: integer("merchant_id").references(() => merchants.id),
  source: varchar("source", { length: 20 }).default('merchant').notNull(),
  placeName: text("place_name").notNull(),
  categoryId: integer("category_id").references(() => categories.id).notNull(),
  subcategoryId: integer("subcategory_id").references(() => subcategories.id).notNull(),
  description: text("description"),
  districtId: integer("district_id").references(() => districts.id).notNull(),
  regionId: integer("region_id").references(() => regions.id).notNull(),
  countryId: integer("country_id").references(() => countries.id).notNull(),
  address: text("address"),
  googlePlaceId: text("google_place_id"),
  googleRating: doublePrecision("google_rating"),
  googleReviewCount: integer("google_review_count"), // 評論數
  locationLat: text("location_lat"),
  locationLng: text("location_lng"),
  status: varchar("status", { length: 20 }).default('pending').notNull(),
  approvedPlaceId: integer("approved_place_id").references(() => places.id),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
}, (table) => [
  index("IDX_place_drafts_merchant").on(table.merchantId),
  index("IDX_place_drafts_status").on(table.status),
  index("IDX_place_drafts_district").on(table.districtId),
  index("IDX_place_drafts_source").on(table.source),
]);

// Place Applications - 申請紀錄（審核流程）
export type ApplicationStatus = 'pending' | 'approved' | 'rejected';

export const placeApplications = pgTable("place_applications", {
  id: serial("id").primaryKey(),
  merchantId: integer("merchant_id").references(() => merchants.id).notNull(),
  placeDraftId: integer("place_draft_id").references(() => placeDrafts.id).notNull(),
  status: varchar("status", { length: 20 }).default('pending').notNull(),
  reviewedBy: varchar("reviewed_by").references(() => users.id),
  reviewedAt: timestamp("reviewed_at"),
  reviewNotes: text("review_notes"),
  placeCacheId: integer("place_cache_id").references(() => placeCache.id),
  createdAt: timestamp("created_at").defaultNow().notNull(),
}, (table) => [
  index("IDX_place_applications_merchant").on(table.merchantId),
  index("IDX_place_applications_status").on(table.status),
  index("IDX_place_applications_draft").on(table.placeDraftId),
]);

// Relations for Place Application System
export const placeDraftsRelations = relations(placeDrafts, ({ one, many }) => ({
  merchant: one(merchants, {
    fields: [placeDrafts.merchantId],
    references: [merchants.id],
  }),
  category: one(categories, {
    fields: [placeDrafts.categoryId],
    references: [categories.id],
  }),
  subcategory: one(subcategories, {
    fields: [placeDrafts.subcategoryId],
    references: [subcategories.id],
  }),
  district: one(districts, {
    fields: [placeDrafts.districtId],
    references: [districts.id],
  }),
  region: one(regions, {
    fields: [placeDrafts.regionId],
    references: [regions.id],
  }),
  country: one(countries, {
    fields: [placeDrafts.countryId],
    references: [countries.id],
  }),
  applications: many(placeApplications),
}));

export const placeApplicationsRelations = relations(placeApplications, ({ one }) => ({
  merchant: one(merchants, {
    fields: [placeApplications.merchantId],
    references: [merchants.id],
  }),
  placeDraft: one(placeDrafts, {
    fields: [placeApplications.placeDraftId],
    references: [placeDrafts.id],
  }),
  reviewer: one(users, {
    fields: [placeApplications.reviewedBy],
    references: [users.id],
  }),
  placeCache: one(placeCache, {
    fields: [placeApplications.placeCacheId],
    references: [placeCache.id],
  }),
}));

// Insert schemas for Place Application System
// status 保留可傳入，預設為 'pending'，AutoDraft 會傳 'auto_generated'
export const insertPlaceDraftSchema = createInsertSchema(placeDrafts).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const insertPlaceApplicationSchema = createInsertSchema(placeApplications).omit({
  id: true,
  status: true,
  reviewedBy: true,
  reviewedAt: true,
  reviewNotes: true,
  placeCacheId: true,
  createdAt: true,
});

// Types for Place Application System
export type PlaceDraft = typeof placeDrafts.$inferSelect;
export type InsertPlaceDraft = z.infer<typeof insertPlaceDraftSchema>;
export type PlaceApplication = typeof placeApplications.$inferSelect;
export type InsertPlaceApplication = z.infer<typeof insertPlaceApplicationSchema>;

// ============ SOS Events Table ============

export type SosEventStatus = 'pending' | 'processing' | 'resolved' | 'false_alarm';

export const sosEvents = pgTable("sos_events", {
  id: serial("id").primaryKey(),
  userId: varchar("user_id").references(() => users.id).notNull(),
  locationLat: text("location_lat"),
  locationLng: text("location_lng"),
  status: varchar("status", { length: 20 }).default('pending').notNull(),
  resolvedBy: varchar("resolved_by").references(() => users.id),
  resolvedAt: timestamp("resolved_at"),
  audioUrl: text("audio_url"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
}, (table) => [
  index("IDX_sos_events_user").on(table.userId),
  index("IDX_sos_events_status").on(table.status),
]);

export const sosEventsRelations = relations(sosEvents, ({ one }) => ({
  user: one(users, {
    fields: [sosEvents.userId],
    references: [users.id],
  }),
  resolver: one(users, {
    fields: [sosEvents.resolvedBy],
    references: [users.id],
  }),
}));

export const insertSosEventSchema = createInsertSchema(sosEvents).omit({
  id: true,
  createdAt: true,
});

export type SosEvent = typeof sosEvents.$inferSelect;
export type InsertSosEvent = z.infer<typeof insertSosEventSchema>;

// ============ Announcements & Events System ============

// Announcement types: announcement (公告), flash_event (快閃活動), holiday_event (節日限定活動)
export type AnnouncementType = 'announcement' | 'flash_event' | 'holiday_event';

export const announcements = pgTable("announcements", {
  id: serial("id").primaryKey(),
  type: varchar("type", { length: 20 }).default('announcement').notNull(),
  title: text("title").notNull(),
  content: text("content").notNull(),
  imageUrl: text("image_url"),
  linkUrl: text("link_url"),
  startDate: timestamp("start_date").defaultNow().notNull(),
  endDate: timestamp("end_date"), // null = permanent (for regular announcements)
  isActive: boolean("is_active").default(true).notNull(),
  priority: integer("priority").default(0).notNull(), // Higher = show first
  createdBy: varchar("created_by").references(() => users.id).notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
}, (table) => [
  index("IDX_announcements_type").on(table.type),
  index("IDX_announcements_dates").on(table.startDate, table.endDate),
  index("IDX_announcements_active").on(table.isActive),
]);

export const announcementsRelations = relations(announcements, ({ one }) => ({
  creator: one(users, {
    fields: [announcements.createdBy],
    references: [users.id],
  }),
}));

export const insertAnnouncementSchema = createInsertSchema(announcements).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export type Announcement = typeof announcements.$inferSelect;
export type InsertAnnouncement = z.infer<typeof insertAnnouncementSchema>;

// ============ Enhanced Coupon System with Tiers ============

// Coupon tier: SP (2%), SSR (8%), SR (15%), S (23%), R (32%)
export type CouponTier = 'SP' | 'SSR' | 'SR' | 'S' | 'R';

export const couponTierProbabilities: Record<CouponTier, number> = {
  SP: 0.02,
  SSR: 0.08,
  SR: 0.15,
  S: 0.23,
  R: 0.32,
};

// Enhanced coupons table (extends existing coupons)
export const merchantCoupons = pgTable("merchant_coupons", {
  id: serial("id").primaryKey(),
  merchantId: integer("merchant_id").references(() => merchants.id).notNull(),
  merchantPlaceLinkId: integer("merchant_place_link_id").references(() => merchantPlaceLinks.id),
  name: text("name").notNull(),
  tier: varchar("tier", { length: 10 }).default('R').notNull(), // SP, SSR, SR, S, R
  terms: text("terms"), // 使用條款
  content: text("content").notNull(), // 優惠內容
  quantity: integer("quantity").default(-1).notNull(), // -1 = unlimited
  usedCount: integer("used_count").default(0).notNull(),
  validFrom: timestamp("valid_from").defaultNow().notNull(),
  validUntil: timestamp("valid_until"), // null = no expiry
  backgroundImageUrl: text("background_image_url"),
  inventoryImageUrl: text("inventory_image_url"), // For S+ tiers
  isActive: boolean("is_active").default(true).notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
}, (table) => [
  index("IDX_merchant_coupons_merchant").on(table.merchantId),
  index("IDX_merchant_coupons_tier").on(table.tier),
  index("IDX_merchant_coupons_active").on(table.isActive),
]);

export const insertMerchantCouponSchema = createInsertSchema(merchantCoupons).omit({
  id: true,
  usedCount: true,
  createdAt: true,
  updatedAt: true,
});

export type MerchantCoupon = typeof merchantCoupons.$inferSelect;
export type InsertMerchantCoupon = z.infer<typeof insertMerchantCouponSchema>;

// ============ Merchant Analytics (商家數據分析) ============

export const merchantAnalytics = pgTable("merchant_analytics", {
  id: serial("id").primaryKey(),
  merchantId: integer("merchant_id").references(() => merchants.id).notNull(),
  placeId: integer("place_id").references(() => merchantPlaceLinks.id), // 行程卡 ID (null = 商家總計)
  date: date("date").notNull(), // 統計日期
  // 數據指標
  collectedCount: integer("collected_count").default(0).notNull(), // 當日被收錄圖鑑卡人數
  totalCollectors: integer("total_collectors").default(0).notNull(), // 累計已有圖鑑卡人數
  clickCount: integer("click_count").default(0).notNull(), // 圖鑑被點擊次數
  couponUsageCount: integer("coupon_usage_count").default(0).notNull(), // 優惠券總使用次數
  couponIssuedCount: integer("coupon_issued_count").default(0).notNull(), // 優惠券發放數
  prizePoolViews: integer("prize_pool_views").default(0).notNull(), // 被查看獎池人數
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
}, (table) => [
  index("IDX_merchant_analytics_merchant").on(table.merchantId),
  index("IDX_merchant_analytics_place").on(table.placeId),
  index("IDX_merchant_analytics_date").on(table.date),
]);

export const insertMerchantAnalyticsSchema = createInsertSchema(merchantAnalytics).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export type MerchantAnalytics = typeof merchantAnalytics.$inferSelect;
export type InsertMerchantAnalytics = z.infer<typeof insertMerchantAnalyticsSchema>;

// ============ User Inventory System (道具箱) ============

export type InventoryItemType = 'coupon' | 'badge' | 'item';
export type InventoryItemStatus = 'active' | 'expired' | 'redeemed' | 'deleted';

export const INVENTORY_MAX_SLOTS = 30;

export const userInventory = pgTable("user_inventory", {
  id: serial("id").primaryKey(),
  userId: varchar("user_id").references(() => users.id).notNull(),
  slotIndex: integer("slot_index").notNull(), // 0-29 for 30 slots
  itemType: varchar("item_type", { length: 20 }).default('coupon').notNull(),
  merchantCouponId: integer("merchant_coupon_id").references(() => merchantCoupons.id), // Link to coupon template
  itemName: text("item_name").notNull(),
  itemDescription: text("item_description"),
  imageUrl: text("image_url"),
  tier: varchar("tier", { length: 10 }), // For coupons: SP, SSR, SR, S, R
  merchantId: integer("merchant_id").references(() => merchants.id),
  merchantName: text("merchant_name"),
  terms: text("terms"),
  content: text("content"),
  validUntil: timestamp("valid_until"),
  status: varchar("status", { length: 20 }).default('active').notNull(), // active, expired, redeemed, deleted
  isRedeemed: boolean("is_redeemed").default(false).notNull(),
  redeemedAt: timestamp("redeemed_at"),
  isExpired: boolean("is_expired").default(false).notNull(),
  isRead: boolean("is_read").default(false).notNull(), // For notification dot
  isDeleted: boolean("is_deleted").default(false).notNull(),
  deletedAt: timestamp("deleted_at"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
}, (table) => [
  index("IDX_user_inventory_user").on(table.userId),
  index("IDX_user_inventory_type").on(table.itemType),
  index("IDX_user_inventory_read").on(table.isRead),
  index("IDX_user_inventory_slot").on(table.userId, table.slotIndex),
  index("IDX_user_inventory_status").on(table.status),
]);

export const userInventoryRelations = relations(userInventory, ({ one }) => ({
  user: one(users, {
    fields: [userInventory.userId],
    references: [users.id],
  }),
  merchantCoupon: one(merchantCoupons, {
    fields: [userInventory.merchantCouponId],
    references: [merchantCoupons.id],
  }),
  merchant: one(merchants, {
    fields: [userInventory.merchantId],
    references: [merchants.id],
  }),
}));

export const insertUserInventorySchema = createInsertSchema(userInventory).omit({
  id: true,
  slotIndex: true, // Auto-assigned by storage
  isRedeemed: true,
  redeemedAt: true,
  isExpired: true,
  isRead: true,
  createdAt: true,
});

export type UserInventoryItem = typeof userInventory.$inferSelect;
export type InsertUserInventoryItem = z.infer<typeof insertUserInventorySchema>;

// ============ Coupon Rarity Config (優惠券機率設定) ============

export const couponRarityConfigs = pgTable("coupon_rarity_configs", {
  id: serial("id").primaryKey(),
  configKey: varchar("config_key", { length: 50 }).default('global').notNull().unique(), // 'global' or merchant-specific key
  spRate: integer("sp_rate").default(2).notNull(), // 2%
  ssrRate: integer("ssr_rate").default(8).notNull(), // 8%
  srRate: integer("sr_rate").default(15).notNull(), // 15%
  sRate: integer("s_rate").default(23).notNull(), // 23%
  rRate: integer("r_rate").default(32).notNull(), // 32% (remaining 20% = no coupon)
  isActive: boolean("is_active").default(true).notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const insertCouponRarityConfigSchema = createInsertSchema(couponRarityConfigs).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export type CouponRarityConfig = typeof couponRarityConfigs.$inferSelect;
export type InsertCouponRarityConfig = z.infer<typeof insertCouponRarityConfigSchema>;

// ============ SOS Alerts (安全中心求救) ============

export type SosAlertStatus = 'pending' | 'acknowledged' | 'resolved' | 'cancelled';

export const sosAlerts = pgTable("sos_alerts", {
  id: serial("id").primaryKey(),
  userId: varchar("user_id").references(() => users.id).notNull(),
  serviceOrderId: integer("service_order_id"), // 關聯的旅程訂單 ID (from trip-planner)
  plannerId: integer("planner_id"), // 負責的旅程策畫師 ID
  location: text("location"), // GPS 座標 (e.g., "25.0330,121.5654")
  locationAddress: text("location_address"), // 可讀地址
  message: text("message"), // 用戶附加訊息
  status: varchar("status", { length: 20 }).default('pending').notNull(), // 'pending' | 'acknowledged' | 'resolved' | 'cancelled'
  acknowledgedBy: varchar("acknowledged_by"), // 處理人員 ID
  acknowledgedAt: timestamp("acknowledged_at"),
  resolvedAt: timestamp("resolved_at"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
}, (table) => [
  index("IDX_sos_alerts_user").on(table.userId),
  index("IDX_sos_alerts_planner").on(table.plannerId),
  index("IDX_sos_alerts_status").on(table.status),
]);

export const sosAlertsRelations = relations(sosAlerts, ({ one }) => ({
  user: one(users, {
    fields: [sosAlerts.userId],
    references: [users.id],
  }),
}));

export const insertSosAlertSchema = createInsertSchema(sosAlerts).omit({
  id: true,
  status: true,
  acknowledgedBy: true,
  acknowledgedAt: true,
  resolvedAt: true,
  createdAt: true,
});

export type SosAlert = typeof sosAlerts.$inferSelect;
export type InsertSosAlert = z.infer<typeof insertSosAlertSchema>;

// ============ Extended User Profile ============

export const userProfiles = pgTable("user_profiles", {
  id: serial("id").primaryKey(),
  userId: varchar("user_id").references(() => users.id).notNull().unique(),
  gender: varchar("gender", { length: 20 }),
  birthDate: timestamp("birth_date"),
  phone: varchar("phone", { length: 50 }),
  dietaryRestrictions: text("dietary_restrictions").array(), // 飲食禁忌 (array of tags)
  medicalHistory: text("medical_history").array(), // 疾病史 (array of tags)
  emergencyContactName: text("emergency_contact_name"),
  emergencyContactPhone: text("emergency_contact_phone"),
  emergencyContactRelation: text("emergency_contact_relation"),
  preferredLanguage: varchar("preferred_language", { length: 10 }).default('zh'),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
}, (table) => [
  index("IDX_user_profiles_user").on(table.userId),
]);

export const userProfilesRelations = relations(userProfiles, ({ one }) => ({
  user: one(users, {
    fields: [userProfiles.userId],
    references: [users.id],
  }),
}));

export const insertUserProfileSchema = createInsertSchema(userProfiles).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export type UserProfile = typeof userProfiles.$inferSelect;
export type InsertUserProfile = z.infer<typeof insertUserProfileSchema>;

// ============ Extended Merchant Profile ============

export type MerchantTier = 'free' | 'pro' | 'premium';
export type TripCardTier = 'free' | 'pro' | 'premium';

export const merchantProfiles = pgTable("merchant_profiles", {
  id: serial("id").primaryKey(),
  merchantId: integer("merchant_id").references(() => merchants.id).notNull().unique(),
  ownerName: text("owner_name").notNull(), // 管理者姓名
  businessName: text("business_name").notNull(), // 商家名稱
  taxId: text("tax_id"), // 統編（選填）
  businessCategory: text("business_category").notNull(), // 營業類別
  address: text("address").notNull(), // 地址
  phone: text("phone"), // 電話
  mobile: text("mobile"), // 手機
  email: text("email").notNull(),
  merchantTier: varchar("merchant_tier", { length: 20 }).default('free').notNull(), // free, pro, premium
  tripCardTier: varchar("trip_card_tier", { length: 20 }).default('free').notNull(), // free, pro, premium
  maxTripCards: integer("max_trip_cards").default(1).notNull(), // Based on merchant tier
  maxCouponSchemes: integer("max_coupon_schemes").default(1).notNull(), // Based on trip card tier
  isApproved: boolean("is_approved").default(false).notNull(), // 審核狀態
  approvedBy: varchar("approved_by").references(() => users.id),
  approvedAt: timestamp("approved_at"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
}, (table) => [
  index("IDX_merchant_profiles_merchant").on(table.merchantId),
  index("IDX_merchant_profiles_approved").on(table.isApproved),
]);

export const merchantProfilesRelations = relations(merchantProfiles, ({ one }) => ({
  merchant: one(merchants, {
    fields: [merchantProfiles.merchantId],
    references: [merchants.id],
  }),
  approver: one(users, {
    fields: [merchantProfiles.approvedBy],
    references: [users.id],
  }),
}));

export const insertMerchantProfileSchema = createInsertSchema(merchantProfiles).omit({
  id: true,
  isApproved: true,
  approvedBy: true,
  approvedAt: true,
  createdAt: true,
  updatedAt: true,
});

export type MerchantProfile = typeof merchantProfiles.$inferSelect;
export type InsertMerchantProfile = z.infer<typeof insertMerchantProfileSchema>;

// ============ Collection Enhancements ============

// Add read status to collections for notification
export const collectionReadStatus = pgTable("collection_read_status", {
  id: serial("id").primaryKey(),
  collectionId: integer("collection_id").references(() => collections.id).notNull(),
  userId: varchar("user_id").references(() => users.id).notNull(),
  isRead: boolean("is_read").default(false).notNull(),
  hasPromo: boolean("has_promo").default(false).notNull(), // 商家有優惠資訊
  lastPromoUpdate: timestamp("last_promo_update"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
}, (table) => [
  index("IDX_collection_read_user").on(table.userId),
  index("IDX_collection_read_status").on(table.isRead),
]);

// ============ Coupon Probability Settings (Global) ============

export const couponProbabilitySettings = pgTable("coupon_probability_settings", {
  id: serial("id").primaryKey(),
  tier: varchar("tier", { length: 10 }).notNull().unique(), // SP, SSR, SR, S, R
  probability: doublePrecision("probability").notNull(), // 0.02, 0.08, 0.15, 0.23, 0.32
  updatedBy: varchar("updated_by").references(() => users.id),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const insertCouponProbabilitySettingSchema = createInsertSchema(couponProbabilitySettings).omit({
  id: true,
  updatedAt: true,
});

export type CouponProbabilitySetting = typeof couponProbabilitySettings.$inferSelect;

// ============ Merchant Analytics Tracking (已移至上方) ============
// merchantAnalytics table defined earlier in the file

// ============ Trip Service Purchases ============

export const tripServicePurchases = pgTable("trip_service_purchases", {
  id: serial("id").primaryKey(),
  userId: varchar("user_id").references(() => users.id).notNull(),
  purchasedForUserId: varchar("purchased_for_user_id").references(() => users.id), // 為他人購買
  countryId: integer("country_id").references(() => countries.id).notNull(),
  regionId: integer("region_id").references(() => regions.id).notNull(),
  arrivalDate: timestamp("arrival_date").notNull(),
  departureDate: timestamp("departure_date").notNull(),
  dailyPrice: integer("daily_price").default(399).notNull(), // TWD
  totalPrice: integer("total_price").notNull(),
  paymentStatus: varchar("payment_status", { length: 20 }).default('pending').notNull(),
  specialistId: integer("specialist_id").references(() => specialists.id),
  chatRoomId: text("chat_room_id"), // Twilio channel SID
  isLocationSharingEnabled: boolean("is_location_sharing_enabled").default(false).notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
}, (table) => [
  index("IDX_trip_service_user").on(table.userId),
  index("IDX_trip_service_specialist").on(table.specialistId),
  index("IDX_trip_service_dates").on(table.arrivalDate, table.departureDate),
]);

export const tripServicePurchasesRelations = relations(tripServicePurchases, ({ one }) => ({
  user: one(users, {
    fields: [tripServicePurchases.userId],
    references: [users.id],
  }),
  purchasedForUser: one(users, {
    fields: [tripServicePurchases.purchasedForUserId],
    references: [users.id],
  }),
  specialist: one(specialists, {
    fields: [tripServicePurchases.specialistId],
    references: [specialists.id],
  }),
  country: one(countries, {
    fields: [tripServicePurchases.countryId],
    references: [countries.id],
  }),
  region: one(regions, {
    fields: [tripServicePurchases.regionId],
    references: [regions.id],
  }),
}));

export const insertTripServicePurchaseSchema = createInsertSchema(tripServicePurchases).omit({
  id: true,
  paymentStatus: true,
  specialistId: true,
  chatRoomId: true,
  isLocationSharingEnabled: true,
  createdAt: true,
  updatedAt: true,
});

export type TripServicePurchase = typeof tripServicePurchases.$inferSelect;
export type InsertTripServicePurchase = z.infer<typeof insertTripServicePurchaseSchema>;

// ============ Ad Placements (廣告設定) ============

export type AdPlatform = 'ios' | 'android' | 'web' | 'all';
export type AdPlacement = 'gacha_start' | 'gacha_result' | 'collection_view' | 'item_use' | 'splash' | 'banner';

export const adPlacements = pgTable("ad_placements", {
  id: serial("id").primaryKey(),
  placementKey: varchar("placement_key", { length: 50 }).notNull().unique(), // e.g., 'gacha_start', 'gacha_result'
  platform: varchar("platform", { length: 20 }).default('all').notNull(), // ios, android, web, all
  adUnitIdIos: text("ad_unit_id_ios"), // AdMob unit ID for iOS
  adUnitIdAndroid: text("ad_unit_id_android"), // AdMob unit ID for Android
  adType: varchar("ad_type", { length: 20 }).default('interstitial').notNull(), // interstitial, rewarded, banner
  fallbackImageUrl: text("fallback_image_url"), // Fallback if no ad
  fallbackLinkUrl: text("fallback_link_url"),
  isActive: boolean("is_active").default(true).notNull(),
  showFrequency: integer("show_frequency").default(1).notNull(), // Show every N times
  metadata: jsonb("metadata"), // Additional config
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
}, (table) => [
  index("IDX_ad_placements_key").on(table.placementKey),
  index("IDX_ad_placements_platform").on(table.platform),
]);

export const insertAdPlacementSchema = createInsertSchema(adPlacements).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export type AdPlacementRecord = typeof adPlacements.$inferSelect;
export type InsertAdPlacement = z.infer<typeof insertAdPlacementSchema>;

// ============ User Notification Badges (未讀通知) ============

export const userNotifications = pgTable("user_notifications", {
  id: serial("id").primaryKey(),
  userId: varchar("user_id").references(() => users.id).notNull(),
  notificationType: varchar("notification_type", { length: 30 }).notNull(), // 'collection', 'itembox', 'announcement'
  unreadCount: integer("unread_count").default(0).notNull(),
  lastSeenAt: timestamp("last_seen_at"),
  lastUpdatedAt: timestamp("last_updated_at").defaultNow().notNull(),
}, (table) => [
  index("IDX_user_notifications_user").on(table.userId),
  index("IDX_user_notifications_type").on(table.notificationType),
]);

export const userNotificationsRelations = relations(userNotifications, ({ one }) => ({
  user: one(users, {
    fields: [userNotifications.userId],
    references: [users.id],
  }),
}));

export type UserNotification = typeof userNotifications.$inferSelect;

// ============ Coupon Redemption Queue (核銷待處理) ============

export const couponRedemptions = pgTable("coupon_redemptions", {
  id: serial("id").primaryKey(),
  userId: varchar("user_id").references(() => users.id).notNull(),
  userInventoryId: integer("user_inventory_id").references(() => userInventory.id).notNull(),
  merchantId: integer("merchant_id").references(() => merchants.id).notNull(),
  redemptionCode: varchar("redemption_code", { length: 20 }).notNull(), // 用戶輸入的核銷碼
  status: varchar("status", { length: 20 }).default('pending').notNull(), // pending, verified, expired
  verifiedAt: timestamp("verified_at"),
  expiresAt: timestamp("expires_at").notNull(), // 3 minutes after verification
  createdAt: timestamp("created_at").defaultNow().notNull(),
}, (table) => [
  index("IDX_coupon_redemptions_user").on(table.userId),
  index("IDX_coupon_redemptions_status").on(table.status),
  index("IDX_coupon_redemptions_expires").on(table.expiresAt),
]);

export const couponRedemptionsRelations = relations(couponRedemptions, ({ one }) => ({
  user: one(users, {
    fields: [couponRedemptions.userId],
    references: [users.id],
  }),
  userInventoryItem: one(userInventory, {
    fields: [couponRedemptions.userInventoryId],
    references: [userInventory.id],
  }),
  merchant: one(merchants, {
    fields: [couponRedemptions.merchantId],
    references: [merchants.id],
  }),
}));

export const insertCouponRedemptionSchema = createInsertSchema(couponRedemptions).omit({
  id: true,
  status: true,
  verifiedAt: true,
  createdAt: true,
});

export type CouponRedemption = typeof couponRedemptions.$inferSelect;
export type InsertCouponRedemption = z.infer<typeof insertCouponRedemptionSchema>;

// ============ User Daily Gacha Stats (每日抽卡統計) ============

export const userDailyGachaStats = pgTable("user_daily_gacha_stats", {
  id: serial("id").primaryKey(),
  userId: varchar("user_id").references(() => users.id).notNull(),
  date: date("date").notNull(), // YYYY-MM-DD format
  pullCount: integer("pull_count").default(0).notNull(), // 當日已抽卡片數
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
}, (table) => [
  index("IDX_user_daily_gacha_user").on(table.userId),
  index("IDX_user_daily_gacha_date").on(table.date),
]);

export const userDailyGachaStatsRelations = relations(userDailyGachaStats, ({ one }) => ({
  user: one(users, {
    fields: [userDailyGachaStats.userId],
    references: [users.id],
  }),
}));

export type UserDailyGachaStat = typeof userDailyGachaStats.$inferSelect;


=== File: server/db.ts ===

import { drizzle } from "drizzle-orm/node-postgres";
import pg from "pg";
import * as schema from "@shared/schema";

const { Pool } = pg;

if (!process.env.DATABASE_URL) {
  throw new Error(
    "DATABASE_URL must be set. Did you forget to provision a database?",
  );
}

export const pool = new Pool({ connectionString: process.env.DATABASE_URL });
export const db = drizzle(pool, { schema });


=== File: server/index.ts ===

import express, { type Request, Response, NextFunction } from "express";
import cors from "cors";
import cookieParser from "cookie-parser";
import { createServer } from "http";
import { runMigrations } from 'stripe-replit-sync';
import { registerRoutes } from "./routes";
import { serveStatic } from "./static";
import { getStripeSync } from "./stripeClient";
import { WebhookHandlers } from "./webhookHandlers";
import { storage } from "./storage";
import { verifyJwtToken, initializeSuperAdmin } from "./replitAuth";
import { checkGeofence } from "./lib/geofencing";
import { generatePlaceWithAI, verifyPlaceWithGoogle, reviewPlaceWithAI } from "./lib/placeGenerator";
import { setupSocketIO } from "./socketHandler";
import { runDataCleanup } from "./lib/dataCleanup";
import { z } from "zod";

declare module "http" {
  interface IncomingMessage {
    rawBody: unknown;
  }
}

export function log(message: string, source = "express") {
  const formattedTime = new Date().toLocaleTimeString("en-US", {
    hour: "numeric",
    minute: "2-digit",
    second: "2-digit",
    hour12: true,
  });
  console.log(`${formattedTime} [${source}] ${message}`);
}

async function initStripe() {
  let databaseUrl = process.env.DATABASE_URL;
  if (!databaseUrl) {
    console.log('DATABASE_URL not set, skipping Stripe initialization');
    return;
  }

  // Add SSL mode to database URL if not present
  if (!databaseUrl.includes('sslmode=')) {
    databaseUrl += databaseUrl.includes('?') ? '&sslmode=require' : '?sslmode=require';
  }

  try {
    console.log('Initializing Stripe schema...');
    await runMigrations({ databaseUrl });
    console.log('Stripe schema ready');

    const stripeSync = await getStripeSync();

    console.log('Setting up managed webhook...');
    const webhookBaseUrl = `https://${process.env.REPLIT_DOMAINS?.split(',')[0]}`;
    const { webhook, uuid } = await stripeSync.findOrCreateManagedWebhook(
      `${webhookBaseUrl}/api/stripe/webhook`,
      { enabled_events: ['*'], description: 'Managed webhook for Stripe sync' }
    );
    console.log(`Webhook configured: ${webhook.url} (UUID: ${uuid})`);

    console.log('Syncing Stripe data...');
    stripeSync.syncBackfill()
      .then(() => console.log('Stripe data synced'))
      .catch((err: any) => console.error('Error syncing Stripe data:', err));
  } catch (error) {
    console.error('Failed to initialize Stripe:', error);
  }
}

async function startServer() {
  const app = express();

  // ============================================================
  // 0. 最最優先：全域請求日誌 (Debug 用)
  // ============================================================
  app.use((req, res, next) => {
    if (req.path.includes('callback') || req.path.includes('login')) {
      console.log(`[GLOBAL_DEBUG] ${req.method} ${req.path} | Query: ${JSON.stringify(req.query)}`);
    }
    next();
  });

  // ============================================================
  // 1. 最優先：Body Parser (必須在所有路由之前!)
  // ============================================================
  app.use(express.json({
    verify: (req, _res, buf) => {
      req.rawBody = buf;
    },
  }));
  app.use(express.urlencoded({ extended: true }));

  // ============================================================
  // 2. 第二順位：CORS 和 Cookie
  // ============================================================
  const isDevelopment = process.env.NODE_ENV === 'development';
  
  app.use(cors({
    origin: (origin, callback) => {
      if (!origin) return callback(null, true);
      if (isDevelopment) return callback(null, true);
      if (origin.endsWith('.replit.dev') || origin.endsWith('.replit.app')) {
        return callback(null, true);
      }
      callback(new Error('Not allowed by CORS'));
    },
    credentials: true,
    methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],
    allowedHeaders: ['Content-Type', 'Authorization', 'Cookie'],
    exposedHeaders: ['Set-Cookie'],
  }));

  app.use(cookieParser());

  // ============================================================
  // 3. 第三順位：API 路由 (絕對要在 Vite 之前!)
  // ============================================================

  // JWT 驗證 middleware
  const jwtAuth = (req: any, res: Response, next: NextFunction) => {
    console.log('[jwtAuth] Request to:', req.path);
    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      console.log('[jwtAuth] FAIL: Missing or invalid Authorization header');
      return res.status(401).json({ message: "Missing or invalid Authorization header" });
    }
    const token = authHeader.substring(7);
    console.log('[jwtAuth] Token received (first 10 chars):', token.substring(0, 10));
    const decoded = verifyJwtToken(token);
    if (!decoded) {
      console.log('[jwtAuth] FAIL: Token verification failed');
      return res.status(401).json({ message: "Invalid token" });
    }
    console.log('[jwtAuth] SUCCESS: User authenticated, sub:', decoded.sub);
    req.user = { claims: { sub: decoded.sub, email: decoded.email } };
    next();
  };

  // POST /api/sos/trigger - 直接在 index.ts 中處理，確保優先載入
  app.post('/api/sos/trigger', (req, res) => {
    console.log('🚨 SOS TRIGGERED!');
    console.log('🚨 Request body:', req.body);
    console.log('🚨 Query params:', req.query);
    res.json({ success: true, message: 'SOS triggered successfully' });
  });

  // POST /api/location/update
  app.post('/api/location/update', jwtAuth, async (req: any, res) => {
    const userId = req.user?.claims?.sub;
    console.log('📍 Location Update Request:', { userId, body: req.body });
    
    const locationSchema = z.object({
      lat: z.number().min(-90).max(90),
      lon: z.number().min(-180).max(180),
      isSharingEnabled: z.boolean().optional(),
      targets: z.array(z.object({
        id: z.union([z.string(), z.number()]),
        name: z.string(),
        lat: z.number().min(-90).max(90),
        lon: z.number().min(-180).max(180),
        radiusMeters: z.number().min(1).max(10000).default(50),
      })).optional(),
    });

    try {
      const validated = locationSchema.parse(req.body);
      console.log('📍 Location Update Validated:', { userId, lat: validated.lat, lon: validated.lon });
      
      let sharingEnabled = validated.isSharingEnabled;
      if (sharingEnabled === undefined) {
        const existingLocation = await storage.getUserLocation(userId);
        sharingEnabled = existingLocation?.isSharingEnabled ?? true;
      }
      
      const location = await storage.upsertUserLocation(
        userId,
        validated.lat,
        validated.lon,
        sharingEnabled
      );
      
      const geofenceResult = checkGeofence(
        { lat: validated.lat, lon: validated.lon },
        validated.targets || []
      );
      
      res.json({ 
        status: "ok",
        arrived: geofenceResult.arrived,
        target: geofenceResult.target,
        distanceMeters: geofenceResult.distanceMeters,
        location,
        message: sharingEnabled ? '位置已更新' : '位置共享已關閉'
      });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ status: "error", error: error.errors });
      }
      console.error("Error updating location:", error);
      res.status(500).json({ status: "error", error: "Failed to update location" });
    }
  });

  // GET /api/user/sos-link
  app.get('/api/user/sos-link', jwtAuth, async (req: any, res) => {
    const userId = req.user?.claims?.sub;
    console.log('🔗 SOS Link Request:', { userId });
    
    try {
      const user = await storage.getUser(userId);
      
      if (!user) {
        return res.status(404).json({ error: "User not found" });
      }

      let sosKey = user.sosSecretKey;
      
      if (!sosKey) {
        sosKey = await storage.generateSosKey(userId);
      }

      const baseUrl = process.env.REPLIT_DEV_DOMAIN 
        ? `https://${process.env.REPLIT_DEV_DOMAIN}`
        : process.env.REPLIT_DOMAINS?.split(',')[0] 
          ? `https://${process.env.REPLIT_DOMAINS.split(',')[0]}`
          : 'https://your-app.replit.app';

      const webhookUrl = `${baseUrl}/api/sos/trigger?key=${sosKey}`;
      
      res.json({ 
        webhookUrl,
        sosKey,
        instructions: {
          method: "POST",
          body: "Optional JSON: { \"lat\": number, \"lon\": number }",
          example: `curl -X POST "${webhookUrl}" -H "Content-Type: application/json" -d '{"lat": 25.0330, "lon": 121.5654}'`
        }
      });
    } catch (error) {
      console.error("Error getting SOS link:", error);
      res.status(500).json({ error: "Failed to get SOS link" });
    }
  });

  // Stripe Webhook (需要 raw body，所以特殊處理)
  app.post(
    '/api/stripe/webhook/:uuid',
    express.raw({ type: 'application/json' }),
    async (req, res) => {
      const signature = req.headers['stripe-signature'];
      if (!signature) {
        return res.status(400).json({ error: 'Missing stripe-signature' });
      }

      try {
        const sig = Array.isArray(signature) ? signature[0] : signature;
        if (!Buffer.isBuffer(req.body)) {
          console.error('STRIPE WEBHOOK ERROR: req.body is not a Buffer');
          return res.status(500).json({ error: 'Webhook processing error' });
        }

        const { uuid } = req.params;
        await WebhookHandlers.processWebhook(req.body as Buffer, sig, uuid);
        res.status(200).json({ received: true });
      } catch (error: any) {
        console.error('Webhook error:', error.message);
        res.status(400).json({ error: 'Webhook processing error' });
      }
    }
  );

  // 請求日誌 middleware
  app.use((req, res, next) => {
    const start = Date.now();
    const path = req.path;
    let capturedJsonResponse: Record<string, any> | undefined = undefined;

    const originalResJson = res.json;
    res.json = function (bodyJson, ...args) {
      capturedJsonResponse = bodyJson;
      return originalResJson.apply(res, [bodyJson, ...args]);
    };

    res.on("finish", () => {
      const duration = Date.now() - start;
      if (path.startsWith("/api")) {
        let logLine = `${req.method} ${path} ${res.statusCode} in ${duration}ms`;
        if (capturedJsonResponse) {
          logLine += ` :: ${JSON.stringify(capturedJsonResponse)}`;
        }
        log(logLine);
      }
    });

    next();
  });

  // Initialize Stripe
  await initStripe();

  // Initialize super admin account
  await initializeSuperAdmin();
  
  // 註冊其他 API 路由 (從 routes.ts)
  const httpServer = await registerRoutes(app);

  // 初始化 Socket.IO 即時位置追蹤
  setupSocketIO(httpServer);

  // 錯誤處理
  app.use((err: any, req: Request, res: Response, _next: NextFunction) => {
    const status = err.status || err.statusCode || 500;
    const message = err.message || "Internal Server Error";
    console.error(`[Express Error] ${req.method} ${req.path}:`, err.stack || err);
    res.status(status).json({ message });
  });

  // API 404 fallback - 防止未知 API 路由回傳 HTML
  app.use('/api/*', (req, res) => {
    res.status(404).json({ error: 'API endpoint not found', path: req.originalUrl });
  });

  // ============================================================
  // 4. 最後：Vite 中介軟體 (負責前端網頁)
  // ============================================================
  if (process.env.NODE_ENV === "production") {
    serveStatic(app);
  } else {
    const { setupVite } = await import("./vite");
    await setupVite(httpServer, app);
  }

  // ============================================================
  // 5. 啟動伺服器
  // ============================================================
  const port = parseInt(process.env.PORT || "5000", 10);
  httpServer.listen(
    {
      port,
      host: "0.0.0.0",
    },
    () => {
      console.log("Server is running on port " + port);

      // ============================================================
      // 6. 每分鐘自動生成行程卡草稿
      // ============================================================
      let isAutoDraftRunning = false;
      
      setInterval(async () => {
        // Prevent overlapping runs
        if (isAutoDraftRunning) {
          console.log('[AutoDraft] Previous run still in progress, skipping...');
          return;
        }
        
        isAutoDraftRunning = true;
        try {
          console.log('[AutoDraft] Starting automatic draft generation...');
          
          // 1. 隨機選擇一個區域 (district) - 預設台灣 (countryId = 1)
          const district = await storage.getRandomDistrictByCountry(1);
          if (!district) {
            console.log('[AutoDraft] No district found, skipping...');
            return;
          }
          
          // 2. 取得區域的父級資料
          const districtWithParents = await storage.getDistrictWithParents(district.id);
          if (!districtWithParents) {
            console.log('[AutoDraft] Failed to get district parents, skipping...');
            return;
          }
          
          const { region, country } = districtWithParents;
          
          // 3. 隨機選擇一個分類和子分類
          const category = await storage.getRandomCategory();
          if (!category) {
            console.log('[AutoDraft] No category found, skipping...');
            return;
          }
          
          const subcategory = await storage.getRandomSubcategoryByCategory(category.id);
          if (!subcategory) {
            console.log('[AutoDraft] No subcategory found, skipping...');
            return;
          }
          
          console.log(`[AutoDraft] Generating for: ${region.nameZh}${district.nameZh} - ${category.nameZh}/${subcategory.nameZh}`);
          
          // 4. 呼叫 AI 生成地點
          const aiResult = await generatePlaceWithAI(
            district.nameZh,
            region.nameZh,
            country.nameZh,
            subcategory.nameZh,
            category.nameZh
          );
          
          if (!aiResult) {
            console.log('[AutoDraft] AI generation failed, skipping...');
            return;
          }
          
          console.log(`[AutoDraft] AI generated: ${aiResult.placeName}`);
          
          // 5. 用 Google Maps API 驗證
          const verification = await verifyPlaceWithGoogle(
            aiResult.placeName,
            district.nameZh,
            region.nameZh
          );
          
          if (!verification.verified) {
            console.log(`[AutoDraft] Google verification failed for: ${aiResult.placeName}, skipping...`);
            return;
          }
          
          console.log(`[AutoDraft] Verified: ${verification.verifiedName} (${verification.placeId})`);
          
          // 6. 存入 placeDrafts 表
          const draft = await storage.createPlaceDraft({
            source: 'ai',
            placeName: verification.verifiedName || aiResult.placeName,
            categoryId: category.id,
            subcategoryId: subcategory.id,
            districtId: district.id,
            regionId: region.id,
            countryId: country.id,
            description: aiResult.description,
            address: verification.verifiedAddress,
            googlePlaceId: verification.placeId,
            googleRating: verification.rating,
            googleReviewCount: verification.reviewCount,
            locationLat: verification.location?.lat?.toString(),
            locationLng: verification.location?.lng?.toString(),
            status: 'auto_generated', // 等待 AI 審查
          });
          
          console.log(`[AutoDraft] Draft created: ID=${draft.id}, Name=${draft.placeName}`);
        } catch (error) {
          console.error('[AutoDraft] Error:', error);
        } finally {
          isAutoDraftRunning = false;
        }
      }, 30000); // 30秒
      
      console.log('[AutoDraft] Automatic draft generation scheduled (every 30 seconds)');

      // ============================================================
      // 7. AI 自動審查 auto_generated 草稿 (每 2 分鐘)
      // ============================================================
      let isAIReviewRunning = false;
      
      setInterval(async () => {
        if (isAIReviewRunning) {
          console.log('[AIReview] Previous run still in progress, skipping...');
          return;
        }
        
        isAIReviewRunning = true;
        try {
          // 取得一筆 auto_generated 狀態的草稿
          const drafts = await storage.getFilteredPlaceDrafts({ status: 'auto_generated' });
          if (drafts.length === 0) {
            return; // 沒有待審查的草稿
          }
          
          // 每次處理一筆
          const draft = drafts[0];
          console.log(`[AIReview] Reviewing: ${draft.placeName} (ID: ${draft.id})`);
          
          // 取得分類資訊
          const categories = await storage.getCategories();
          const category = categories.find(c => c.id === draft.categoryId);
          const subcategories = await storage.getSubcategoriesByCategory(draft.categoryId);
          const subcategory = subcategories.find(s => s.id === draft.subcategoryId);
          const districtInfo = await storage.getDistrictWithParents(draft.districtId);
          
          if (!category || !subcategory || !districtInfo) {
            console.log(`[AIReview] Missing category/district info for draft ${draft.id}, moving to pending`);
            await storage.updatePlaceDraft(draft.id, { status: 'pending' });
            return;
          }
          
          // 呼叫 AI 審查
          const reviewResult = await reviewPlaceWithAI(
            draft.placeName,
            draft.description || '',
            category.nameZh,
            subcategory.nameZh,
            districtInfo.district.nameZh,
            districtInfo.region.nameZh
          );
          
          console.log(`[AIReview] Result: ${reviewResult.passed ? 'PASS' : 'FAIL'} - ${reviewResult.reason} (confidence: ${reviewResult.confidence})`);
          
          if (reviewResult.passed && reviewResult.confidence >= 0.7) {
            // 通過審查 → 直接發布到 place_cache
            await storage.savePlaceToCache({
              placeName: draft.placeName,
              description: draft.description || '',
              category: category.code,
              subCategory: subcategory.nameZh,
              district: districtInfo.district.nameZh,
              city: districtInfo.region.nameZh,
              country: districtInfo.country.nameZh,
              placeId: draft.googlePlaceId || undefined,
              locationLat: draft.locationLat || undefined,
              locationLng: draft.locationLng || undefined,
              verifiedAddress: draft.address || undefined,
            });
            
            // 刪除草稿
            await storage.deletePlaceDraft(draft.id);
            console.log(`[AIReview] Draft ${draft.id} published to cache and deleted`);
          } else {
            // 未通過審查 → 改為 pending 狀態，等待人工審核，並加上退件原因
            const rejectionPrefix = `[AI審核不通過] ${reviewResult.reason} (信心度: ${Math.round(reviewResult.confidence * 100)}%)`;
            const newDescription = draft.description 
              ? `${rejectionPrefix}\n\n原描述：${draft.description}`
              : rejectionPrefix;
            
            await storage.updatePlaceDraft(draft.id, { 
              status: 'pending',
              description: newDescription
            });
            console.log(`[AIReview] Draft ${draft.id} moved to pending for manual review: ${reviewResult.reason}`);
          }
        } catch (error) {
          console.error('[AIReview] Error:', error);
        } finally {
          isAIReviewRunning = false;
        }
      }, 30000); // 30秒
      
      console.log('[AIReview] AI review scheduler started (every 30 seconds)');

      // ============================================================
      // 8. 每小時自動清除過期活動 (快閃活動、節日限定活動)
      // ============================================================
      setInterval(async () => {
        try {
          const deletedCount = await storage.deleteExpiredEvents();
          if (deletedCount > 0) {
            console.log(`[AutoCleanup] Deleted ${deletedCount} expired events`);
          }
        } catch (error) {
          console.error('[AutoCleanup] Error cleaning up expired events:', error);
        }
      }, 3600000); // 3600000ms = 1小時
      
      console.log('[AutoCleanup] Expired events cleanup scheduled (every 1 hour)');
      
      // ============================================================
      // 9. 每 48 小時自動執行資料清洗（名稱正規化 + 智慧去重）
      // ============================================================
      let isDataCleanupRunning = false;
      
      setInterval(async () => {
        if (isDataCleanupRunning) {
          console.log('[DataCleanup] Previous run still in progress, skipping...');
          return;
        }
        
        isDataCleanupRunning = true;
        try {
          const result = await runDataCleanup();
          if (result.totalRenamed > 0 || result.totalDeleted > 0) {
            console.log(`[DataCleanup] Cleanup complete - Renamed: ${result.totalRenamed}, Deleted: ${result.totalDeleted}`);
          }
        } catch (error) {
          console.error('[DataCleanup] Error during data cleanup:', error);
        } finally {
          isDataCleanupRunning = false;
        }
      }, 172800000); // 172800000ms = 48 小時
      
      console.log('[DataCleanup] Data cleanup scheduled (every 48 hours)');
      
      // 啟動時也執行一次清洗
      runDataCleanup().then(result => {
        if (result.totalRenamed > 0 || result.totalDeleted > 0) {
          console.log(`[DataCleanup] Initial cleanup complete - Renamed: ${result.totalRenamed}, Deleted: ${result.totalDeleted}`);
        } else {
          console.log('[DataCleanup] Initial cleanup complete - No changes needed');
        }
      }).catch(err => {
        console.error('[DataCleanup] Initial cleanup error:', err);
      });
    },
  );
}

startServer().catch((err) => {
  console.error('Failed to start server:', err);
  process.exit(1);
});


=== File: server/klookService.ts ===

import { storage } from "./storage";

const GEMINI_BASE_URL = process.env.AI_INTEGRATIONS_GEMINI_BASE_URL;
const GEMINI_API_KEY = process.env.AI_INTEGRATIONS_GEMINI_API_KEY;

interface DetectedProduct {
  keyword: string;
  startIndex: number;
  endIndex: number;
  klookUrl: string;
}

interface DetectionResult {
  products: DetectedProduct[];
  rawResponse?: string;
}

async function callGeminiForDetection(prompt: string): Promise<string> {
  if (!GEMINI_BASE_URL || !GEMINI_API_KEY) {
    throw new Error("Gemini API not configured");
  }

  const response = await fetch(`${GEMINI_BASE_URL}/models/gemini-2.5-flash:generateContent`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'x-goog-api-key': GEMINI_API_KEY,
    },
    body: JSON.stringify({
      contents: [{ role: "user", parts: [{ text: prompt }] }],
      generationConfig: {
        temperature: 0.1,
        maxOutputTokens: 2048,
      }
    }),
  });

  if (!response.ok) {
    const errorText = await response.text();
    console.error("Gemini API error:", errorText);
    throw new Error(`Gemini API failed: ${response.status}`);
  }

  const data = await response.json();
  return data.candidates?.[0]?.content?.parts?.[0]?.text || '';
}

function generateKlookSearchUrl(keyword: string, region?: string): string {
  const encodedKeyword = encodeURIComponent(keyword);
  const baseUrl = 'https://www.klook.com/zh-TW/search/?query=';
  return `${baseUrl}${encodedKeyword}`;
}

export async function detectKlookProducts(
  messageText: string,
  conversationSid: string,
  messageSid: string
): Promise<DetectionResult> {
  if (!messageText || messageText.length < 5) {
    return { products: [] };
  }

  const prompt = `你是一個旅遊商品偵測助手。分析以下聊天訊息，找出可能在 Klook 上購買的旅遊商品或體驗。

Klook 銷售的商品類型包括：
- 景點門票（如：101觀景台、故宮、九份、太魯閣）
- 一日遊行程（如：日月潭一日遊、阿里山一日遊）
- 交通票券（如：高鐵、台鐵、包車）
- 活動體驗（如：潛水、SUP、溯溪、露營）
- 按摩/SPA
- 網卡/WiFi
- 美食體驗（如：吃到飽、米其林餐廳）
- 主題樂園（如：六福村、劍湖山）

聊天訊息：
"${messageText}"

請以 JSON 格式回傳偵測到的商品關鍵字。只回傳 JSON，不要其他文字。
如果沒有偵測到任何商品，回傳空陣列 []。

格式範例：
[
  {"keyword": "日月潭一日遊", "type": "tour"},
  {"keyword": "101觀景台", "type": "ticket"}
]`;

  try {
    const response = await callGeminiForDetection(prompt);
    
    let jsonStr = response.trim();
    const jsonMatch = jsonStr.match(/\[[\s\S]*\]/);
    if (jsonMatch) {
      jsonStr = jsonMatch[0];
    }
    
    const detected = JSON.parse(jsonStr) as Array<{ keyword: string; type: string }>;
    
    if (!Array.isArray(detected) || detected.length === 0) {
      return { products: [], rawResponse: response };
    }

    const products: DetectedProduct[] = [];
    
    for (const item of detected) {
      const keyword = item.keyword;
      const startIndex = messageText.indexOf(keyword);
      
      if (startIndex >= 0) {
        const endIndex = startIndex + keyword.length;
        const klookUrl = generateKlookSearchUrl(keyword);
        
        products.push({
          keyword,
          startIndex,
          endIndex,
          klookUrl
        });

        try {
          await storage.createMessageHighlight({
            conversationSid,
            messageSid,
            productName: keyword,
            productUrl: klookUrl,
            startIndex,
            endIndex
          });
        } catch (err) {
          console.error('Failed to save message highlight:', err);
        }
      }
    }

    return { products, rawResponse: response };
  } catch (error) {
    console.error('Klook detection error:', error);
    return { products: [] };
  }
}

export async function getMessageHighlights(
  conversationSid: string,
  messageSid: string
) {
  return storage.getMessageHighlights(conversationSid, messageSid);
}

export async function getConversationHighlights(conversationSid: string) {
  return storage.getConversationHighlights(conversationSid);
}


=== File: server/lib/dataCleanup.ts ===

import { db } from "../db";
import { places, placeCache, placeDrafts } from "@shared/schema";
import { eq } from "drizzle-orm";

const SUFFIXES = [
  '售票處', '停車場', '遊客中心', '服務中心', '公廁', '廁所',
  '入口', '收費站', '管理處', '忘憂亭', '觀景台', '休息站',
  '販賣部', '紀念品店', '售票口', '驗票口', '候車亭', '管理站'
];

interface TableCleanupResult {
  tableName: string;
  renamedCount: number;
  deletedCount: number;
  renamedPlaces: Array<{ id: number; oldName: string; newName: string }>;
  deletedPlaces: Array<{ id: number; name: string; reason: string }>;
}

interface CleanupResult {
  places: TableCleanupResult;
  placeCache: TableCleanupResult;
  placeDrafts: TableCleanupResult;
  totalRenamed: number;
  totalDeleted: number;
}

type PlaceRecord = {
  id: number;
  placeName: string;
  rating?: number | null;
  locationLat?: number | string | null;
  locationLng?: number | string | null;
  photoReference?: string | null;
  description?: string | null;
  googleRating?: number | null;
  isLocationVerified?: boolean | null;
};

type PlaceWithSuffix = {
  id: number;
  placeName: string;
  suffix: string;
  coreName: string;
  score: number;
};

function findPlacesWithSuffix<T extends PlaceRecord>(records: T[]): PlaceWithSuffix[] {
  const result: PlaceWithSuffix[] = [];
  
  for (const record of records) {
    for (const suffix of SUFFIXES) {
      if (record.placeName.endsWith(suffix)) {
        const coreName = record.placeName.slice(0, -suffix.length).trim();
        if (coreName.length > 0) {
          const rating = record.rating ?? record.googleRating ?? 0;
          const hasCoords = (record.locationLat !== null && record.locationLat !== undefined) || 
                           (record.isLocationVerified === true);
          const hasPhoto = record.photoReference !== null && record.photoReference !== undefined;
          const hasDesc = record.description !== null && record.description !== undefined;
          
          result.push({
            id: record.id,
            placeName: record.placeName,
            suffix,
            coreName,
            score: (rating || 0) * 10 + (hasCoords ? 3 : 0) + (hasPhoto ? 2 : 0) + (hasDesc ? 1 : 0)
          });
        }
        break;
      }
    }
  }
  
  return result;
}

async function cleanupTable<T extends PlaceRecord>(
  tableName: string,
  allRecords: T[],
  deleteById: (id: number) => Promise<void>,
  updateName: (id: number, newName: string) => Promise<void>
): Promise<TableCleanupResult> {
  const result: TableCleanupResult = {
    tableName,
    renamedCount: 0,
    deletedCount: 0,
    renamedPlaces: [],
    deletedPlaces: []
  };

  const placesWithSuffix = findPlacesWithSuffix(allRecords);
  
  if (placesWithSuffix.length === 0) {
    return result;
  }

  console.log(`[DataCleanup:${tableName}] Found ${placesWithSuffix.length} records with suffixes`);

  const coreNameGroups = new Map<string, PlaceWithSuffix[]>();
  for (const place of placesWithSuffix) {
    if (!coreNameGroups.has(place.coreName)) {
      coreNameGroups.set(place.coreName, []);
    }
    coreNameGroups.get(place.coreName)!.push(place);
  }

  const existingCoreNames = new Set<string>();
  for (const record of allRecords) {
    const isInSuffixList = placesWithSuffix.some(p => p.id === record.id);
    if (!isInSuffixList) {
      existingCoreNames.add(record.placeName);
    }
  }

  const coreNames = Array.from(coreNameGroups.keys());
  for (const coreName of coreNames) {
    const group = coreNameGroups.get(coreName)!;
    const existsAsCore = existingCoreNames.has(coreName);

    if (existsAsCore) {
      for (const place of group) {
        await deleteById(place.id);
        result.deletedCount++;
        result.deletedPlaces.push({
          id: place.id,
          name: place.placeName,
          reason: `Duplicate of existing "${coreName}"`
        });
        console.log(`[DataCleanup:${tableName}] Deleted "${place.placeName}" (duplicate of "${coreName}")`);
      }
    } else if (group.length > 1) {
      group.sort((a, b) => b.score - a.score);
      const best = group[0];
      const rest = group.slice(1);

      await updateName(best.id, coreName);
      result.renamedCount++;
      result.renamedPlaces.push({
        id: best.id,
        oldName: best.placeName,
        newName: coreName
      });
      console.log(`[DataCleanup:${tableName}] Renamed "${best.placeName}" → "${coreName}"`);

      for (const dup of rest) {
        await deleteById(dup.id);
        result.deletedCount++;
        result.deletedPlaces.push({
          id: dup.id,
          name: dup.placeName,
          reason: `Duplicate after normalization, kept id=${best.id}`
        });
        console.log(`[DataCleanup:${tableName}] Deleted "${dup.placeName}" (duplicate)`);
      }
    }
  }

  return result;
}

export async function runDataCleanup(): Promise<CleanupResult> {
  console.log('[DataCleanup] Starting data cleanup for all tables...');

  const allPlaces = await db.select().from(places);
  const placesResult = await cleanupTable(
    'places',
    allPlaces,
    async (id) => { await db.delete(places).where(eq(places.id, id)); },
    async (id, name) => { await db.update(places).set({ placeName: name }).where(eq(places.id, id)); }
  );

  const allCache = await db.select().from(placeCache);
  const cacheResult = await cleanupTable(
    'place_cache',
    allCache,
    async (id) => { await db.delete(placeCache).where(eq(placeCache.id, id)); },
    async (id, name) => { await db.update(placeCache).set({ placeName: name }).where(eq(placeCache.id, id)); }
  );

  const allDrafts = await db.select().from(placeDrafts);
  const draftsResult = await cleanupTable(
    'place_drafts',
    allDrafts,
    async (id) => { await db.delete(placeDrafts).where(eq(placeDrafts.id, id)); },
    async (id, name) => { await db.update(placeDrafts).set({ placeName: name }).where(eq(placeDrafts.id, id)); }
  );

  const result: CleanupResult = {
    places: placesResult,
    placeCache: cacheResult,
    placeDrafts: draftsResult,
    totalRenamed: placesResult.renamedCount + cacheResult.renamedCount + draftsResult.renamedCount,
    totalDeleted: placesResult.deletedCount + cacheResult.deletedCount + draftsResult.deletedCount
  };

  console.log(`[DataCleanup] Complete. Total renamed: ${result.totalRenamed}, Total deleted: ${result.totalDeleted}`);
  return result;
}


=== File: server/lib/geofencing.ts ===

export interface Coordinate {
  lat: number;
  lon: number;
}

export interface GeofenceTarget {
  id: string | number;
  name: string;
  lat: number;
  lon: number;
  radiusMeters: number;
}

export interface GeofenceResult {
  status: "ok" | "error";
  arrived: boolean;
  target: GeofenceTarget | null;
  distanceMeters: number | null;
}

export function haversineDistance(point1: Coordinate, point2: Coordinate): number {
  const R = 6371000;
  const lat1Rad = point1.lat * Math.PI / 180;
  const lat2Rad = point2.lat * Math.PI / 180;
  const deltaLat = (point2.lat - point1.lat) * Math.PI / 180;
  const deltaLon = (point2.lon - point1.lon) * Math.PI / 180;

  const a = 
    Math.sin(deltaLat / 2) * Math.sin(deltaLat / 2) +
    Math.cos(lat1Rad) * Math.cos(lat2Rad) *
    Math.sin(deltaLon / 2) * Math.sin(deltaLon / 2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

  return R * c;
}

export function checkGeofence(
  userLocation: Coordinate,
  targets: GeofenceTarget[]
): GeofenceResult {
  if (targets.length === 0) {
    return { status: "ok", arrived: false, target: null, distanceMeters: null };
  }

  let nearestTarget: GeofenceTarget | null = null;
  let minDistance = Infinity;

  for (const target of targets) {
    const distance = haversineDistance(userLocation, { lat: target.lat, lon: target.lon });
    if (distance < minDistance) {
      minDistance = distance;
      nearestTarget = target;
    }
  }

  if (nearestTarget && minDistance <= nearestTarget.radiusMeters) {
    return {
      status: "ok",
      arrived: true,
      target: nearestTarget,
      distanceMeters: Math.round(minDistance * 100) / 100,
    };
  }

  return {
    status: "ok",
    arrived: false,
    target: nearestTarget,
    distanceMeters: nearestTarget ? Math.round(minDistance * 100) / 100 : null,
  };
}

export function isWithinRadius(
  point1: Coordinate,
  point2: Coordinate,
  radiusMeters: number
): boolean {
  return haversineDistance(point1, point2) <= radiusMeters;
}


=== File: server/lib/placeGenerator.ts ===

const GOOGLE_MAPS_API_KEY = process.env.GOOGLE_MAPS_API_KEY;

const EXCLUDED_BUSINESS_STATUS = ['CLOSED_PERMANENTLY', 'CLOSED_TEMPORARILY'];
const EXCLUDED_PLACE_TYPES = [
  'travel_agency', 'insurance_agency', 'real_estate_agency', 'lawyer', 'accounting', 
  'bank', 'library', 'local_government_office', 'city_hall', 'courthouse', 'post_office',
  'police', 'fire_station', 'hospital', 'doctor', 'dentist', 'pharmacy', 'veterinary_care',
  'school', 'primary_school', 'secondary_school', 'university', 'car_dealer', 'car_rental',
  'car_repair', 'car_wash', 'gas_station', 'parking', 'transit_station', 'bus_station',
  'train_station', 'subway_station', 'taxi_stand', 'atm', 'funeral_home', 'cemetery',
  'church', 'mosque', 'synagogue', 'hindu_temple', 'place_of_worship'
];
const GENERIC_NAME_PATTERNS = [
  '探索', '旅行社', '旅行', 'Travel', 'Explore', 'Tour',
  '農會', '公所', '區公所', '鄉公所', '鎮公所', '市公所', '縣政府', '市政府', '衛生所', '戶政事務所',
  '警察局', '派出所', '消防隊', '消防局', '郵局', '稅務局', '地政事務所',
  '診所', '牙醫', '醫院', '藥局', '獸醫', '銀行', '加油站', '停車場', '汽車', '機車行',
  '葬儀', '殯儀館', '靈骨塔', '納骨塔',
  '服務中心', '遊客中心'
];

function isPlaceValid(place: any): boolean {
  if (place.business_status && EXCLUDED_BUSINESS_STATUS.includes(place.business_status)) {
    return false;
  }
  if (place.types && place.types.some((t: string) => EXCLUDED_PLACE_TYPES.includes(t))) {
    return false;
  }
  if (place.name && GENERIC_NAME_PATTERNS.some(pattern => place.name.includes(pattern))) {
    return false;
  }
  return true;
}

export async function callGemini(prompt: string): Promise<string> {
  const baseUrl = process.env.AI_INTEGRATIONS_GEMINI_BASE_URL;
  const apiKey = process.env.AI_INTEGRATIONS_GEMINI_API_KEY;
  
  if (!baseUrl || !apiKey) {
    throw new Error("Gemini API not configured");
  }

  const response = await fetch(`${baseUrl}/models/gemini-2.5-flash:generateContent`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'x-goog-api-key': apiKey,
    },
    body: JSON.stringify({
      contents: [{ role: "user", parts: [{ text: prompt }] }],
      generationConfig: {
        temperature: 0.9,
        maxOutputTokens: 8192,
      }
    }),
  });

  if (!response.ok) {
    const errorText = await response.text();
    console.error("Gemini API error:", errorText);
    throw new Error(`Gemini API failed: ${response.status}`);
  }

  const data = await response.json();
  return data.candidates?.[0]?.content?.parts?.[0]?.text || '';
}

export async function generatePlaceWithAI(
  districtNameZh: string, 
  regionNameZh: string, 
  countryNameZh: string,
  subcategoryNameZh: string,
  categoryNameZh: string,
  excludePlaceNames: string[] = []
): Promise<{ placeName: string; description: string } | null> {
  try {
    const exclusionNote = excludePlaceNames.length > 0 
      ? `\n注意：請不要推薦以下已經出現過的地點：${excludePlaceNames.join('、')}` 
      : '';
    
    const prompt = `你是台灣在地旅遊專家。請推薦一個位於「${regionNameZh}${districtNameZh}」的「${subcategoryNameZh}」類型店家或景點。

要求：
1. 必須是真實存在、適合觀光旅遊的店家或景點
2. 必須確實位於 ${regionNameZh}${districtNameZh} 這個行政區內
3. 提供一個有吸引力的介紹（約30-50字），說明為什麼遊客應該造訪
4. 不要推薦一般性的公共設施（如普通的公立圖書館、區公所、戶政事務所、學校等）
5. 優先推薦有特色、有口碑、適合遊客體驗的地點${exclusionNote}

請以 JSON 格式回答：
{
  "placeName": "店家或景點名稱",
  "description": "簡短介紹"
}

只回答 JSON，不要有其他文字。`;

    const responseText = await callGemini(prompt);
    
    const jsonMatch = responseText.match(/\{[\s\S]*\}/);
    if (!jsonMatch) {
      console.error("Failed to parse Gemini response:", responseText);
      return null;
    }
    
    const parsed = JSON.parse(jsonMatch[0]);
    return {
      placeName: parsed.placeName,
      description: parsed.description
    };
  } catch (error) {
    console.error("Gemini AI generation error:", error);
    return null;
  }
}

export async function verifyPlaceWithGoogle(
  placeName: string,
  districtNameZh: string,
  regionNameZh: string
): Promise<{
  verified: boolean;
  placeId?: string;
  verifiedName?: string;
  verifiedAddress?: string;
  rating?: number;
  reviewCount?: number;
  location?: { lat: number; lng: number };
  googleTypes?: string[];
  primaryType?: string;
}> {
  if (!GOOGLE_MAPS_API_KEY) {
    return { verified: false };
  }

  try {
    const searchText = encodeURIComponent(`${placeName} ${districtNameZh} ${regionNameZh}`);
    const url = `https://maps.googleapis.com/maps/api/place/textsearch/json?query=${searchText}&key=${GOOGLE_MAPS_API_KEY}&language=zh-TW`;
    
    const response = await fetch(url);
    const data = await response.json();
    
    if (data.status === 'OK' && data.results && data.results.length > 0) {
      const genericPlaceholderPatterns = ['探索', '旅行社', '服務中心', '遊客中心', '資訊站'];
      const validResults = data.results.slice(0, 10).filter((place: any) => {
        const address = place.formatted_address || '';
        const name = place.name || '';
        
        if (!isPlaceValid(place)) {
          return false;
        }
        
        const isInDistrict = address.includes(regionNameZh) && address.includes(districtNameZh);
        const isGenericPlaceholder = genericPlaceholderPatterns.some(pattern => name.includes(pattern));
        
        return isInDistrict && !isGenericPlaceholder;
      });
      
      if (validResults.length === 0) {
        return { verified: false };
      }
      
      const randomIndex = Math.floor(Math.random() * validResults.length);
      const place = validResults[randomIndex];
      const address = place.formatted_address || '';
      
      const googleTypes = place.types || [];
      const genericTypes = ['point_of_interest', 'establishment', 'premise', 'political', 'locality', 'sublocality'];
      const primaryType = googleTypes.find((t: string) => !genericTypes.includes(t)) || googleTypes[0];
      
      return {
        verified: true,
        placeId: place.place_id,
        verifiedName: place.name,
        verifiedAddress: address,
        rating: place.rating,
        reviewCount: place.user_ratings_total,
        location: place.geometry?.location,
        googleTypes,
        primaryType
      };
    }
    
    return { verified: false };
  } catch (error) {
    console.error("Google Places verification error:", error);
    return { verified: false };
  }
}

export interface AIReviewResult {
  passed: boolean;
  reason: string;
  confidence: number;
}

export async function reviewPlaceWithAI(
  placeName: string,
  description: string,
  categoryName: string,
  subcategoryName: string,
  districtName: string,
  regionName: string
): Promise<AIReviewResult> {
  try {
    const prompt = `你是旅遊內容品質審核專家。請評估以下地點資料是否適合推薦給遊客。

地點名稱：${placeName}
分類：${categoryName} / ${subcategoryName}
地區：${regionName}${districtName}
描述：${description}

【審核標準】
1. 描述與地點不符 → 不通過（例如：描述講的是另一個地方）
2. 包含否定詞 → 不通過（例如：「無此類型」「非專營」「尚無」「並無符合」「無法找到」）
3. 建議去別處 → 不通過（例如：「建議體驗當地其他」「建議前往」）
4. 通用/空泛描述 → 不通過（可套用在任何地點的描述）
5. 分類錯誤 → 不通過（例如：麵包店歸類為溫泉）
6. 非旅遊性質 → 不通過（政府機關、銀行、超商等日常服務）

【通過標準】
- 描述具體且與地點相關
- 分類正確
- 適合推薦給遊客

請以 JSON 格式回答：
{
  "passed": true或false,
  "reason": "簡短說明原因（10字以內）",
  "confidence": 0到1之間的數字
}

只回答 JSON，不要有其他文字。`;

    const responseText = await callGemini(prompt);
    
    const jsonMatch = responseText.match(/\{[\s\S]*\}/);
    if (!jsonMatch) {
      console.error("[AIReview] Failed to parse response:", responseText);
      return { passed: false, reason: "AI 回應解析失敗", confidence: 0 };
    }
    
    const parsed = JSON.parse(jsonMatch[0]);
    return {
      passed: !!parsed.passed,
      reason: parsed.reason || "未提供原因",
      confidence: typeof parsed.confidence === 'number' ? parsed.confidence : 0.5
    };
  } catch (error) {
    console.error("[AIReview] Error:", error);
    return { passed: false, reason: "AI 審查發生錯誤", confidence: 0 };
  }
}


=== File: server/replitAuth.ts ===

import * as client from "openid-client";
import { Strategy, type VerifyFunction } from "openid-client/passport";

import passport from "passport";
import session from "express-session";
import jwt from "jsonwebtoken";
import crypto from "crypto";
import type { Express, RequestHandler } from "express";
import memoize from "memoizee";
import connectPg from "connect-pg-simple";
import { storage } from "./storage";
import { registerUserSchema } from "@shared/schema";
import { z } from "zod";

const JWT_SECRET = process.env.JWT_SECRET || 'mibu_secret_key_fixed_12345';

// Password hashing using PBKDF2 (Node.js built-in)
const SALT_LENGTH = 16;
const HASH_ITERATIONS = 100000;
const HASH_KEY_LENGTH = 64;
const HASH_DIGEST = 'sha512';

export function hashPassword(password: string): string {
  const salt = crypto.randomBytes(SALT_LENGTH).toString('hex');
  const hash = crypto.pbkdf2Sync(password, salt, HASH_ITERATIONS, HASH_KEY_LENGTH, HASH_DIGEST).toString('hex');
  return `${salt}:${hash}`;
}

export function verifyPassword(password: string, storedHash: string): boolean {
  const [salt, hash] = storedHash.split(':');
  if (!salt || !hash) return false;
  const verifyHash = crypto.pbkdf2Sync(password, salt, HASH_ITERATIONS, HASH_KEY_LENGTH, HASH_DIGEST).toString('hex');
  return crypto.timingSafeEqual(Buffer.from(hash), Buffer.from(verifyHash));
}

// Super admin initialization
const SUPER_ADMIN_EMAIL = process.env.SUPER_ADMIN_EMAIL || 's8869420@gmail.com';
const SUPER_ADMIN_PASSWORD = process.env.SUPER_ADMIN_PASSWORD;

export async function initializeSuperAdmin(): Promise<void> {
  try {
    if (!SUPER_ADMIN_PASSWORD) {
      console.warn('[Admin] SUPER_ADMIN_PASSWORD environment variable not set. Skipping super admin initialization.');
      return;
    }

    const existingUser = await storage.getUserByEmail(SUPER_ADMIN_EMAIL);
    
    if (!existingUser) {
      console.log('[Admin] Creating super admin account...');
      await storage.createUser({
        email: SUPER_ADMIN_EMAIL,
        password: hashPassword(SUPER_ADMIN_PASSWORD),
        role: 'admin',
        isApproved: true,
        provider: 'email',
        firstName: 'Super',
        lastName: 'Admin',
      });
      console.log('[Admin] Super admin account created successfully');
    } else {
      // Ensure super admin has correct role and is approved
      if (existingUser.role !== 'admin' || !existingUser.isApproved) {
        console.log('[Admin] Updating super admin privileges...');
        await storage.updateUser(existingUser.id, { 
          role: 'admin', 
          isApproved: true 
        });
        console.log('[Admin] Super admin privileges updated');
      }
    }
  } catch (error) {
    console.error('[Admin] Failed to initialize super admin:', error);
  }
}
console.log('[JWT] Using fixed JWT_SECRET (first 10 chars):', JWT_SECRET.substring(0, 10));
const JWT_EXPIRES_IN = '7d';

const ALLOWED_REDIRECT_ORIGINS = [
  'https://cca44805-83a8-48a7-8754-2ce82f774385-00-1gu87zpyw11ng.pike.replit.dev',
  process.env.EXPO_APP_URL,
].filter(Boolean) as string[];

function isAllowedRedirectUri(uri: string): boolean {
  try {
    // Allow Expo and custom app deep links
    if (uri.startsWith('exp://') || uri.startsWith('myapp://') || uri.startsWith('mibu://')) {
      return true;
    }
    
    const url = new URL(uri);
    return ALLOWED_REDIRECT_ORIGINS.some(allowed => {
      const allowedUrl = new URL(allowed);
      return url.origin === allowedUrl.origin;
    });
  } catch {
    return false;
  }
}

export function generateJwtToken(user: any, activeRole?: string): string {
  if (!JWT_SECRET) {
    throw new Error('JWT_SECRET or SESSION_SECRET is required for token generation');
  }
  const payload = {
    sub: user.claims?.sub || user.id,
    email: user.claims?.email || user.email,
    firstName: user.claims?.first_name || user.firstName,
    lastName: user.claims?.last_name || user.lastName,
    profileImageUrl: user.claims?.profile_image_url || user.profileImageUrl,
    activeRole: activeRole || user.role || 'traveler',
  };
  return jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_EXPIRES_IN });
}

export function verifyJwtToken(token: string): any {
  console.log('[JWT DEBUG] verifyJwtToken called');
  console.log('[JWT DEBUG] Token (first 10 chars):', token ? token.substring(0, 10) : 'null/undefined');
  console.log('[JWT DEBUG] JWT_SECRET (first 10 chars):', JWT_SECRET.substring(0, 10));
  
  try {
    const decoded = jwt.verify(token, JWT_SECRET);
    console.log('[JWT DEBUG] Token verification SUCCESS, decoded sub:', (decoded as any)?.sub);
    return decoded;
  } catch (error: any) {
    console.log('[JWT DEBUG] Token verification FAILED, reason:', error?.message || 'unknown error');
    return null;
  }
}

const getOidcConfig = memoize(
  async () => {
    return await client.discovery(
      new URL(process.env.ISSUER_URL ?? "https://replit.com/oidc"),
      process.env.REPL_ID!
    );
  },
  { maxAge: 3600 * 1000 }
);

export function getSession() {
  const sessionTtl = 7 * 24 * 60 * 60 * 1000; // 1 week
  const pgStore = connectPg(session);
  const sessionStore = new pgStore({
    conString: process.env.DATABASE_URL,
    createTableIfMissing: false,
    ttl: sessionTtl,
    tableName: "sessions",
  });
  
  // Log any session store errors
  sessionStore.on('error', (error) => {
    console.error('[Session Store Error]', error);
  });
  
  return session({
    secret: process.env.SESSION_SECRET!,
    store: sessionStore,
    resave: false,
    saveUninitialized: false,
    cookie: {
      httpOnly: true,
      secure: true,
      sameSite: 'none' as const,
      maxAge: sessionTtl,
    },
  });
}

function updateUserSession(
  user: any,
  tokens: client.TokenEndpointResponse & client.TokenEndpointResponseHelpers
) {
  user.claims = tokens.claims();
  user.access_token = tokens.access_token;
  user.refresh_token = tokens.refresh_token;
  user.expires_at = user.claims?.exp;
}

async function upsertUser(claims: any) {
  await storage.upsertUser({
    id: claims["sub"],
    email: claims["email"],
    firstName: claims["first_name"],
    lastName: claims["last_name"],
    profileImageUrl: claims["profile_image_url"],
    provider: 'replit',
  });
}

export async function setupAuth(app: Express) {
  app.set("trust proxy", 1);
  app.use(getSession());
  app.use(passport.initialize());
  app.use(passport.session());

  const config = await getOidcConfig();

  const verify: VerifyFunction = async (
    tokens: client.TokenEndpointResponse & client.TokenEndpointResponseHelpers,
    verified: passport.AuthenticateCallback
  ) => {
    const user = {};
    updateUserSession(user, tokens);
    await upsertUser(tokens.claims());
    verified(null, user);
  };

  const registeredStrategies = new Set<string>();

  // Always use the development domain for OAuth callback (Replit only registers dev domain for OAuth)
  const getOAuthCallbackDomain = () => {
    const replitDomains = process.env.REPLIT_DOMAINS;
    if (replitDomains) {
      const devDomain = replitDomains.split(',')[0].trim();
      console.log(`[OAuth] Using REPLIT_DOMAINS for callback: ${devDomain}`);
      return devDomain;
    }
    // Fallback: shouldn't happen in Replit environment
    console.warn('[OAuth] REPLIT_DOMAINS not set, OAuth may fail');
    return null;
  };

  const oauthCallbackDomain = getOAuthCallbackDomain();

  const ensureStrategy = (requestDomain: string) => {
    // Use the OAuth callback domain (dev domain) for strategy, not the request domain
    const callbackDomain = oauthCallbackDomain || requestDomain;
    const strategyName = `replitauth:${callbackDomain}`;
    
    if (!registeredStrategies.has(strategyName)) {
      console.log(`[OAuth] Registering strategy: ${strategyName}, callbackURL: https://${callbackDomain}/api/callback`);
      const strategy = new Strategy(
        {
          name: strategyName,
          config,
          scope: "openid email profile offline_access",
          callbackURL: `https://${callbackDomain}/api/callback`,
        },
        verify,
      );
      passport.use(strategy);
      registeredStrategies.add(strategyName);
    }
    
    return strategyName;
  };

  passport.serializeUser((user: Express.User, cb) => cb(null, user));
  passport.deserializeUser((user: Express.User, cb) => cb(null, user));

  const loginHandler = (req: any, res: any, next: any) => {
    try {
      console.log(`[OAuth Login] Starting login for hostname: ${req.hostname}`);
      const redirectUri = req.query.redirect_uri as string | undefined;
      const portal = req.query.portal as string | undefined; // merchant, specialist, traveler, admin
      const targetRole = req.query.target_role as string | undefined;
      
      if (redirectUri) {
        if (!isAllowedRedirectUri(redirectUri)) {
          return res.status(400).json({ error: 'Invalid redirect_uri' });
        }
        (req.session as any).externalRedirectUri = redirectUri;
        
        // Also set a cookie as backup (session might be lost during OAuth flow)
        res.cookie('app_redirect_uri', redirectUri, {
          httpOnly: true,
          secure: true,
          sameSite: 'none' as const,
          maxAge: 10 * 60 * 1000, // 10 minutes
        });
      }
      
      // Store portal/target_role for setting activeRole after login
      const requestedRole = portal || targetRole;
      if (requestedRole && ['traveler', 'merchant', 'specialist', 'admin'].includes(requestedRole)) {
        (req.session as any).requestedActiveRole = requestedRole;
        res.cookie('requested_active_role', requestedRole, {
          httpOnly: true,
          secure: true,
          sameSite: 'none' as const,
          maxAge: 10 * 60 * 1000, // 10 minutes
        });
        console.log(`[OAuth] Login requested with portal/target_role: ${requestedRole}`);
      }
      
      console.log(`[OAuth Login] Calling ensureStrategy for request from: ${req.hostname}`);
      const strategyName = ensureStrategy(req.hostname);
      console.log(`[OAuth Login] Starting passport.authenticate with strategy: ${strategyName}`);
      passport.authenticate(strategyName, {
        prompt: "login consent",
        scope: ["openid", "email", "profile", "offline_access"],
      })(req, res, next);
    } catch (error) {
      console.error('[OAuth Login] Error in loginHandler:', error);
      res.status(500).json({ error: 'Login initialization failed', details: String(error) });
    }
  };

  app.get("/api/login", loginHandler);
  app.get("/api/auth/login", loginHandler);

  app.get("/api/callback", async (req, res, next) => {
    // Global error handler wrapper for the entire callback
    const handleCallbackError = (error: any, context: string) => {
      console.error(`[OAuth Callback ERROR] ${context}:`, error);
      const redirectUri = req.cookies?.app_redirect_uri || (req.session as any)?.externalRedirectUri;
      if (redirectUri) {
        res.clearCookie('app_redirect_uri');
        res.clearCookie('requested_active_role');
        const isCustom = redirectUri.startsWith('exp://') || redirectUri.startsWith('mibu://') || redirectUri.startsWith('myapp://');
        const targetUrl = `${redirectUri}?error=CALLBACK_ERROR&message=${encodeURIComponent(context)}`;
        if (isCustom) {
          return res.send(`<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="refresh" content="0;url=${targetUrl}"><title>錯誤</title></head><body><script>window.location.href="${targetUrl}";</script></body></html>`);
        }
        return res.redirect(targetUrl);
      }
      return res.status(500).json({ error: 'Callback processing failed', context });
    };

    try {
      console.log(`[OAuth Callback] ========== CALLBACK RECEIVED ==========`);
      console.log(`[OAuth Callback] hostname: ${req.hostname}, REPLIT_DOMAINS: ${process.env.REPLIT_DOMAINS}`);
      console.log(`[OAuth Callback] query: ${JSON.stringify(req.query)}`);
      console.log(`[OAuth Callback] session id: ${req.sessionID}, session exists: ${!!req.session}`);
      console.log(`[OAuth Callback] cookies: app_redirect_uri=${req.cookies?.app_redirect_uri}, requested_active_role=${req.cookies?.requested_active_role}`);
    } catch (e) {
      console.error('[OAuth Callback] Initial logging error:', e);
    }
    
    // Helper to get redirect URI from session or cookie
    const getExternalRedirectUri = () => {
      return (req.session as any)?.externalRedirectUri || req.cookies?.app_redirect_uri;
    };
    
    // Helper to clear redirect URI from both session and cookie
    const clearExternalRedirectUri = () => {
      delete (req.session as any).externalRedirectUri;
      res.clearCookie('app_redirect_uri');
    };
    
    // Helper to check if redirect is to a custom app scheme (exp://, mibu://, etc.)
    const isCustomScheme = (uri: string) => {
      return uri.startsWith('exp://') || uri.startsWith('mibu://') || uri.startsWith('myapp://');
    };
    
    // Helper to redirect using HTML bounce page (for iOS Safari compatibility)
    const redirectWithBouncePage = (targetUrl: string, message: string) => {
      const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>登入成功</title>
  <style>
    body { 
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      display: flex; 
      justify-content: center; 
      align-items: center; 
      height: 100vh; 
      margin: 0;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      text-align: center;
    }
    .container { padding: 20px; }
    h1 { font-size: 24px; margin-bottom: 10px; }
    p { font-size: 16px; opacity: 0.9; }
    .spinner { 
      width: 40px; 
      height: 40px; 
      border: 3px solid rgba(255,255,255,0.3); 
      border-top-color: white; 
      border-radius: 50%; 
      animation: spin 1s linear infinite; 
      margin: 20px auto;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
  </style>
</head>
<body>
  <div class="container">
    <h1>${message}</h1>
    <div class="spinner"></div>
    <p>正在跳轉回 APP...</p>
  </div>
  <script>
    window.location.href = "${targetUrl}";
  </script>
</body>
</html>`;
      res.setHeader('Content-Type', 'text/html; charset=utf-8');
      return res.send(html);
    };
    
    if (req.query.error) {
      console.log("OAuth denied:", req.query.error, req.query.error_description);
      const externalRedirectUri = getExternalRedirectUri();
      if (externalRedirectUri) {
        clearExternalRedirectUri();
        const targetUrl = `${externalRedirectUri}?error=access_denied`;
        if (isCustomScheme(externalRedirectUri)) {
          return redirectWithBouncePage(targetUrl, '登入已取消');
        }
        return res.redirect(targetUrl);
      }
      return res.redirect("/");
    }
    
    let strategyName: string;
    try {
      console.log(`[OAuth Callback] Processing callback for hostname: ${req.hostname}`);
      strategyName = ensureStrategy(req.hostname);
      console.log(`[OAuth Callback] Using strategy: ${strategyName}`);
    } catch (strategyError) {
      console.error('[OAuth Callback] ensureStrategy failed:', strategyError);
      const extUri = getExternalRedirectUri();
      if (extUri) {
        clearExternalRedirectUri();
        const targetUrl = `${extUri}?error=CONFIG_ERROR&message=${encodeURIComponent('OAuth設定錯誤')}`;
        if (isCustomScheme(extUri)) {
          return redirectWithBouncePage(targetUrl, 'OAuth設定錯誤');
        }
        return res.redirect(targetUrl);
      }
      return res.status(500).json({ message: 'OAuth configuration error' });
    }
    
    try {
      passport.authenticate(strategyName, (err: any, user: any) => {
        console.log(`[OAuth Callback] passport.authenticate result - err: ${err}, user: ${user?.claims?.sub || 'null'}`);
      if (err) {
        console.error('[OAuth Callback] Passport authentication error:', err);
      }
      if (err || !user) {
        const externalRedirectUri = getExternalRedirectUri();
        if (externalRedirectUri) {
          clearExternalRedirectUri();
          const targetUrl = `${externalRedirectUri}?error=auth_failed`;
          if (isCustomScheme(externalRedirectUri)) {
            return redirectWithBouncePage(targetUrl, '登入失敗');
          }
          return res.redirect(targetUrl);
        }
        return res.redirect("/");
      }
      
      req.logIn(user, async (loginErr) => {
        if (loginErr) {
          console.error("Login error:", loginErr);
          return res.redirect("/");
        }
        
        // Get requested activeRole from session or cookie
        const requestedPortal = (req.session as any)?.requestedActiveRole || req.cookies?.requested_active_role;
        const externalRedirectUri = getExternalRedirectUri();
        
        // Helper to redirect with error
        const redirectWithError = (errorCode: string, errorMessage: string) => {
          // Clear cookies
          delete (req.session as any).requestedActiveRole;
          res.clearCookie('requested_active_role');
          clearExternalRedirectUri();
          
          if (externalRedirectUri) {
            const separator = externalRedirectUri.includes('?') ? '&' : '?';
            const targetUrl = `${externalRedirectUri}${separator}error=${errorCode}&message=${encodeURIComponent(errorMessage)}`;
            if (isCustomScheme(externalRedirectUri)) {
              return redirectWithBouncePage(targetUrl, errorMessage);
            }
            return res.redirect(targetUrl);
          }
          return res.redirect(`/?error=${errorCode}&message=${encodeURIComponent(errorMessage)}`);
        };
        
        try {
          // ===== Login Permission Matrix =====
          const SUPER_ADMIN_EMAIL = 's8869420@gmail.com';
          const userId = user.claims?.sub;
          console.log(`[OAuth Callback] Getting user from DB: ${userId}`);
          const dbUser = userId ? await storage.getUser(userId) : null;
          console.log(`[OAuth Callback] DB user found: ${dbUser ? 'yes' : 'no'}, role: ${dbUser?.role || 'null'}, email: ${dbUser?.email || 'null'}`);
        const userRole = dbUser?.role || 'traveler';
        const isSuperAdmin = dbUser?.email === SUPER_ADMIN_EMAIL;
        
        // If portal is specified, validate permissions
        if (requestedPortal && ['traveler', 'merchant', 'specialist', 'admin'].includes(requestedPortal)) {
          console.log(`[OAuth] User ${userId} (role: ${userRole}, superAdmin: ${isSuperAdmin}) requested portal: ${requestedPortal}`);
          
          // Super Admin can access ANY portal (God Mode)
          if (isSuperAdmin) {
            (req.session as any).activeRole = requestedPortal;
            console.log(`[GOD MODE] Super admin accessing portal: ${requestedPortal}`);
            
            // Auto-seed merchant/specialist data for super admin
            if (dbUser) {
              try {
                if (requestedPortal === 'merchant') {
                  let merchant = await storage.getMerchantByUserId(dbUser.id);
                  if (!merchant && dbUser.email) {
                    const crypto = await import('crypto');
                    merchant = await storage.createMerchant({
                      userId: dbUser.id,
                      name: `${dbUser.firstName || 'Admin'}'s Test Store`,
                      email: dbUser.email,
                      subscriptionPlan: 'premium',
                      dailySeedCode: crypto.randomBytes(4).toString('hex').toUpperCase(),
                      creditBalance: 10000,
                    });
                    console.log(`[GOD MODE] Auto-created merchant: ${merchant.id}`);
                  } else if (!merchant) {
                    console.log(`[GOD MODE] Cannot auto-create merchant: user has no email`);
                  }
                } else if (requestedPortal === 'specialist') {
                  let specialist = await storage.getSpecialistByUserId(dbUser.id);
                  if (!specialist) {
                    specialist = await storage.createSpecialist({
                      userId: dbUser.id,
                      name: `${dbUser.firstName || 'Admin'} Specialist`,
                      serviceRegion: 'taipei',
                      isAvailable: true,
                      maxTravelers: 10,
                    });
                    console.log(`[GOD MODE] Auto-created specialist: ${specialist.id}`);
                  }
                }
              } catch (seedError) {
                console.error(`[GOD MODE] Failed to auto-seed ${requestedPortal} data:`, seedError);
                // Continue anyway - super admin can still access the portal
              }
            }
          }
          // Regular users - strict permission checking
          else {
            // TRAVELER trying to access different portals
            if (userRole === 'traveler') {
              if (requestedPortal === 'traveler') {
                (req.session as any).activeRole = 'traveler';
              } else if (requestedPortal === 'merchant') {
                return redirectWithError('NO_MERCHANT_DATA', '您尚未註冊為商家，請先申請商家帳號');
              } else if (requestedPortal === 'specialist') {
                return redirectWithError('NO_SPECIALIST_DATA', '您尚未註冊為專員，請先申請專員帳號');
              } else if (requestedPortal === 'admin') {
                return redirectWithError('PERMISSION_DENIED', '權限不符，無法進入管理後台');
              }
            }
            // MERCHANT trying to access different portals
            else if (userRole === 'merchant') {
              if (requestedPortal === 'merchant') {
                (req.session as any).activeRole = 'merchant';
              } else if (requestedPortal === 'traveler') {
                return redirectWithError('WRONG_PORTAL', '請切換至商家入口登入');
              } else if (requestedPortal === 'specialist') {
                return redirectWithError('PERMISSION_DENIED', '權限不符，無法進入專員後台');
              } else if (requestedPortal === 'admin') {
                return redirectWithError('PERMISSION_DENIED', '權限不符，無法進入管理後台');
              }
            }
            // SPECIALIST trying to access different portals
            else if (userRole === 'specialist') {
              if (requestedPortal === 'specialist') {
                (req.session as any).activeRole = 'specialist';
              } else if (requestedPortal === 'traveler') {
                return redirectWithError('WRONG_PORTAL', '請切換至專員入口登入');
              } else if (requestedPortal === 'merchant') {
                return redirectWithError('PERMISSION_DENIED', '權限不符，無法進入商家後台');
              } else if (requestedPortal === 'admin') {
                return redirectWithError('PERMISSION_DENIED', '權限不符，無法進入管理後台');
              }
            }
            // ADMIN trying to access different portals
            else if (userRole === 'admin') {
              if (requestedPortal === 'admin') {
                (req.session as any).activeRole = 'admin';
              } else {
                return redirectWithError('WRONG_PORTAL', '請使用管理入口登入');
              }
            }
          }
          
          // Clear the requested role from session and cookie
          delete (req.session as any).requestedActiveRole;
          res.clearCookie('requested_active_role');
        }
        
        // Get the final activeRole for this session
        const finalActiveRole = (req.session as any).activeRole || userRole;
        
        // Redirect with token (include activeRole in JWT)
        if (externalRedirectUri) {
          clearExternalRedirectUri();
          const token = generateJwtToken(user, finalActiveRole);
          const separator = externalRedirectUri.includes('?') ? '&' : '?';
          const targetUrl = `${externalRedirectUri}${separator}token=${token}&activeRole=${finalActiveRole}`;
          
          console.log(`[OAuth] Redirecting with activeRole: ${finalActiveRole}`);
          
          if (isCustomScheme(externalRedirectUri)) {
            return redirectWithBouncePage(targetUrl, '登入成功！');
          }
          return res.redirect(targetUrl);
        }
        
        return res.redirect("/");
        } catch (permissionError: any) {
          console.error('[OAuth Callback] Permission check error:', permissionError);
          // If there's an error during permission checking, redirect with error
          const externalUri = getExternalRedirectUri();
          if (externalUri) {
            clearExternalRedirectUri();
            const targetUrl = `${externalUri}?error=INTERNAL_ERROR&message=${encodeURIComponent('登入處理失敗，請稍後再試')}`;
            if (isCustomScheme(externalUri)) {
              return redirectWithBouncePage(targetUrl, '登入失敗');
            }
            return res.redirect(targetUrl);
          }
          return res.redirect("/?error=INTERNAL_ERROR");
        }
      });
    })(req, res, next);
    } catch (passportError: any) {
      console.error('[OAuth Callback] Passport authenticate error:', passportError);
      const extUri = getExternalRedirectUri();
      if (extUri) {
        clearExternalRedirectUri();
        const targetUrl = `${extUri}?error=AUTH_ERROR&message=${encodeURIComponent('認證處理失敗')}`;
        if (isCustomScheme(extUri)) {
          return redirectWithBouncePage(targetUrl, '認證失敗');
        }
        return res.redirect(targetUrl);
      }
      return res.status(500).json({ message: 'Authentication processing error' });
    }
  });

  app.get("/api/logout", (req, res) => {
    req.logout(() => {
      res.redirect(
        client.buildEndSessionUrl(config, {
          client_id: process.env.REPL_ID!,
          post_logout_redirect_uri: `${req.protocol}://${req.hostname}`,
        }).href
      );
    });
  });

  app.get("/api/auth/verify", (req, res) => {
    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.status(401).json({ valid: false, error: 'No token provided' });
    }
    
    const token = authHeader.substring(7);
    const decoded = verifyJwtToken(token);
    
    if (!decoded) {
      return res.status(401).json({ valid: false, error: 'Invalid or expired token' });
    }
    
    return res.json({
      valid: true,
      user: {
        id: decoded.sub,
        email: decoded.email,
        firstName: decoded.firstName,
        lastName: decoded.lastName,
        profileImageUrl: decoded.profileImageUrl,
      }
    });
  });

  app.post("/api/auth/refresh-token", async (req, res) => {
    const { token } = req.body;
    if (!token) {
      return res.status(400).json({ error: 'Token required' });
    }
    
    const decoded = verifyJwtToken(token);
    if (!decoded) {
      return res.status(401).json({ error: 'Invalid or expired token' });
    }
    
    const user = await storage.getUser(decoded.sub);
    if (!user) {
      return res.status(401).json({ error: 'User not found' });
    }
    
    const newToken = generateJwtToken({
      claims: {
        sub: user.id,
        email: user.email,
        first_name: user.firstName,
        last_name: user.lastName,
        profile_image_url: user.profileImageUrl,
      }
    });
    
    return res.json({ token: newToken });
  });

  // ============ Email/Password Auth Routes ============

  // POST /api/register - 註冊新帳號
  app.post("/api/register", async (req, res) => {
    try {
      const { email, password, firstName, lastName, role } = req.body;

      // 驗證輸入
      const validated = registerUserSchema.parse({ email, password, firstName, lastName, role });

      // 檢查 email 是否已存在
      const existingUser = await storage.getUserByEmail(validated.email);
      if (existingUser) {
        return res.status(409).json({ error: "此電子郵件已被註冊" });
      }

      // 決定是否需要審核
      const needsApproval = ['merchant', 'specialist', 'admin'].includes(validated.role || 'traveler');
      const isApproved = !needsApproval; // traveler 直接通過，其他需審核

      // 建立使用者
      const user = await storage.createUser({
        email: validated.email,
        password: hashPassword(validated.password),
        firstName: validated.firstName || null,
        lastName: validated.lastName || null,
        role: validated.role || 'traveler',
        provider: 'email',
        isApproved,
      });

      if (needsApproval) {
        return res.status(201).json({
          success: true,
          message: "註冊成功！您的帳號需要管理員審核後才能登入。",
          needsApproval: true,
          user: {
            id: user.id,
            email: user.email,
            role: user.role,
          }
        });
      }

      // 如果不需要審核，直接發放 token
      const token = generateJwtToken({
        id: user.id,
        email: user.email,
        firstName: user.firstName,
        lastName: user.lastName,
      });

      return res.status(201).json({
        success: true,
        message: "註冊成功！",
        needsApproval: false,
        token,
        user: {
          id: user.id,
          email: user.email,
          firstName: user.firstName,
          lastName: user.lastName,
          role: user.role,
        }
      });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ error: error.errors[0]?.message || "輸入格式錯誤" });
      }
      console.error("Register error:", error);
      return res.status(500).json({ error: "註冊失敗，請稍後再試" });
    }
  });

  // POST /api/login - 登入（email/password）
  app.post("/api/login", async (req, res) => {
    try {
      const { email, password } = req.body;

      if (!email || !password) {
        return res.status(400).json({ error: "請輸入電子郵件和密碼" });
      }

      // 查找使用者
      const user = await storage.getUserByEmail(email);
      if (!user) {
        return res.status(401).json({ error: "電子郵件或密碼錯誤" });
      }

      // 檢查是否是 email 註冊的使用者
      if (!user.password) {
        return res.status(401).json({ error: "此帳號使用其他方式登入（如 Replit）" });
      }

      // 檢查審核狀態
      if (!user.isApproved) {
        return res.status(403).json({ 
          error: "帳號待審核中，請聯繫管理員",
          code: "PENDING_APPROVAL"
        });
      }

      // 驗證密碼
      if (!verifyPassword(password, user.password)) {
        return res.status(401).json({ error: "電子郵件或密碼錯誤" });
      }

      // 發放 token
      const token = generateJwtToken({
        id: user.id,
        email: user.email,
        firstName: user.firstName,
        lastName: user.lastName,
      });

      return res.json({
        success: true,
        token,
        user: {
          id: user.id,
          email: user.email,
          firstName: user.firstName,
          lastName: user.lastName,
          role: user.role,
          profileImageUrl: user.profileImageUrl,
        }
      });
    } catch (error) {
      console.error("Login error:", error);
      return res.status(500).json({ error: "登入失敗，請稍後再試" });
    }
  });
}

export const isAuthenticated: RequestHandler = async (req, res, next) => {
  const authHeader = req.headers.authorization;
  if (authHeader && authHeader.startsWith('Bearer ')) {
    const token = authHeader.substring(7);
    const decoded = verifyJwtToken(token);
    if (decoded) {
      (req as any).jwtUser = decoded;
      (req as any).user = {
        claims: {
          sub: decoded.sub,
          email: decoded.email,
          first_name: decoded.firstName,
          last_name: decoded.lastName,
          profile_image_url: decoded.profileImageUrl,
        }
      };
      return next();
    }
    return res.status(401).json({ message: "Invalid token" });
  }

  const user = req.user as any;

  if (!req.isAuthenticated() || !user.expires_at) {
    return res.status(401).json({ message: "Unauthorized" });
  }

  const now = Math.floor(Date.now() / 1000);
  if (now <= user.expires_at) {
    return next();
  }

  const refreshToken = user.refresh_token;
  if (!refreshToken) {
    res.status(401).json({ message: "Unauthorized" });
    return;
  }

  try {
    const config = await getOidcConfig();
    const tokenResponse = await client.refreshTokenGrant(config, refreshToken);
    updateUserSession(user, tokenResponse);
    return next();
  } catch (error) {
    res.status(401).json({ message: "Unauthorized" });
    return;
  }
};

// Role-based access control middleware
export const requireRole = (...allowedRoles: string[]): RequestHandler => {
  return async (req, res, next) => {
    const user = req.user as any;
    
    if (!req.isAuthenticated() || !user?.claims?.sub) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    
    try {
      const dbUser = await storage.getUser(user.claims.sub);
      if (!dbUser) {
        return res.status(401).json({ message: "User not found" });
      }
      
      const userRole = dbUser.role || 'traveler';
      
      // Super admin can access any interface
      const isSuperAdmin = dbUser.email === SUPER_ADMIN_EMAIL;
      
      if (!isSuperAdmin && !allowedRoles.includes(userRole)) {
        return res.status(403).json({ message: "Forbidden: insufficient permissions" });
      }
      
      // Attach role to request for downstream use
      (req as any).userRole = userRole;
      (req as any).dbUser = dbUser;
      (req as any).isSuperAdmin = isSuperAdmin;
      
      return next();
    } catch (error) {
      console.error("Role check error:", error);
      return res.status(500).json({ message: "Internal server error" });
    }
  };
};

// Middleware for merchant-only routes
export const isMerchant = requireRole('merchant', 'admin');

// Middleware for admin-only routes
export const isAdmin = requireRole('admin');


=== File: server/routes.ts ===

import type { Express } from "express";
import { createServer, type Server } from "http";
import { storage } from "./storage";
import { setupAuth, isAuthenticated, generateJwtToken } from "./replitAuth";
import { insertCollectionSchema, insertMerchantSchema, insertCouponSchema, insertCartItemSchema, insertPlaceDraftSchema, insertPlaceApplicationSchema, registerUserSchema, insertSpecialistSchema, insertServiceRelationSchema, insertAdPlacementSchema, insertCouponRarityConfigSchema, INVENTORY_MAX_SLOTS, type PlaceDraft, type Subcategory } from "@shared/schema";
import { ErrorCode, createErrorResponse } from "@shared/errors";
import * as crypto from "crypto";
import jwt from "jsonwebtoken";
import { z } from "zod";
import { createTripPlannerRoutes } from "../modules/trip-planner/server/routes";
import { createPlannerServiceRoutes } from "../modules/trip-planner/server/planner-routes";
import { registerStripeRoutes } from "./stripeRoutes";
import { getUncachableStripeClient } from "./stripeClient";
import { checkGeofence } from "./lib/geofencing";
import { callGemini, generatePlaceWithAI, verifyPlaceWithGoogle, reviewPlaceWithAI } from "./lib/placeGenerator";
import twilio from "twilio";
import appleSignin from "apple-signin-auth";
const { AccessToken } = twilio.jwt;
const ChatGrant = AccessToken.ChatGrant;
const VoiceGrant = AccessToken.VoiceGrant;

const RECUR_API_URL = "https://api.recur.tw/v1";
const RECUR_PREMIUM_PLAN_ID = "adkwbl9dya0wc6b53parl9yk";
const UNLIMITED_GENERATION_EMAILS = ["s8869420@gmail.com"];
const GOOGLE_MAPS_API_KEY = process.env.GOOGLE_MAPS_API_KEY;

interface PlaceSearchResult {
  name: string;
  formatted_address: string;
  place_id: string;
  geometry?: {
    location: { lat: number; lng: number };
  };
  rating?: number;
  types?: string[];
  business_status?: string;
}

const EXCLUDED_BUSINESS_STATUS = ['CLOSED_PERMANENTLY', 'CLOSED_TEMPORARILY'];
// Exclude non-tourism Google Place types
const EXCLUDED_PLACE_TYPES = [
  'travel_agency', 'insurance_agency', 'real_estate_agency', 'lawyer', 'accounting', 
  'bank', 'library', 'local_government_office', 'city_hall', 'courthouse', 'post_office',
  'police', 'fire_station', 'hospital', 'doctor', 'dentist', 'pharmacy', 'veterinary_care',
  'school', 'primary_school', 'secondary_school', 'university', 'car_dealer', 'car_rental',
  'car_repair', 'car_wash', 'gas_station', 'parking', 'transit_station', 'bus_station',
  'train_station', 'subway_station', 'taxi_stand', 'atm', 'funeral_home', 'cemetery',
  'church', 'mosque', 'synagogue', 'hindu_temple', 'place_of_worship'
];
// Exclude non-tourism places by name patterns (Chinese and English)
const GENERIC_NAME_PATTERNS = [
  // Travel/tour related
  '探索', '旅行社', '旅行', 'Travel', 'Explore', 'Tour',
  // Government/public services
  '農會', '公所', '區公所', '鄉公所', '鎮公所', '市公所', '縣政府', '市政府', '衛生所', '戶政事務所',
  '警察局', '派出所', '消防隊', '消防局', '郵局', '稅務局', '地政事務所',
  // Non-tourism services
  '診所', '牙醫', '醫院', '藥局', '獸醫', '銀行', '加油站', '停車場', '汽車', '機車行',
  '葬儀', '殯儀館', '靈骨塔', '納骨塔',
  // Generic/placeholder names
  '服務中心', '遊客中心'
];

function isPlaceValid(place: any): boolean {
  if (place.business_status && EXCLUDED_BUSINESS_STATUS.includes(place.business_status)) {
    return false;
  }
  
  if (place.types && place.types.some((t: string) => EXCLUDED_PLACE_TYPES.includes(t))) {
    return false;
  }
  
  if (place.name && GENERIC_NAME_PATTERNS.some(pattern => place.name.includes(pattern))) {
    return false;
  }
  
  return true;
}

async function searchPlaceInDistrict(
  query: string,
  district: string,
  city: string,
  country: string
): Promise<PlaceSearchResult | null> {
  if (!GOOGLE_MAPS_API_KEY) {
    console.warn("Google Maps API key not configured");
    return null;
  }

  try {
    const searchQuery = encodeURIComponent(`${query} ${district} ${city}`);
    const url = `https://maps.googleapis.com/maps/api/place/textsearch/json?query=${searchQuery}&key=${GOOGLE_MAPS_API_KEY}&language=zh-TW`;
    
    const response = await fetch(url);
    const data = await response.json();
    
    if (data.status === 'OK' && data.results && data.results.length > 0) {
      for (const place of data.results) {
        if (!isPlaceValid(place)) {
          continue;
        }
        
        return {
          name: place.name,
          formatted_address: place.formatted_address,
          place_id: place.place_id,
          geometry: place.geometry,
          rating: place.rating,
          types: place.types,
          business_status: place.business_status
        };
      }
      return null;
    }
    return null;
  } catch (error) {
    console.error("Google Places API error:", error);
    return null;
  }
}

async function getDistrictBoundary(
  district: string,
  city: string,
  country: string
): Promise<{ lat: number; lng: number } | null> {
  if (!GOOGLE_MAPS_API_KEY) {
    return null;
  }

  try {
    const address = encodeURIComponent(`${district}, ${city}, ${country}`);
    const url = `https://maps.googleapis.com/maps/api/geocode/json?address=${address}&key=${GOOGLE_MAPS_API_KEY}&language=zh-TW`;
    
    const response = await fetch(url);
    const data = await response.json();
    
    if (data.status === 'OK' && data.results && data.results.length > 0) {
      const location = data.results[0].geometry.location;
      return { lat: location.lat, lng: location.lng };
    }
    return null;
  } catch (error) {
    console.error("Google Geocoding API error:", error);
    return null;
  }
}

function isWithinRadius(
  point1: { lat: number; lng: number },
  point2: { lat: number; lng: number },
  radiusKm: number
): boolean {
  const R = 6371;
  const dLat = (point2.lat - point1.lat) * Math.PI / 180;
  const dLon = (point2.lng - point1.lng) * Math.PI / 180;
  const a = 
    Math.sin(dLat/2) * Math.sin(dLat/2) +
    Math.cos(point1.lat * Math.PI / 180) * Math.cos(point2.lat * Math.PI / 180) *
    Math.sin(dLon/2) * Math.sin(dLon/2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  const distance = R * c;
  return distance <= radiusKm;
}

export async function registerRoutes(app: Express): Promise<Server> {
  // Setup Replit Auth
  await setupAuth(app);

  // ============ Health Check ============
  app.get('/api/health', (req, res) => {
    res.json({ status: 'ok', message: 'Server is running correctly!', timestamp: new Date().toISOString() });
  });

  // ============ Public Config Routes ============
  // Mapbox access token (public tokens are designed to be exposed to clients)
  // Security is managed via URL restrictions in Mapbox dashboard
  app.get('/api/config/mapbox', (req, res) => {
    const token = process.env.VITE_MAPBOX_ACCESS_TOKEN || '';
    if (!token) {
      return res.status(503).json({ error: 'Mapbox token not configured' });
    }
    res.json({ accessToken: token });
  });

  // ============ Module Routes ============
  // Trip Planner Module
  app.use('/api/planner', createTripPlannerRoutes());
  
  // Planner Service Routes (策劃師服務)
  createPlannerServiceRoutes(app);

  // ============ Auth Routes ============
  
  // Password hashing utilities
  const hashPassword = (password: string): string => {
    const salt = crypto.randomBytes(16).toString('hex');
    const hash = crypto.pbkdf2Sync(password, salt, 100000, 64, 'sha512').toString('hex');
    return `${salt}:${hash}`;
  };
  
  const verifyPassword = (password: string, storedHash: string): boolean => {
    const [salt, hash] = storedHash.split(':');
    const verifyHash = crypto.pbkdf2Sync(password, salt, 100000, 64, 'sha512').toString('hex');
    return hash === verifyHash;
  };
  
  const generateToken = (userId: string, role: string): string => {
    const secret = process.env.SESSION_SECRET || 'mibu-secret-key';
    return jwt.sign({ sub: userId, role }, secret, { expiresIn: '30d' });
  };

  // Email/Password Registration (Traveler only)
  // For merchant/specialist registration, use /api/auth/register/merchant or /api/auth/register/specialist
  app.post('/api/auth/register', async (req, res) => {
    try {
      const travelerRegisterSchema = z.object({
        email: z.string().email('請輸入有效的電子郵件'),
        password: z.string().min(6, '密碼至少6個字'),
        firstName: z.string().optional(),
        lastName: z.string().optional(),
      });
      
      const validated = travelerRegisterSchema.parse(req.body);
      
      // Check if email already exists
      const existingUser = await storage.getUserByEmail(validated.email);
      if (existingUser) {
        return res.status(400).json(createErrorResponse(ErrorCode.EMAIL_ALREADY_EXISTS));
      }
      
      // Hash password
      const hashedPassword = hashPassword(validated.password);
      
      // Generate unique user ID
      const userId = `email_${crypto.randomBytes(16).toString('hex')}`;
      
      // Security: Always create as traveler, always auto-approved
      // Merchant/Specialist must use dedicated registration endpoints
      const user = await storage.createUser({
        id: userId,
        email: validated.email,
        password: hashedPassword,
        firstName: validated.firstName || null,
        lastName: validated.lastName || null,
        role: 'traveler', // Always traveler
        isApproved: true, // Travelers are always auto-approved
        provider: 'email',
      });
      
      // Generate JWT token
      const token = generateToken(user.id, 'traveler');
      
      res.status(201).json({ 
        user: { 
          id: user.id, 
          email: user.email, 
          firstName: user.firstName, 
          lastName: user.lastName,
          role: user.role,
          isApproved: user.isApproved,
        }, 
        token 
      });
    } catch (error: any) {
      console.error("Registration error:", error);
      if (error.name === 'ZodError') {
        return res.status(400).json({ error: '輸入資料格式錯誤', details: error.errors });
      }
      res.status(500).json(createErrorResponse(ErrorCode.SERVER_ERROR, '註冊失敗，請稍後再試'));
    }
  });

  // Merchant Registration (商家註冊)
  app.post('/api/auth/register/merchant', async (req, res) => {
    try {
      const merchantRegisterSchema = z.object({
        email: z.string().email('請輸入有效的電子郵件'),
        password: z.string().min(6, '密碼至少6個字'),
        businessName: z.string().min(1, '請輸入商家名稱'),
        contactName: z.string().min(1, '請輸入聯絡人名稱'),
        taxId: z.string().optional(), // 統一編號（選填）
        businessCategory: z.string().min(1, '請選擇產業類別'),
        address: z.string().min(1, '請輸入營業地址'),
        otherContact: z.string().optional(), // 其他聯絡方式
      });
      
      const validated = merchantRegisterSchema.parse(req.body);
      
      // Check if email already exists
      const existingUser = await storage.getUserByEmail(validated.email);
      if (existingUser) {
        return res.status(400).json(createErrorResponse(ErrorCode.EMAIL_ALREADY_EXISTS));
      }
      
      // Hash password
      const hashedPassword = hashPassword(validated.password);
      
      // Generate unique user ID
      const userId = `email_${crypto.randomBytes(16).toString('hex')}`;
      
      // Create user with merchant role (pending approval)
      const user = await storage.createUser({
        id: userId,
        email: validated.email,
        password: hashedPassword,
        firstName: validated.contactName,
        lastName: null,
        role: 'merchant',
        isApproved: false, // Requires admin approval
        provider: 'email',
      });
      
      // Create merchant record
      await storage.createMerchant({
        userId: user.id,
        email: validated.email,
        businessName: validated.businessName,
        ownerName: validated.contactName,
        taxId: validated.taxId || null,
        businessCategory: validated.businessCategory,
        address: validated.address,
        phone: validated.otherContact || null,
        name: validated.businessName, // For backward compatibility
        subscriptionPlan: 'free',
        creditBalance: 0,
      });
      
      console.log(`[Merchant Register] New merchant application: ${validated.email}, business: ${validated.businessName}`);
      
      res.status(201).json({
        success: true,
        message: '已收到您的申請，立馬為您處理',
        user: {
          id: user.id,
          email: user.email,
          role: user.role,
          isApproved: user.isApproved,
        },
      });
    } catch (error: any) {
      console.error("Merchant registration error:", error);
      if (error.name === 'ZodError') {
        return res.status(400).json({ error: '輸入資料格式錯誤', details: error.errors });
      }
      res.status(500).json(createErrorResponse(ErrorCode.SERVER_ERROR, '註冊失敗，請稍後再試'));
    }
  });

  // Specialist Registration (專員註冊)
  app.post('/api/auth/register/specialist', async (req, res) => {
    try {
      const specialistRegisterSchema = z.object({
        email: z.string().email('請輸入有效的電子郵件'),
        password: z.string().min(6, '密碼至少6個字'),
        name: z.string().min(1, '請輸入名稱'),
        otherContact: z.string().optional(), // 其他聯絡方式
        serviceRegion: z.string().optional(), // 服務地區（可後續設定）
      });
      
      const validated = specialistRegisterSchema.parse(req.body);
      
      // Check if email already exists
      const existingUser = await storage.getUserByEmail(validated.email);
      if (existingUser) {
        return res.status(400).json(createErrorResponse(ErrorCode.EMAIL_ALREADY_EXISTS));
      }
      
      // Hash password
      const hashedPassword = hashPassword(validated.password);
      
      // Generate unique user ID
      const userId = `email_${crypto.randomBytes(16).toString('hex')}`;
      
      // Create user with specialist role (pending approval)
      const user = await storage.createUser({
        id: userId,
        email: validated.email,
        password: hashedPassword,
        firstName: validated.name,
        lastName: null,
        role: 'specialist',
        isApproved: false, // Requires admin approval
        provider: 'email',
      });
      
      // Create specialist record
      await storage.createSpecialist({
        userId: user.id,
        name: validated.name,
        serviceRegion: validated.serviceRegion || 'taipei', // Default region
        isAvailable: false, // Not available until approved
        maxTravelers: 5,
        currentTravelers: 0,
      });
      
      console.log(`[Specialist Register] New specialist application: ${validated.email}, name: ${validated.name}`);
      
      res.status(201).json({
        success: true,
        message: '已收到您的申請，立馬為您處理',
        user: {
          id: user.id,
          email: user.email,
          role: user.role,
          isApproved: user.isApproved,
        },
      });
    } catch (error: any) {
      console.error("Specialist registration error:", error);
      if (error.name === 'ZodError') {
        return res.status(400).json({ error: '輸入資料格式錯誤', details: error.errors });
      }
      res.status(500).json(createErrorResponse(ErrorCode.SERVER_ERROR, '註冊失敗，請稍後再試'));
    }
  });

  // Super Admin Email (God Mode)
  const SUPER_ADMIN_EMAIL = 's8869420@gmail.com';
  const VALID_ROLES = ['traveler', 'merchant', 'specialist', 'admin'] as const;
  type TargetRole = typeof VALID_ROLES[number];

  // Email/Password Login with God Mode support
  app.post('/api/auth/login', async (req, res) => {
    try {
      const loginSchema = z.object({
        email: z.string().email('請輸入有效的電子郵件'),
        password: z.string().min(1, '請輸入密碼'),
        target_role: z.enum(VALID_ROLES).optional(),
      });
      
      const validated = loginSchema.parse(req.body);
      const targetRole = validated.target_role || 'traveler';
      
      // Find user by email
      const user = await storage.getUserByEmail(validated.email);
      if (!user || !user.password) {
        return res.status(401).json(createErrorResponse(ErrorCode.INVALID_CREDENTIALS));
      }
      
      // Verify password
      if (!verifyPassword(validated.password, user.password)) {
        return res.status(401).json(createErrorResponse(ErrorCode.INVALID_CREDENTIALS));
      }
      
      const isSuperAdmin = user.email === SUPER_ADMIN_EMAIL;
      
      // Super Admin (God Mode) - can login as any role
      if (isSuperAdmin) {
        console.log(`[GOD MODE] Super admin ${user.email} logging in as ${targetRole}`);
        
        // Auto-seeding for merchant/specialist if needed
        if (targetRole === 'merchant') {
          let merchant = await storage.getMerchantByUserId(user.id);
          if (!merchant) {
            merchant = await storage.createMerchant({
              userId: user.id,
              name: `${user.firstName || 'Admin'}'s Test Store`,
              email: user.email!,
              subscriptionPlan: 'premium',
              dailySeedCode: crypto.randomBytes(4).toString('hex').toUpperCase(),
              creditBalance: 10000,
            });
            console.log(`[GOD MODE] Auto-created merchant for super admin: ${merchant.id}`);
          }
        } else if (targetRole === 'specialist') {
          let specialist = await storage.getSpecialistByUserId(user.id);
          if (!specialist) {
            specialist = await storage.createSpecialist({
              userId: user.id,
              name: `${user.firstName || 'Admin'} Specialist`,
              serviceRegion: 'taipei',
              isAvailable: true,
              maxTravelers: 10,
              currentTravelers: 0,
            });
            console.log(`[GOD MODE] Auto-created specialist for super admin: ${specialist.id}`);
          }
        }
        
        // Generate token with target role (masquerading)
        const token = generateToken(user.id, targetRole);
        
        return res.json({ 
          user: { 
            id: user.id, 
            email: user.email, 
            firstName: user.firstName, 
            lastName: user.lastName,
            role: targetRole,
            actualRole: user.role,
            isApproved: true,
            isSuperAdmin: true,
          }, 
          token 
        });
      }
      
      // Normal User (Strict Mode) - must match target role
      if (user.role !== targetRole) {
        return res.status(403).json({ 
          error: `您的帳號角色為 ${user.role}，無法從 ${targetRole} 入口登入。請使用正確的入口或註冊新帳號。`,
          code: 'ROLE_MISMATCH',
          currentRole: user.role,
          targetRole: targetRole,
        });
      }
      
      // Check approval status for non-traveler roles
      if (user.role !== 'traveler' && !user.isApproved) {
        return res.status(403).json({ 
          error: '帳號審核中，請等待管理員核准',
          code: 'PENDING_APPROVAL',
          isApproved: user.isApproved 
        });
      }
      
      // Generate JWT token
      const token = generateToken(user.id, user.role || 'traveler');
      
      res.json({ 
        user: { 
          id: user.id, 
          email: user.email, 
          firstName: user.firstName, 
          lastName: user.lastName,
          role: user.role,
          isApproved: user.isApproved,
        }, 
        token 
      });
    } catch (error: any) {
      console.error("Login error:", error);
      if (error.name === 'ZodError') {
        return res.status(400).json(createErrorResponse(ErrorCode.VALIDATION_ERROR));
      }
      res.status(500).json(createErrorResponse(ErrorCode.SERVER_ERROR, '登入失敗，請稍後再試'));
    }
  });

  // Apple Sign In
  app.post('/api/auth/apple', async (req, res) => {
    console.log('[Apple Auth] Request received:', JSON.stringify({
      hasIdentityToken: !!req.body?.identityToken,
      hasUser: !!req.body?.user,
      portal: req.body?.portal,
      targetPortal: req.body?.targetPortal,
      keys: Object.keys(req.body || {}),
    }));
    
    try {
      const appleAuthSchema = z.object({
        identityToken: z.string().min(1, 'Identity token is required'),
        fullName: z.object({
          givenName: z.string().nullable().optional(),
          familyName: z.string().nullable().optional(),
        }).nullable().optional(),
        email: z.string().email().nullable().optional(),
        user: z.string().min(1, 'Apple user ID is required'),
        targetPortal: z.enum(['traveler', 'merchant', 'specialist', 'admin']).nullable().optional(),
        portal: z.enum(['traveler', 'merchant', 'specialist', 'admin']).nullable().optional(),
      });
      
      const validated = appleAuthSchema.parse(req.body);
      const { identityToken, fullName, email, user: appleUserId } = validated;
      const targetPortal = validated.targetPortal || validated.portal || 'traveler';
      
      console.log(`[Apple Auth] Verifying token for Apple user: ${appleUserId}`);
      
      // Verify Apple identity token
      // Support both production Bundle ID and Expo Go testing (host.exp.Exponent)
      const validAudiences = [
        process.env.APPLE_CLIENT_ID,
        'host.exp.Exponent', // Expo Go development testing
      ].filter(Boolean) as string[];
      
      let appleTokenPayload: any;
      let verificationSucceeded = false;
      
      for (const audience of validAudiences) {
        try {
          appleTokenPayload = await appleSignin.verifyIdToken(identityToken, {
            audience: audience,
            ignoreExpiration: false,
          });
          verificationSucceeded = true;
          console.log(`[Apple Auth] Token verified with audience: ${audience}`);
          break;
        } catch (verifyError: any) {
          console.log(`[Apple Auth] Token verification failed for audience ${audience}: ${verifyError.message}`);
          continue;
        }
      }
      
      if (!verificationSucceeded) {
        console.error('[Apple Auth] Token verification failed for all audiences');
        return res.status(401).json(createErrorResponse(ErrorCode.INVALID_CREDENTIALS, 'Apple token verification failed'));
      }
      
      // Extract email from token or request body (Apple only sends email on first login)
      const userEmail = appleTokenPayload.email || email;
      const firstName = fullName?.givenName || null;
      const lastName = fullName?.familyName || null;
      
      console.log(`[Apple Auth] Verified. Email: ${userEmail}, Apple sub: ${appleTokenPayload.sub}`);
      
      // Generate unique user ID for Apple users
      const userId = `apple_${appleUserId}`;
      
      // Try to find existing user by Apple ID first
      let existingUser = await storage.getUser(userId);
      
      // If no user found by ID but we have email, check if there's an existing user with this email
      // This handles account merging (e.g., guest user → Apple login)
      if (!existingUser && userEmail) {
        const existingUserByEmail = await storage.getUserByEmail(userEmail);
        if (existingUserByEmail && existingUserByEmail.id !== userId) {
          console.log(`[Apple Auth] Found existing user with same email. Will merge: ${existingUserByEmail.id} -> ${userId}`);
          existingUser = existingUserByEmail; // Use existing user's role for validation
        }
      }
      
      // Security: Apple login only allows 'traveler' portal
      // Merchant/Specialist must use email registration
      if (targetPortal !== 'traveler') {
        return res.status(400).json({
          success: false,
          error: '商家與專員請使用 Email 註冊',
          code: 'APPLE_LOGIN_TRAVELER_ONLY',
        });
      }
      
      // For existing users, validate they're accessing the correct portal
      let userRole: string = 'traveler';
      if (existingUser) {
        userRole = existingUser.role || 'traveler';
        // Check if user is trying to access a different portal than their role
        if (userRole !== 'traveler' && existingUser.email !== SUPER_ADMIN_EMAIL) {
          return res.status(403).json({
            success: false,
            error: `您的帳號角色為 ${userRole}，請使用對應入口登入`,
            code: 'ROLE_MISMATCH',
            currentRole: userRole,
            targetPortal: targetPortal,
          });
        }
      }
      
      // upsertUser handles account merging if email matches existing user
      const user = await storage.upsertUser({
        id: userId,
        email: userEmail,
        firstName: firstName,
        lastName: lastName,
        role: userRole,
        provider: 'apple',
        isApproved: userRole === 'traveler' ? true : (existingUser?.isApproved || false),
      });
      
      console.log(`[Apple Auth] User upserted: ${user.id}, role: ${user.role}`);
      
      const isSuperAdmin = user.email === SUPER_ADMIN_EMAIL;
      
      // For non-traveler roles, check approval status (unless super admin)
      if (!isSuperAdmin && user.role !== 'traveler' && !user.isApproved) {
        return res.status(403).json({
          success: false,
          error: '帳號審核中，請等待管理員核准',
          code: 'PENDING_APPROVAL',
        });
      }
      
      // Generate JWT token
      const token = generateToken(user.id, user.role || 'traveler');
      
      res.json({
        success: true,
        token,
        user: {
          id: user.id,
          email: user.email || '',
          name: [user.firstName, user.lastName].filter(Boolean).join(' ') || 'Apple User',
          role: user.role,
          isApproved: user.isApproved,
          isSuperAdmin,
        },
      });
    } catch (error: any) {
      console.error('[Apple Auth] Error:', error);
      if (error.name === 'ZodError') {
        const zodError = error as z.ZodError;
        const issues = zodError.issues.map(i => `${i.path.join('.')}: ${i.message}`).join(', ');
        console.error(`[Apple Auth] Zod validation failed: ${issues}`);
        console.error(`[Apple Auth] Received body keys: ${Object.keys(req.body || {}).join(', ')}`);
        console.error(`[Apple Auth] Received body (masked):`, JSON.stringify({
          identityToken: req.body?.identityToken ? `[${String(req.body.identityToken).length} chars]` : undefined,
          user: req.body?.user,
          portal: req.body?.portal,
          targetPortal: req.body?.targetPortal,
          email: req.body?.email,
          fullName: req.body?.fullName,
        }));
        return res.status(400).json(createErrorResponse(ErrorCode.VALIDATION_ERROR, `Invalid request data: ${issues}`));
      }
      res.status(500).json(createErrorResponse(ErrorCode.SERVER_ERROR, 'Apple authentication failed'));
    }
  });

  // Get current authenticated user
  app.get('/api/auth/user', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const user = await storage.getUser(userId);
      
      // Check if user is super admin (can access any interface)
      const SUPER_ADMIN_EMAIL = 's8869420@gmail.com';
      const isSuperAdmin = user?.email === SUPER_ADMIN_EMAIL;
      
      const accessibleRoles = isSuperAdmin 
        ? ['traveler', 'merchant', 'specialist', 'admin'] 
        : [user?.role || 'traveler'];
      
      // Get active role: Priority: JWT token > session > database role
      // For JWT auth (mobile app), read from jwtUser.activeRole
      // For session auth (web), read from session.activeRole
      const jwtActiveRole = req.jwtUser?.activeRole;
      const sessionActiveRole = req.session?.activeRole;
      const activeRole = jwtActiveRole || sessionActiveRole || user?.role || 'traveler';
      
      console.log(`[/api/auth/user] userId: ${userId}, jwtActiveRole: ${jwtActiveRole}, sessionActiveRole: ${sessionActiveRole}, finalActiveRole: ${activeRole}`);
      
      // For super admin god mode: return activeRole as the "role" field for frontend compatibility
      const responseRole = isSuperAdmin ? activeRole : (user?.role || 'traveler');
      
      res.json({
        ...user,
        isSuperAdmin,
        accessibleRoles,
        activeRole: accessibleRoles.includes(activeRole) ? activeRole : (user?.role || 'traveler'),
        role: responseRole, // Override role for super admin god mode
      });
    } catch (error) {
      console.error("Error fetching user:", error);
      res.status(500).json({ message: "Failed to fetch user" });
    }
  });

  // Switch active role (for super admin God Mode)
  app.post('/api/auth/switch-role', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const user = await storage.getUser(userId);
      
      const SUPER_ADMIN_EMAIL = 's8869420@gmail.com';
      const isSuperAdmin = user?.email === SUPER_ADMIN_EMAIL;
      
      const switchRoleSchema = z.object({
        role: z.enum(['traveler', 'merchant', 'specialist', 'admin']),
      });
      
      const { role: targetRole } = switchRoleSchema.parse(req.body);
      
      // Check if user can access this role
      const accessibleRoles = isSuperAdmin 
        ? ['traveler', 'merchant', 'specialist', 'admin'] 
        : [user?.role || 'traveler'];
      
      if (!accessibleRoles.includes(targetRole)) {
        return res.status(403).json({ 
          error: '您沒有權限切換到此角色', 
          code: 'ROLE_NOT_ACCESSIBLE' 
        });
      }
      
      // Store active role in session
      if (req.session) {
        req.session.activeRole = targetRole;
      }
      
      // Auto-seed merchant/specialist data for super admin
      if (isSuperAdmin) {
        if (targetRole === 'merchant') {
          let merchant = await storage.getMerchantByUserId(user!.id);
          if (!merchant) {
            merchant = await storage.createMerchant({
              userId: user!.id,
              name: `${user!.firstName || 'Admin'}'s Test Store`,
              email: user!.email!,
              subscriptionPlan: 'premium',
              dailySeedCode: crypto.randomBytes(4).toString('hex').toUpperCase(),
              creditBalance: 10000,
            });
            console.log(`[GOD MODE] Auto-created merchant for super admin: ${merchant.id}`);
          }
        } else if (targetRole === 'specialist') {
          let specialist = await storage.getSpecialistByUserId(user!.id);
          if (!specialist) {
            specialist = await storage.createSpecialist({
              userId: user!.id,
              name: `${user!.firstName || 'Admin'} Specialist`,
              serviceRegion: 'taipei',
              isAvailable: true,
              maxTravelers: 10,
            });
            console.log(`[GOD MODE] Auto-created specialist for super admin: ${specialist.id}`);
          }
        }
      }
      
      console.log(`[Role Switch] User ${userId} switched to role: ${targetRole}`);
      
      // Generate new JWT token with updated activeRole
      const newToken = generateJwtToken({
        claims: {
          sub: user!.id,
          email: user!.email,
          first_name: user!.firstName,
          last_name: user!.lastName,
          profile_image_url: user!.profileImageUrl,
        }
      }, targetRole);
      
      res.json({ 
        success: true, 
        activeRole: targetRole,
        role: targetRole, // For frontend compatibility
        token: newToken, // New token with updated activeRole
        message: `已切換至${targetRole === 'traveler' ? '旅客' : targetRole === 'merchant' ? '商家' : targetRole === 'specialist' ? '專員' : '管理員'}模式`
      });
    } catch (error: any) {
      console.error("Switch role error:", error);
      if (error.name === 'ZodError') {
        return res.status(400).json({ error: '無效的角色', code: 'INVALID_ROLE' });
      }
      res.status(500).json(createErrorResponse(ErrorCode.SERVER_ERROR, '切換角色失敗'));
    }
  });

  // Check if user has unlimited generation privilege
  app.get('/api/auth/privileges', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const user = await storage.getUser(userId);
      const hasUnlimitedGeneration = user?.email && UNLIMITED_GENERATION_EMAILS.includes(user.email);
      res.json({ hasUnlimitedGeneration });
    } catch (error) {
      res.json({ hasUnlimitedGeneration: false });
    }
  });

  // ============ Logout ============
  
  app.post('/api/auth/logout', async (req: any, res) => {
    try {
      if (req.session) {
        req.session.destroy((err: any) => {
          if (err) console.error('Session destroy error:', err);
        });
      }
      res.clearCookie('connect.sid');
      res.json({ success: true, message: '已成功登出' });
    } catch (error) {
      console.error('Logout error:', error);
      res.status(500).json(createErrorResponse(ErrorCode.SERVER_ERROR, '登出失敗'));
    }
  });

  // ============ Profile Routes (設定頁面) ============

  app.get('/api/profile', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub || req.jwtUser?.userId;
      if (!userId) return res.status(401).json(createErrorResponse(ErrorCode.AUTH_REQUIRED));
      
      const user = await storage.getUser(userId);
      if (!user) return res.status(404).json(createErrorResponse(ErrorCode.USER_NOT_FOUND));

      res.json({
        id: user.id,
        email: user.email,
        firstName: user.firstName,
        lastName: user.lastName,
        profileImageUrl: user.profileImageUrl,
        role: user.role,
        gender: user.gender,
        birthDate: user.birthDate,
        phone: user.phone,
        dietaryRestrictions: user.dietaryRestrictions || [],
        medicalHistory: user.medicalHistory || [],
        emergencyContactName: user.emergencyContactName,
        emergencyContactPhone: user.emergencyContactPhone,
        emergencyContactRelation: user.emergencyContactRelation,
        preferredLanguage: user.preferredLanguage || 'zh-TW',
      });
    } catch (error) {
      console.error('Get profile error:', error);
      res.status(500).json(createErrorResponse(ErrorCode.SERVER_ERROR, '無法取得用戶資料'));
    }
  });

  app.patch('/api/profile', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub || req.jwtUser?.userId;
      if (!userId) return res.status(401).json(createErrorResponse(ErrorCode.AUTH_REQUIRED));

      const { updateProfileSchema } = await import('@shared/schema');
      const validated = updateProfileSchema.parse(req.body);
      
      const updateData: any = { ...validated };
      if (validated.birthDate) {
        updateData.birthDate = new Date(validated.birthDate);
      }

      const updatedUser = await storage.updateUser(userId, updateData);
      if (!updatedUser) return res.status(404).json(createErrorResponse(ErrorCode.USER_NOT_FOUND));

      res.json({
        success: true,
        message: '個人資料已更新',
        profile: {
          firstName: updatedUser.firstName,
          lastName: updatedUser.lastName,
          gender: updatedUser.gender,
          birthDate: updatedUser.birthDate,
          phone: updatedUser.phone,
          dietaryRestrictions: updatedUser.dietaryRestrictions || [],
          medicalHistory: updatedUser.medicalHistory || [],
          emergencyContactName: updatedUser.emergencyContactName,
          emergencyContactPhone: updatedUser.emergencyContactPhone,
          emergencyContactRelation: updatedUser.emergencyContactRelation,
          preferredLanguage: updatedUser.preferredLanguage,
        }
      });
    } catch (error: any) {
      console.error('Update profile error:', error);
      if (error.name === 'ZodError') {
        return res.status(400).json({ error: '資料格式錯誤', details: error.errors });
      }
      res.status(500).json(createErrorResponse(ErrorCode.SERVER_ERROR, '無法更新用戶資料'));
    }
  });

  // ============ SOS Alerts (安全中心) ============

  app.get('/api/sos/eligibility', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub || req.jwtUser?.userId;
      if (!userId) return res.status(401).json(createErrorResponse(ErrorCode.AUTH_REQUIRED));

      const hasPurchased = await storage.hasUserPurchasedTripService(userId);
      res.json({ 
        eligible: hasPurchased,
        reason: hasPurchased ? null : '需購買旅程服務才能使用安全中心功能'
      });
    } catch (error) {
      console.error('SOS eligibility check error:', error);
      res.status(500).json(createErrorResponse(ErrorCode.SERVER_ERROR, '無法檢查資格'));
    }
  });

  app.post('/api/sos/alert', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub || req.jwtUser?.userId;
      if (!userId) return res.status(401).json(createErrorResponse(ErrorCode.AUTH_REQUIRED));

      const hasPurchased = await storage.hasUserPurchasedTripService(userId);
      if (!hasPurchased) {
        return res.status(403).json({ 
          error: '需購買旅程服務才能使用 SOS 求救功能',
          requiresPurchase: true
        });
      }

      const { insertSosAlertSchema } = await import('@shared/schema');
      const validated = insertSosAlertSchema.parse({ ...req.body, userId });

      const alert = await storage.createSosAlert(validated);
      console.log('🆘 SOS Alert Created:', alert);

      res.json({
        success: true,
        alertId: alert.id,
        message: '求救訊號已發送，我們會盡快聯繫您',
      });
    } catch (error: any) {
      console.error('Create SOS alert error:', error);
      if (error.name === 'ZodError') {
        return res.status(400).json({ error: '資料格式錯誤', details: error.errors });
      }
      res.status(500).json(createErrorResponse(ErrorCode.SERVER_ERROR, '無法發送求救訊號'));
    }
  });

  app.get('/api/sos/alerts', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub || req.jwtUser?.userId;
      if (!userId) return res.status(401).json(createErrorResponse(ErrorCode.AUTH_REQUIRED));

      const alerts = await storage.getUserSosAlerts(userId);
      res.json({ alerts });
    } catch (error) {
      console.error('Get SOS alerts error:', error);
      res.status(500).json(createErrorResponse(ErrorCode.SERVER_ERROR, '無法取得求救記錄'));
    }
  });

  app.patch('/api/sos/alerts/:id/cancel', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub || req.jwtUser?.userId;
      const alertId = parseInt(req.params.id);
      
      if (!userId) return res.status(401).json(createErrorResponse(ErrorCode.AUTH_REQUIRED));

      const alert = await storage.getSosAlertById(alertId);
      if (!alert || alert.userId !== userId) {
        return res.status(404).json({ error: '找不到求救記錄' });
      }

      if (alert.status !== 'pending') {
        return res.status(400).json({ error: '無法取消已處理的求救' });
      }

      const updated = await storage.updateSosAlertStatus(alertId, 'cancelled');
      res.json({ success: true, alert: updated });
    } catch (error) {
      console.error('Cancel SOS alert error:', error);
      res.status(500).json(createErrorResponse(ErrorCode.SERVER_ERROR, '無法取消求救'));
    }
  });

  // ============ Location Routes ============

  app.post('/api/location/update', isAuthenticated, async (req: any, res) => {
    const userId = req.user?.claims?.sub;
    console.log('📍 Location Update Request:', { userId, body: req.body });
    
    const locationSchema = z.object({
      lat: z.number().min(-90).max(90),
      lon: z.number().min(-180).max(180),
      isSharingEnabled: z.boolean().optional(),
      targets: z.array(z.object({
        id: z.union([z.string(), z.number()]),
        name: z.string(),
        lat: z.number().min(-90).max(90),
        lon: z.number().min(-180).max(180),
        radiusMeters: z.number().min(1).max(10000).default(50),
      })).optional(),
    });

    try {
      const validated = locationSchema.parse(req.body);
      console.log('📍 Location Update Validated:', { userId, lat: validated.lat, lon: validated.lon, isSharingEnabled: validated.isSharingEnabled });
      
      let sharingEnabled = validated.isSharingEnabled;
      if (sharingEnabled === undefined) {
        const existingLocation = await storage.getUserLocation(userId);
        sharingEnabled = existingLocation?.isSharingEnabled ?? true;
      }
      
      const location = await storage.upsertUserLocation(
        userId,
        validated.lat,
        validated.lon,
        sharingEnabled
      );
      
      const geofenceResult = checkGeofence(
        { lat: validated.lat, lon: validated.lon },
        validated.targets || []
      );
      
      res.json({ 
        status: "ok",
        arrived: geofenceResult.arrived,
        target: geofenceResult.target,
        distanceMeters: geofenceResult.distanceMeters,
        location,
        message: sharingEnabled ? '位置已更新' : '位置共享已關閉'
      });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ status: "error", error: error.errors });
      }
      console.error("Error updating location:", error);
      res.status(500).json({ status: "error", error: "Failed to update location" });
    }
  });

  app.get('/api/location/me', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const location = await storage.getUserLocation(userId);
      res.json(location || null);
    } catch (error) {
      console.error("Error fetching location:", error);
      res.status(500).json({ error: "Failed to fetch location" });
    }
  });

  // ============ SOS Emergency Routes ============

  // Trigger SOS mode via webhook (for iOS Shortcuts, no auth required - uses secret key)
  app.post('/api/sos/trigger', async (req, res) => {
    const key = req.query.key as string;
    console.log('🚨 SOS Trigger Request:', { key: key ? `${key.slice(0, 8)}...` : 'missing', body: req.body });
    
    const sosSchema = z.object({
      lat: z.number().min(-90).max(90).optional(),
      lon: z.number().min(-180).max(180).optional(),
    });

    try {
      if (!key) {
        console.log('🚨 SOS Trigger Failed: Missing key');
        return res.status(401).json({ status: "error", error: "Missing SOS key" });
      }

      const user = await storage.getUserBySosKey(key);
      if (!user) {
        console.log('🚨 SOS Trigger Failed: Invalid key');
        return res.status(401).json({ status: "error", error: "Invalid SOS key" });
      }

      console.log('🚨 SOS Trigger Authenticated:', { userId: user.id, userName: `${user.firstName} ${user.lastName}` });
      const validated = sosSchema.parse(req.body);
      
      // Enable SOS mode
      let location = await storage.getUserLocation(user.id);
      
      if (validated.lat !== undefined && validated.lon !== undefined) {
        // Update location and enable SOS mode
        location = await storage.upsertUserLocation(
          user.id,
          validated.lat,
          validated.lon,
          location?.isSharingEnabled ?? true,
          true // sosMode = true
        );
      } else if (location) {
        // Just enable SOS mode without updating location
        location = await storage.setSosMode(user.id, true);
      } else {
        return res.status(400).json({ status: "error", error: "No location data available. Please provide lat/lon." });
      }

      // TODO: Notify planner via push notification or SMS
      console.log(`[SOS TRIGGERED] User ${user.id} (${user.firstName} ${user.lastName}) triggered SOS mode`);
      
      res.json({ 
        status: "ok", 
        message: "SOS mode activated",
        location
      });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ status: "error", error: error.errors });
      }
      console.error("Error triggering SOS:", error);
      res.status(500).json({ status: "error", error: "Failed to trigger SOS" });
    }
  });

  // Deactivate SOS mode (requires auth)
  app.post('/api/sos/deactivate', isAuthenticated, async (req: any, res) => {
    const userId = req.user?.claims?.sub;
    console.log('🚨 SOS Deactivate Request:', { userId });
    
    try {
      const location = await storage.setSosMode(userId, false);
      
      if (!location) {
        return res.status(404).json({ status: "error", error: "No location found" });
      }

      console.log(`[SOS DEACTIVATED] User ${userId} deactivated SOS mode`);
      res.json({ status: "ok", message: "SOS mode deactivated", location });
    } catch (error) {
      console.error("Error deactivating SOS:", error);
      res.status(500).json({ status: "error", error: "Failed to deactivate SOS" });
    }
  });

  // Get SOS webhook link (requires auth)
  app.get('/api/user/sos-link', isAuthenticated, async (req: any, res) => {
    const userId = req.user?.claims?.sub;
    console.log('🔗 SOS Link Request:', { userId });
    
    try {
      const user = await storage.getUser(userId);
      
      if (!user) {
        return res.status(404).json({ error: "User not found" });
      }

      let sosKey = user.sosSecretKey;
      
      // Generate new key if not exists
      if (!sosKey) {
        sosKey = await storage.generateSosKey(userId);
      }

      const baseUrl = process.env.REPLIT_DEV_DOMAIN 
        ? `https://${process.env.REPLIT_DEV_DOMAIN}`
        : process.env.REPLIT_DOMAINS?.split(',')[0] 
          ? `https://${process.env.REPLIT_DOMAINS.split(',')[0]}`
          : 'https://your-app.replit.app';

      const webhookUrl = `${baseUrl}/api/sos/trigger?key=${sosKey}`;
      
      res.json({ 
        webhookUrl,
        sosKey,
        instructions: {
          method: "POST",
          body: "Optional JSON: { \"lat\": number, \"lon\": number }",
          example: `curl -X POST "${webhookUrl}" -H "Content-Type: application/json" -d '{"lat": 25.0330, "lon": 121.5654}'`
        }
      });
    } catch (error) {
      console.error("Error getting SOS link:", error);
      res.status(500).json({ error: "Failed to get SOS link" });
    }
  });

  // Regenerate SOS key (requires auth)
  app.post('/api/user/sos-key/regenerate', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const newKey = await storage.generateSosKey(userId);
      
      res.json({ 
        status: "ok",
        message: "SOS key regenerated successfully",
        sosKey: newKey
      });
    } catch (error) {
      console.error("Error regenerating SOS key:", error);
      res.status(500).json({ error: "Failed to regenerate SOS key" });
    }
  });

  // ============ Delete User Account ============
  
  app.delete('/api/user/account', isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      
      if (!userId) {
        return res.status(401).json({ 
          success: false, 
          error: "未授權",
          code: "UNAUTHORIZED" 
        });
      }
      
      console.log(`[Account Deletion] User ${userId} requested account deletion`);
      
      const result = await storage.deleteUserAccount(userId);
      
      if (result.success) {
        console.log(`[Account Deletion] User ${userId} account deleted successfully`);
        res.json({ 
          success: true, 
          message: "帳號已成功刪除" 
        });
      } else {
        // 根據錯誤代碼返回適當的狀態碼
        const statusCode = result.code === 'MERCHANT_ACCOUNT_EXISTS' ? 400 : 500;
        console.log(`[Account Deletion] Failed to delete user ${userId}: ${result.code}`);
        res.status(statusCode).json({ 
          success: false, 
          error: result.error,
          code: result.code
        });
      }
    } catch (error) {
      console.error("Delete account error:", error);
      res.status(500).json({ 
        success: false, 
        error: "刪除帳號時發生錯誤",
        code: "SERVER_ERROR" 
      });
    }
  });

  // ============ Collection Routes ============
  
  app.get("/api/collections", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const items = await storage.getUserCollections(userId);
      res.json({ collections: items });
    } catch (error) {
      console.error("Fetch collections error:", error);
      res.status(500).json({ error: "Failed to fetch collections" });
    }
  });

  // Get merchant promo for a specific place (by placeId or placeName+district+city)
  app.get("/api/place/promo", async (req, res) => {
    try {
      const { placeId, placeName, district, city } = req.query;
      
      let merchantLink = null;
      
      // First try to find by Google Place ID (most accurate)
      if (placeId && typeof placeId === 'string') {
        merchantLink = await storage.getPlaceLinkByGooglePlaceId(placeId);
      }
      
      // Fallback to placeName + district + city
      if (!merchantLink && placeName && district && city) {
        merchantLink = await storage.getPlaceLinkByPlace(
          placeName as string,
          district as string,
          city as string
        );
      }
      
      if (!merchantLink || !merchantLink.isPromoActive) {
        return res.json({ promo: null });
      }
      
      res.json({
        promo: {
          title: merchantLink.promoTitle,
          description: merchantLink.promoDescription,
          imageUrl: merchantLink.promoImageUrl
        }
      });
    } catch (error) {
      console.error("Get place promo error:", error);
      res.status(500).json({ error: "Failed to get place promo" });
    }
  });

  app.post("/api/collections", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const validated = insertCollectionSchema.parse({ ...req.body, userId });
      const collection = await storage.addToCollection(validated);
      res.json({ collection });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ error: error.errors });
      }
      console.error("Add collection error:", error);
      res.status(500).json({ error: "Failed to add to collection" });
    }
  });

  // ============ Merchant Routes ============
  
  app.get("/api/merchant", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const merchant = await storage.getMerchantByUserId(userId);
      
      if (!merchant) {
        return res.status(404).json({ error: "Merchant not found" });
      }
      
      res.json({ merchant });
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch merchant" });
    }
  });

  app.post("/api/merchant", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const validated = insertMerchantSchema.parse({ ...req.body, userId });
      const merchant = await storage.createMerchant(validated);
      res.json({ merchant });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ error: error.errors });
      }
      res.status(500).json({ error: "Failed to create merchant" });
    }
  });

  app.patch("/api/merchant/:id/plan", isAuthenticated, async (req, res) => {
    try {
      const merchantId = parseInt(req.params.id);
      const { plan } = req.body;
      
      if (!['free', 'partner', 'premium'].includes(plan)) {
        return res.status(400).json({ error: "Invalid plan" });
      }
      
      const merchant = await storage.updateMerchantPlan(merchantId, plan);
      res.json({ merchant });
    } catch (error) {
      res.status(500).json({ error: "Failed to update plan" });
    }
  });

  // ============ Coupon Routes ============
  
  app.get("/api/coupons/merchant/:merchantId", isAuthenticated, async (req, res) => {
    try {
      const merchantId = parseInt(req.params.merchantId);
      const allCoupons = await storage.getMerchantCoupons(merchantId);
      res.json({ coupons: allCoupons });
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch coupons" });
    }
  });

  app.post("/api/coupons", isAuthenticated, async (req, res) => {
    try {
      const validated = insertCouponSchema.parse(req.body);
      const coupon = await storage.createCoupon(validated);
      res.json({ coupon });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ error: error.errors });
      }
      res.status(500).json({ error: "Failed to create coupon" });
    }
  });

  app.patch("/api/coupons/:id", isAuthenticated, async (req, res) => {
    try {
      const couponId = parseInt(req.params.id);
      const coupon = await storage.updateCoupon(couponId, req.body);
      res.json({ coupon });
    } catch (error) {
      res.status(500).json({ error: "Failed to update coupon" });
    }
  });

  // 取得區域獎池 (SP/SSR 優惠券)
  app.get("/api/coupons/region/:regionId/pool", async (req, res) => {
    try {
      const regionId = parseInt(req.params.regionId);
      if (isNaN(regionId)) {
        return res.status(400).json({ error: "Invalid region ID" });
      }
      
      const coupons = await storage.getRegionPrizePoolCoupons(regionId);
      res.json({ coupons });
    } catch (error) {
      console.error("Failed to fetch prize pool:", error);
      res.status(500).json({ error: "Failed to fetch prize pool" });
    }
  });

  // ============ Category & Sub-category Data ============
  // Note: DISTRICT_DATA and getRandomDistrict removed - now using database queries via storage.getRandomDistrictByRegion/getRandomDistrictByCountry
  const CATEGORY_DATA: Record<string, { subCategories: string[]; weight: number; timeSlots: string[] }> = {
    '食': {
      subCategories: ['火鍋', '小吃', '異國料理', '日式料理', '中式料理', '西式料理', '咖啡廳', '甜點', '夜市美食', '素食', '海鮮', '燒烤', '拉麵', '鐵板燒', '牛排', '早午餐', '台式便當', '港式飲茶'],
      weight: 3,
      timeSlots: ['breakfast', 'lunch', 'tea_time', 'dinner', 'late_night']
    },
    '宿': {
      subCategories: ['五星飯店', '商務旅館', '民宿', '青年旅社', '溫泉旅館', '設計旅店', '膠囊旅館', '度假村'],
      weight: 0,
      timeSlots: ['overnight']
    },
    '生態文化教育': {
      subCategories: ['博物館', '美術館', '科學館', '歷史古蹟', '文化中心', '圖書館', '紀念館', '展覽館'],
      weight: 2,
      timeSlots: ['morning', 'afternoon']
    },
    '遊程體驗': {
      subCategories: ['導覽行程', '手作體驗', '烹飪課程', '文化體驗', '農場體驗', '茶道體驗', '攝影之旅', '單車遊'],
      weight: 2,
      timeSlots: ['morning', 'afternoon']
    },
    '娛樂設施': {
      subCategories: ['遊樂園', '電影院', 'KTV', '酒吧', '夜店', '桌遊店', '密室逃脫', '電玩中心'],
      weight: 1,
      timeSlots: ['afternoon', 'evening', 'night']
    },
    '活動': {
      subCategories: ['登山健行', '水上活動', '極限運動', '瑜珈課程', '運動賽事', '音樂會', '市集活動', 'SPA按摩'],
      weight: 2,
      timeSlots: ['morning', 'afternoon', 'evening']
    },
    '景點': {
      subCategories: ['自然風景', '地標建築', '公園綠地', '觀景台', '寺廟宗教', '老街', '海灘', '溫泉'],
      weight: 3,
      timeSlots: ['morning', 'afternoon', 'evening']
    },
    '購物': {
      subCategories: ['百貨公司', '購物中心', '傳統市場', '商店街', '特色小店', '伴手禮店', '二手店', '藥妝店'],
      weight: 1,
      timeSlots: ['afternoon', 'evening']
    }
  };

  const TIME_SLOT_ORDER = ['breakfast', 'morning', 'lunch', 'afternoon', 'tea_time', 'dinner', 'evening', 'night', 'late_night', 'overnight'];

  interface SkeletonItem {
    order: number;
    category: string;
    subCategory: string;
    timeSlot: string;
    suggestedTime: string;
    energyLevel: 'high' | 'medium' | 'low';
  }

  function generateItinerarySkeleton(targetDistrict: string, cardCount: number): {
    targetDistrict: string;
    userRequestCount: number;
    generatedCount: number;
    skeleton: SkeletonItem[];
  } {
    const K = Math.min(12, Math.max(5, cardCount));
    
    const lockedDistrict = targetDistrict;
    
    const stayCount = K >= 8 ? 1 : 0;
    let foodMin = 2;
    if (K >= 7 && K <= 8) foodMin = 3;
    if (K >= 9) foodMin = 4;
    
    const skeleton: SkeletonItem[] = [];
    const usedSubCategories = new Set<string>();
    
    function pickSubCategory(category: string): string {
      const subs = CATEGORY_DATA[category].subCategories;
      const available = subs.filter(s => !usedSubCategories.has(`${category}:${s}`));
      if (available.length === 0) {
        return subs[Math.floor(Math.random() * subs.length)];
      }
      const picked = available[Math.floor(Math.random() * available.length)];
      usedSubCategories.add(`${category}:${picked}`);
      return picked;
    }

    const foodTimeSlots = ['breakfast', 'lunch', 'dinner', 'tea_time', 'late_night'];
    let foodSlotIndex = 0;
    for (let i = 0; i < foodMin; i++) {
      skeleton.push({
        order: 0,
        category: '食',
        subCategory: pickSubCategory('食'),
        timeSlot: foodTimeSlots[foodSlotIndex % foodTimeSlots.length],
        suggestedTime: '',
        energyLevel: 'low'
      });
      foodSlotIndex++;
    }

    if (stayCount > 0) {
      skeleton.push({
        order: 0,
        category: '宿',
        subCategory: pickSubCategory('宿'),
        timeSlot: 'overnight',
        suggestedTime: '22:00',
        energyLevel: 'low'
      });
    }

    const remainingSlots = K - skeleton.length;
    const fillableCategories = ['生態文化教育', '遊程體驗', '娛樂設施', '活動', '景點', '購物'];
    const weights = fillableCategories.map(c => CATEGORY_DATA[c].weight);
    const totalWeight = weights.reduce((a, b) => a + b, 0);

    let lastActivityCount = 0;
    const activityCategories = ['生態文化教育', '遊程體驗', '活動', '景點'];

    for (let i = 0; i < remainingSlots; i++) {
      let selectedCategory: string;
      
      if (lastActivityCount >= 2) {
        const restCategories = ['食', '購物'];
        selectedCategory = restCategories[Math.floor(Math.random() * restCategories.length)];
        lastActivityCount = 0;
      } else {
        const rand = Math.random() * totalWeight;
        let cumulative = 0;
        selectedCategory = fillableCategories[0];
        for (let j = 0; j < fillableCategories.length; j++) {
          cumulative += weights[j];
          if (rand < cumulative) {
            selectedCategory = fillableCategories[j];
            break;
          }
        }
      }

      if (activityCategories.includes(selectedCategory)) {
        lastActivityCount++;
      } else {
        lastActivityCount = 0;
      }

      const validSlots = CATEGORY_DATA[selectedCategory].timeSlots;
      const timeSlot = validSlots[Math.floor(Math.random() * validSlots.length)];

      let energyLevel: 'high' | 'medium' | 'low' = 'medium';
      if (['活動', '遊程體驗'].includes(selectedCategory)) {
        energyLevel = 'high';
      } else if (['食', '購物', '宿'].includes(selectedCategory)) {
        energyLevel = 'low';
      }

      skeleton.push({
        order: 0,
        category: selectedCategory,
        subCategory: pickSubCategory(selectedCategory),
        timeSlot: timeSlot,
        suggestedTime: '',
        energyLevel: energyLevel
      });
    }

    skeleton.sort((a, b) => {
      const aIdx = TIME_SLOT_ORDER.indexOf(a.timeSlot);
      const bIdx = TIME_SLOT_ORDER.indexOf(b.timeSlot);
      return aIdx - bIdx;
    });

    const timeMap: Record<string, string> = {
      'breakfast': '08:00',
      'morning': '10:00',
      'lunch': '12:30',
      'afternoon': '14:30',
      'tea_time': '16:00',
      'dinner': '18:30',
      'evening': '20:00',
      'night': '21:30',
      'late_night': '22:30',
      'overnight': '23:00'
    };

    skeleton.forEach((item, idx) => {
      item.order = idx + 1;
      item.suggestedTime = timeMap[item.timeSlot] || '12:00';
    });

    return {
      targetDistrict: lockedDistrict,
      userRequestCount: cardCount,
      generatedCount: skeleton.length,
      skeleton: skeleton
    };
  }

  // ============ Gemini AI Itinerary Generation ============

  app.post("/api/generate-itinerary", async (req, res) => {
    console.log('[generate-itinerary] API called with:', req.body);
    try {
      const { regionId, countryId, level, language, collectedNames } = req.body;
      
      // Validate: must have regionId or countryId (use database, no hardcoding)
      if (!regionId && !countryId) {
        return res.status(400).json(createErrorResponse(ErrorCode.MISSING_LOCATION_ID));
      }
      
      // Step 1: Get random district from database (no DISTRICT_DATA)
      let district;
      if (regionId) {
        district = await storage.getRandomDistrictByRegion(regionId);
      } else {
        district = await storage.getRandomDistrictByCountry(countryId);
      }
      
      if (!district) {
        return res.status(404).json(createErrorResponse(ErrorCode.NO_DISTRICT_FOUND));
      }
      
      // Step 2: Get full hierarchy (district, region, country) from database
      const hierarchy = await storage.getDistrictWithParents(district.id);
      if (!hierarchy) {
        return res.status(500).json({ error: "Failed to get location hierarchy" });
      }
      
      const { district: districtInfo, region, country: countryInfo } = hierarchy;
      const targetDistrict = districtInfo.nameZh;
      const city = region.nameZh;
      const country = countryInfo.nameZh;
      
      console.log('[generate-itinerary] Resolved location:', { targetDistrict, city, country, districtId: district.id });
      
      const langMap: Record<string, string> = {
        'zh-TW': '繁體中文',
        'en': 'English',
        'ja': '日本語',
        'ko': '한국어'
      };
      const outputLang = langMap[language] || 'English';
      
      const itemCount = Math.min(12, Math.max(5, Math.floor(level * 1.2)));
      
      // Pass targetDistrict directly (no more getRandomDistrict call)
      const skeletonResult = generateItinerarySkeleton(targetDistrict, itemCount);
      const { skeleton } = skeletonResult;

      const categoryMap: Record<string, string> = {
        '食': 'Food', '宿': 'Stay', '生態文化教育': 'Education',
        '遊程體驗': 'Activity', '娛樂設施': 'Entertainment',
        '活動': 'Activity', '景點': 'Scenery', '購物': 'Shopping'
      };

      // Check cache for existing places (using DB-resolved names)
      const cachedPlaces = await storage.getCachedPlaces(targetDistrict, city, country);
      const cacheMap = new Map(cachedPlaces.map(p => [p.subCategory, p]));
      
      // Separate skeleton items into cached and uncached
      // Track used place names to prevent duplicates within the same pull
      const usedPlaceNamesInPull: Set<string> = new Set(collectedNames || []);
      const cachedItems: any[] = [];
      const uncachedSkeleton: Array<typeof skeleton[0] & { originalIdx: number }> = [];
      
      skeleton.forEach((item, idx) => {
        const cached = cacheMap.get(item.subCategory);
        // Check both collectedNames AND usedPlaceNamesInPull to prevent duplicates
        if (cached && !usedPlaceNamesInPull.has(cached.placeName)) {
          cachedItems.push({
            skeletonIdx: idx,
            cached: cached,
            skeleton: item
          });
          // Mark this place as used so it won't appear again in this pull
          usedPlaceNamesInPull.add(cached.placeName);
        } else {
          uncachedSkeleton.push({ ...item, originalIdx: idx });
        }
      });

      console.log(`Cache hit: ${cachedItems.length}/${skeleton.length} items from cache`);

      let aiGeneratedItems: any[] = [];

      // Only call Gemini if there are uncached items
      if (uncachedSkeleton.length > 0) {
        const skeletonInstructions = uncachedSkeleton.map((item, idx) => 
          `${idx + 1}. [${item.timeSlot}] ${categoryMap[item.category] || item.category} - ${item.subCategory} (${item.suggestedTime}, energy: ${item.energyLevel})`
        ).join('\n');

        const prompt = `You are a professional travel planner AI. Fill in REAL place names for this itinerary skeleton in ${city}, ${country}.

【目標區域 Target District】
All places MUST be in or near "${targetDistrict}" district.

【行程骨架 Itinerary Skeleton - FOLLOW THIS EXACTLY】
${skeletonInstructions}

【重要規則 CRITICAL RULES】
1. place_name 必須是「真實存在的店家名稱」，例如：
   - 正確: "阿嬌熱炒"、"蘭姐鴨肉飯"、"石碇老街"、"功維敘隧道"
   - 錯誤: "壯圍鄉景點探索"、"南澳鄉食探索"、"XX鄉購物探索"
2. 絕對禁止使用「地區名+類別+探索」格式的假名稱
3. 如果該區域確實沒有符合類別的店家，請推薦鄰近區域的真實店家
4. place_name 必須可以在 Google Maps 搜尋到

【動線順暢原則 Route Flow】
- 推薦鄰近區域的店家時，優先選擇「相鄰區域」而非遠方區域
- 考慮時間順序：早上的地點、中午的地點、下午的地點應該在合理的移動範圍內
- 避免讓使用者來回奔波，地點之間的移動距離應控制在 30 分鐘車程以內
- 如果必須跨區，請選擇同一方向上的區域

【任務說明 Your Task】
For each skeleton slot, find a REAL business/location in or near ${targetDistrict}:
- Must be an actual restaurant, shop, attraction, or business with a real name
- Can be searched and found on Google Maps
- If no matching place in ${targetDistrict}, suggest one from a nearby district (prefer adjacent areas)
- Ensure route flow is smooth - places should be geographically close to minimize travel time

【排除清單 Exclusions】
Do NOT include: ${usedPlaceNamesInPull.size > 0 ? Array.from(usedPlaceNamesInPull).join(', ') : 'none'}

Output language: ${outputLang}
Output ONLY valid JSON array, no markdown, no explanation:

[
${uncachedSkeleton.map((item, idx) => `  {
    "place_name": "真實店家名稱",
    "description": "2-3句描述這個地點的特色",
    "category": "${categoryMap[item.category] || item.category}",
    "sub_category": "${item.subCategory}",
    "suggested_time": "${item.suggestedTime}",
    "duration": "1-2 hours",
    "time_slot": "${item.timeSlot}",
    "search_query": "店家名稱 ${city}",
    "color_hex": "#6366f1",
    "energy_level": "${item.energyLevel}"
  }`).join(',\n')}
]`;

        const responseText = await callGemini(prompt);
        let jsonText = responseText || '';
        jsonText = jsonText.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
        aiGeneratedItems = JSON.parse(jsonText);
        
        // 驗證並過濾掉無效的 place_name (搜索詞格式的假名稱)
        const invalidPatterns = [
          /探索$/,  // 以「探索」結尾
          /^.{2,4}(鄉|區|市|鎮|村).{2,6}探索$/,  // 區域名+探索
          /^.{2,4}(鄉|區|市|鎮|村).{2,4}(美食|購物|景點|住宿|體驗)$/,  // 區域名+類別
          /真實店家名稱/,  // 模板佔位符
          /^REAL place/i,  // 英文模板佔位符
        ];
        
        aiGeneratedItems = aiGeneratedItems.map((item: any, idx: number) => {
          const isInvalid = invalidPatterns.some(pattern => pattern.test(item.place_name));
          if (isInvalid) {
            console.log(`[AI Validation] Rejected invalid place_name: "${item.place_name}"`);
            // 使用 sub_category + 區域作為備用，標記為需要人工審核
            return {
              ...item,
              place_name: `[待審核] ${targetDistrict}${item.sub_category}推薦`,
              description: `此地點需要人工確認，AI 無法找到符合條件的真實店家。原始分類：${item.sub_category}`,
              needs_review: true
            };
          }
          return item;
        });
      }

      // Merge cached and AI-generated items
      const districtCenter = await getDistrictBoundary(targetDistrict, city, country);
      const finalInventory: any[] = new Array(skeleton.length);

      // Process cached items (no Google API calls needed - data already in cache)
      for (const { skeletonIdx, cached, skeleton: skelItem } of cachedItems) {
        const cachedLocation = cached.locationLat && cached.locationLng 
          ? { lat: parseFloat(cached.locationLat), lng: parseFloat(cached.locationLng) }
          : null;
        
        const categoryZhMapCached: Record<string, string> = {
          'Food': '美食', 'Stay': '住宿', 'Education': '生態文化教育',
          'Activity': '遊程體驗', 'Entertainment': '娛樂設施', 'Scenery': '景點', 'Shopping': '購物'
        };
        finalInventory[skeletonIdx] = {
          id: Date.now() + skeletonIdx,
          placeName: cached.placeName,
          description: cached.description,
          category: categoryZhMapCached[cached.category] || cached.category,
          subCategory: cached.subCategory,
          suggestedTime: skelItem.suggestedTime,
          duration: cached.duration || '1-2 hours',
          timeSlot: skelItem.timeSlot,
          searchQuery: cached.searchQuery,
          colorHex: cached.colorHex || '#6366f1',
          city: city,
          country: country,
          district: targetDistrict,
          energyLevel: skelItem.energyLevel,
          isCoupon: false,
          couponData: null,
          operatingStatus: 'OPEN',
          placeId: cached.placeId || null,
          verifiedName: cached.verifiedName || cached.placeName,
          verifiedAddress: cached.verifiedAddress || null,
          googleRating: cached.googleRating ? Number(cached.googleRating) : null,
          location: cachedLocation,
          isLocationVerified: cached.isLocationVerified === true,
          districtCenter: districtCenter,
          fromCache: true
        };
      }

      // Process AI-generated items (need Google API verification and cache saving)
      const newCacheEntries: any[] = [];
      
      for (let i = 0; i < uncachedSkeleton.length; i++) {
        const skelItem = uncachedSkeleton[i];
        const aiItem = aiGeneratedItems[i];
        const originalIdx = skelItem.originalIdx;

        const placeResult = await searchPlaceInDistrict(
          aiItem.place_name,
          targetDistrict,
          city,
          country
        );

        let isVerified = false;
        let placeLocation: { lat: number; lng: number } | null = null;

        if (placeResult && placeResult.geometry) {
          placeLocation = placeResult.geometry.location;
          if (districtCenter) {
            isVerified = isWithinRadius(districtCenter, placeLocation, 5);
          } else {
            isVerified = true;
          }
        }

        const categoryZhMap: Record<string, string> = {
          'Food': '美食', 'Stay': '住宿', 'Education': '生態文化教育',
          'Activity': '遊程體驗', 'Entertainment': '娛樂設施', 'Scenery': '景點', 'Shopping': '購物'
        };
        const inventoryItem = {
          id: Date.now() + originalIdx,
          placeName: aiItem.place_name,
          description: aiItem.description,
          category: categoryZhMap[aiItem.category] || aiItem.category,
          subCategory: aiItem.sub_category,
          suggestedTime: skelItem.suggestedTime,
          duration: aiItem.duration || '1-2 hours',
          timeSlot: skelItem.timeSlot,
          searchQuery: aiItem.search_query,
          colorHex: aiItem.color_hex || '#6366f1',
          city: city,
          country: country,
          district: targetDistrict,
          energyLevel: skelItem.energyLevel,
          isCoupon: false,
          couponData: null,
          operatingStatus: 'OPEN',
          placeId: placeResult?.place_id || null,
          verifiedName: placeResult?.name || aiItem.place_name,
          verifiedAddress: placeResult?.formatted_address || null,
          googleRating: placeResult?.rating || null,
          location: placeLocation,
          isLocationVerified: isVerified,
          districtCenter: districtCenter,
          fromCache: false
        };

        finalInventory[originalIdx] = inventoryItem;

        // Prepare cache entry
        newCacheEntries.push({
          subCategory: aiItem.sub_category,
          district: targetDistrict,
          city: city,
          country: country,
          placeName: aiItem.place_name,
          description: aiItem.description,
          category: aiItem.category,
          suggestedTime: skelItem.suggestedTime,
          duration: aiItem.duration || '1-2 hours',
          searchQuery: aiItem.search_query,
          colorHex: aiItem.color_hex || '#6366f1',
          placeId: placeResult?.place_id || null,
          verifiedName: placeResult?.name || null,
          verifiedAddress: placeResult?.formatted_address || null,
          googleRating: placeResult?.rating?.toString() || null,
          locationLat: placeLocation?.lat?.toString() || null,
          locationLng: placeLocation?.lng?.toString() || null,
          isLocationVerified: isVerified
        });
      }

      // Save new entries to drafts (待審核) instead of cache
      if (newCacheEntries.length > 0) {
        try {
          // 映射代碼到資料庫中的實際名稱
          const countryNameMap: Record<string, string> = {
            'taiwan': '台灣',
            'japan': '日本',
            'hong_kong': '香港',
          };
          const cityNameMap: Record<string, string> = {
            'taipei': '台北市',
            'new_taipei': '新北市',
            'taoyuan': '桃園市',
            'taichung': '台中市',
            'tainan': '台南市',
            'kaohsiung': '高雄市',
            'keelung': '基隆市',
            'hsinchu_city': '新竹市',
            'chiayi_city': '嘉義市',
            'tokyo': '東京都',
            'osaka': '大阪市',
            'kyoto': '京都市',
            'fukuoka': '福岡市',
            'hong_kong': '香港',
          };
          const categoryNameMap: Record<string, string> = {
            'Food': '食',
            'Stay': '宿',
            'Education': '生態文化教育',
            'Activity': '遊程體驗',
            'Entertainment': '娛樂設施',
            'Scenery': '景點',
            'Shopping': '購物',
          };

          const draftEntries = newCacheEntries.map(entry => ({
            placeName: entry.placeName,
            description: entry.description,
            category: categoryNameMap[entry.category] || entry.category,
            subCategory: entry.subCategory,
            district: entry.district,
            city: cityNameMap[entry.city] || entry.city,
            country: countryNameMap[entry.country] || entry.country,
            googlePlaceId: entry.placeId,
            googleRating: entry.googleRating ? parseFloat(entry.googleRating) : null,
            locationLat: entry.locationLat,
            locationLng: entry.locationLng,
            address: entry.verifiedAddress,
          }));
          const savedDrafts = await storage.saveAIPlacesToDrafts(draftEntries);
          console.log(`Saved ${savedDrafts.length} new AI places to drafts (pending review)`);
        } catch (draftError) {
          console.error('Failed to save to drafts:', draftError);
        }
      }

      // ===== Merchant Promo Overlay: 檢查商家認領並附加優惠資訊與優惠券機率 =====
      // SECURITY: 只從已驗證的 auth context 取得 userId，不接受 req.body.userId
      // 驗證 session 或 JWT 是否真正已認證
      const reqAny = req as any;
      const isActuallyAuthenticated = !!(
        (reqAny.user?.claims?.sub && reqAny.session?.userId) ||  // Replit Auth with valid session
        (reqAny.jwtUser?.userId && req.headers.authorization)  // Valid JWT token
      );
      const userId = isActuallyAuthenticated 
        ? (reqAny.user?.claims?.sub || reqAny.jwtUser?.userId) 
        : null;
      let couponsWon: any[] = [];
      
      const enrichedInventory = await Promise.all(finalInventory.map(async (item: any) => {
        if (!item) return item;
        
        try {
          // 查找商家是否認領此地點
          const merchantLink = await storage.getMerchantPlaceLinkByPlaceName(
            item.placeName || item.verifiedName,
            item.district || '',
            item.city
          );
          
          if (merchantLink) {
            // 附加商家優惠資訊 overlay
            item.merchantPromo = {
              merchantId: merchantLink.merchantId,
              isPromoActive: merchantLink.isPromoActive || false,
              promoTitle: merchantLink.promoTitle,
              promoDescription: merchantLink.promoDescription,
              promoImageUrl: merchantLink.promoImageUrl
            };
            
            // 如果有登入用戶(已驗證)且背包未滿，進行優惠券抽獎
            if (isActuallyAuthenticated && userId && merchantLink.isPromoActive) {
              const isFull = await storage.isInventoryFull(userId);
              if (!isFull) {
                // 使用機率系統抽取優惠券等級
                const tier = await storage.rollCouponTier();
                
                if (tier) {
                  // 獲取該商家的優惠券模板
                  const merchantCoupons = await storage.getMerchantCouponsByPlaceLink(merchantLink.id);
                  // 根據等級找到匹配的優惠券
                  const matchingCoupon = merchantCoupons.find(c => c.tier === tier) || merchantCoupons[0];
                  
                  if (matchingCoupon) {
                    // 計算有效期限: 使用優惠券的 validUntil 或預設 30 天
                    const validUntil = matchingCoupon.validUntil 
                      ? new Date(matchingCoupon.validUntil)
                      : new Date(Date.now() + 30 * 24 * 60 * 60 * 1000);
                    
                    // 新增到用戶背包
                    const inventoryItem = await storage.addToUserInventory({
                      userId,
                      itemType: 'coupon',
                      itemName: matchingCoupon.name,
                      itemDescription: matchingCoupon.content,
                      tier: tier,
                      merchantId: merchantLink.merchantId,
                      merchantCouponId: matchingCoupon.id,
                      terms: matchingCoupon.terms,
                      content: JSON.stringify({
                        placeName: item.placeName,
                        district: item.district,
                        city: item.city,
                        country: item.country,
                        promoTitle: merchantLink.promoTitle
                      }),
                      validUntil,
                    });
                    
                    if (inventoryItem) {
                      item.isCoupon = true;
                      item.couponData = {
                        inventoryId: inventoryItem.id,
                        tier: tier,
                        name: matchingCoupon.name,
                        description: matchingCoupon.content,
                        validUntil: validUntil.toISOString(),
                        slotIndex: inventoryItem.slotIndex
                      };
                      couponsWon.push({
                        tier,
                        placeName: item.placeName,
                        couponName: matchingCoupon.name
                      });
                    }
                  }
                }
              }
            }
          }
        } catch (promoError) {
          console.error(`Error enriching place ${item.placeName} with promo:`, promoError);
        }
        
        return item;
      }));

      const data = {
        status: 'success',
        meta: {
          date: new Date().toISOString().split('T')[0],
          country: country,
          city: city,
          lockedDistrict: targetDistrict,
          userLevel: level,
          totalItems: skeleton.length,
          verificationEnabled: !!GOOGLE_MAPS_API_KEY,
          cacheHits: cachedItems.length,
          aiGenerated: uncachedSkeleton.length,
          couponsWon: couponsWon.length
        },
        inventory: enrichedInventory,
        couponsWon: couponsWon
      };

      res.json({ data, sources: [] });
    } catch (error) {
      console.error("Gemini generation error:", error);
      res.status(500).json({ error: "Failed to generate itinerary" });
    }
  });

  // ============ Recur Payment Routes ============
  
  app.post("/api/checkout/create-session", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const { customerEmail } = req.body;
      
      const secretKey = process.env.RECUR_SECRET_KEY;
      if (!secretKey) {
        return res.status(500).json({ error: "Payment system not configured" });
      }

      const appUrl = process.env.REPLIT_DEV_DOMAIN 
        ? `https://${process.env.REPLIT_DEV_DOMAIN}`
        : `https://${process.env.REPL_SLUG}.${process.env.REPL_OWNER}.repl.co`;

      const response = await fetch(`${RECUR_API_URL}/checkout/sessions`, {
        method: "POST",
        headers: {
          "Authorization": `Bearer ${secretKey}`,
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          productId: RECUR_PREMIUM_PLAN_ID,
          mode: "SUBSCRIPTION",
          successUrl: `${appUrl}?payment_success=true&session_id={CHECKOUT_SESSION_ID}`,
          cancelUrl: `${appUrl}?payment_cancelled=true`,
          customerEmail: customerEmail || undefined,
          metadata: {
            userId: userId,
            plan: "premium"
          }
        }),
      });

      const data = await response.json();

      if (!response.ok) {
        console.error("Recur API error:", data);
        return res.status(response.status).json({ error: data.error || "Checkout failed" });
      }

      res.json({ url: data.url, sessionId: data.id });
    } catch (error) {
      console.error("Create checkout session error:", error);
      res.status(500).json({ error: "Failed to create checkout session" });
    }
  });

  app.get("/api/checkout/session/:sessionId", isAuthenticated, async (req, res) => {
    try {
      const { sessionId } = req.params;
      const secretKey = process.env.RECUR_SECRET_KEY;
      
      if (!secretKey) {
        return res.status(500).json({ error: "Payment system not configured" });
      }

      const response = await fetch(`${RECUR_API_URL}/checkout/sessions/${sessionId}`, {
        headers: {
          "Authorization": `Bearer ${secretKey}`,
        },
      });

      const session = await response.json();

      if (!response.ok) {
        return res.status(response.status).json({ error: session.error });
      }

      res.json({ session });
    } catch (error) {
      console.error("Fetch checkout session error:", error);
      res.status(500).json({ error: "Failed to fetch session" });
    }
  });

  // Webhook for Recur payment events
  app.post("/api/webhooks/recur", async (req, res) => {
    try {
      const event = req.body;
      console.log("=== Recur Webhook Received ===");
      console.log("Event Type:", event.type);
      console.log("Event Data:", JSON.stringify(event, null, 2));

      switch (event.type) {
        case "checkout.completed": {
          // 結帳完成 - 啟用訂閱
          const checkout = event.data;
          const userId = checkout.metadata?.userId;
          
          if (userId) {
            const merchant = await storage.getMerchantByUserId(userId);
            if (merchant) {
              await storage.updateMerchantPlan(merchant.id, "premium");
              console.log(`[checkout.completed] Upgraded merchant ${merchant.id} to premium`);
            }
          }
          break;
        }

        case "subscription.created": {
          // 訂閱建立
          const subscription = event.data;
          const userId = subscription.metadata?.userId;
          console.log(`[subscription.created] Subscription ${subscription.id} created for user ${userId}`);
          
          if (userId && subscription.status === "active") {
            const merchant = await storage.getMerchantByUserId(userId);
            if (merchant) {
              await storage.updateMerchantPlan(merchant.id, "premium");
              console.log(`[subscription.created] Activated premium for merchant ${merchant.id}`);
            }
          }
          break;
        }

        case "subscription.updated": {
          // 訂閱更新
          const subscription = event.data;
          const userId = subscription.metadata?.userId;
          console.log(`[subscription.updated] Subscription ${subscription.id} updated, status: ${subscription.status}`);
          
          if (userId) {
            const merchant = await storage.getMerchantByUserId(userId);
            if (merchant) {
              if (subscription.status === "active") {
                await storage.updateMerchantPlan(merchant.id, "premium");
                console.log(`[subscription.updated] Merchant ${merchant.id} plan set to premium`);
              } else if (subscription.status === "canceled" || subscription.status === "expired") {
                await storage.updateMerchantPlan(merchant.id, "free");
                console.log(`[subscription.updated] Merchant ${merchant.id} plan downgraded to free`);
              }
            }
          }
          break;
        }

        case "subscription.canceled": {
          // 訂閱取消
          const subscription = event.data;
          const userId = subscription.metadata?.userId;
          console.log(`[subscription.canceled] Subscription ${subscription.id} canceled for user ${userId}`);
          
          if (userId) {
            const merchant = await storage.getMerchantByUserId(userId);
            if (merchant) {
              await storage.updateMerchantPlan(merchant.id, "free");
              console.log(`[subscription.canceled] Downgraded merchant ${merchant.id} to free`);
            }
          }
          break;
        }

        case "invoice.paid": {
          // 發票付款成功 - 續訂成功
          const invoice = event.data;
          console.log(`[invoice.paid] Invoice ${invoice.id} paid`);
          break;
        }

        case "invoice.payment_failed": {
          // 發票付款失敗
          const invoice = event.data;
          console.log(`[invoice.payment_failed] Invoice ${invoice.id} payment failed`);
          break;
        }

        default:
          console.log(`[webhook] Unhandled event type: ${event.type}`);
      }

      res.json({ received: true });
    } catch (error) {
      console.error("Webhook error:", error);
      res.status(500).json({ error: "Webhook processing failed" });
    }
  });

  // Endpoint to get the webhook URL (for configuration reference)
  app.get("/api/webhooks/recur/info", (req, res) => {
    const domain = process.env.REPLIT_DEV_DOMAIN || `${process.env.REPL_SLUG}.${process.env.REPL_OWNER}.repl.co`;
    const webhookUrl = `https://${domain}/api/webhooks/recur`;
    res.json({ 
      webhookUrl,
      supportedEvents: [
        "checkout.completed",
        "subscription.created", 
        "subscription.updated",
        "subscription.canceled",
        "invoice.paid",
        "invoice.payment_failed"
      ]
    });
  });

  // ============ Location Hierarchy Routes ============

  app.get("/api/locations/countries", async (req, res) => {
    try {
      const countriesList = await storage.getCountries();
      res.json({ countries: countriesList });
    } catch (error) {
      console.error("Error fetching countries:", error);
      res.status(500).json({ error: "Failed to fetch countries" });
    }
  });

  app.get("/api/locations/regions/:countryId", async (req, res) => {
    try {
      const countryId = parseInt(req.params.countryId);
      const regionsList = await storage.getRegionsByCountry(countryId);
      res.json({ regions: regionsList });
    } catch (error) {
      console.error("Error fetching regions:", error);
      res.status(500).json({ error: "Failed to fetch regions" });
    }
  });

  app.get("/api/locations/districts/:regionId", async (req, res) => {
    try {
      const regionId = parseInt(req.params.regionId);
      const districtsList = await storage.getDistrictsByRegion(regionId);
      res.json({ districts: districtsList });
    } catch (error) {
      console.error("Error fetching districts:", error);
      res.status(500).json({ error: "Failed to fetch districts" });
    }
  });

  app.get("/api/locations/districts/country/:countryId", async (req, res) => {
    try {
      const countryId = parseInt(req.params.countryId);
      const districtsList = await storage.getDistrictsByCountry(countryId);
      res.json({ districts: districtsList, count: districtsList.length });
    } catch (error) {
      console.error("Error fetching districts by country:", error);
      res.status(500).json({ error: "Failed to fetch districts" });
    }
  });

  // ============ Category Routes ============

  app.get("/api/categories", async (req, res) => {
    try {
      const categoriesList = await storage.getCategories();
      res.json({ categories: categoriesList });
    } catch (error) {
      console.error("Error fetching categories:", error);
      res.status(500).json({ error: "Failed to fetch categories" });
    }
  });

  app.get("/api/categories/:categoryId/subcategories", async (req, res) => {
    try {
      const categoryId = parseInt(req.params.categoryId);
      const subcategoriesList = await storage.getSubcategoriesByCategory(categoryId);
      res.json({ subcategories: subcategoriesList });
    } catch (error) {
      console.error("Error fetching subcategories:", error);
      res.status(500).json({ error: "Failed to fetch subcategories" });
    }
  });

  // ============ Gacha Pull Route ============

  // Helper function to generate a single place for a subcategory in a specific district
  async function generatePlaceForSubcategory(
    districtNameZh: string,
    regionNameZh: string,
    countryNameZh: string,
    category: any,
    subcategory: any,
    language: string,
    excludePlaceNames: string[] = []
  ): Promise<{
    category: any;
    subcategory: any;
    place: any;
    source: 'cache' | 'ai';
    isVerified: boolean;
  } | null> {
    const subcategoryNameZh = subcategory.nameZh;
    const categoryNameZh = category.nameZh;

    // Check cache first
    const cachedPlace = await storage.getCachedPlace(
      subcategoryNameZh,
      districtNameZh,
      regionNameZh,
      countryNameZh
    );

    // Only use cache if the place is not in the exclusion list
    if (cachedPlace && !excludePlaceNames.includes(cachedPlace.placeName)) {
      return {
        category,
        subcategory,
        place: {
          name: cachedPlace.placeName,
          description: cachedPlace.description,
          address: cachedPlace.verifiedAddress,
          placeId: cachedPlace.placeId,
          rating: cachedPlace.googleRating,
          googleTypes: cachedPlace.googleTypes?.split(',').filter(Boolean) || [],
          primaryType: cachedPlace.primaryType || null,
          location: cachedPlace.locationLat && cachedPlace.locationLng ? {
            lat: parseFloat(cachedPlace.locationLat),
            lng: parseFloat(cachedPlace.locationLng)
          } : null
        },
        source: 'cache',
        isVerified: cachedPlace.isLocationVerified || false
      };
    }

    // Generate with AI and verify
    const MAX_RETRIES = 2;
    let attempts = 0;
    let failedAttempts: string[] = [];

    while (attempts < MAX_RETRIES) {
      attempts++;
      
      // Combine failed attempts with already used places
      const allExclusions = [...excludePlaceNames, ...failedAttempts];
      
      const aiResult = await generatePlaceWithAI(
        districtNameZh,
        regionNameZh,
        countryNameZh,
        subcategoryNameZh,
        categoryNameZh,
        allExclusions
      );

      if (aiResult) {
        const verification = await verifyPlaceWithGoogle(
          aiResult.placeName,
          districtNameZh,
          regionNameZh
        );

        if (verification.verified) {
          // Save to cache
          const cacheEntry = await storage.savePlaceToCache({
            subCategory: subcategoryNameZh,
            district: districtNameZh,
            city: regionNameZh,
            country: countryNameZh,
            placeName: verification.verifiedName || aiResult.placeName,
            description: aiResult.description,
            category: categoryNameZh,
            searchQuery: `${subcategoryNameZh} ${districtNameZh} ${regionNameZh}`,
            placeId: verification.placeId || null,
            verifiedName: verification.verifiedName || null,
            verifiedAddress: verification.verifiedAddress || null,
            googleRating: verification.rating?.toString() || null,
            googleTypes: verification.googleTypes?.join(',') || null,
            primaryType: verification.primaryType || null,
            locationLat: verification.location?.lat?.toString() || null,
            locationLng: verification.location?.lng?.toString() || null,
            isLocationVerified: true
          });

          console.log(`[${categoryNameZh}] Verified: ${aiResult.placeName}`);
          return {
            category,
            subcategory,
            place: {
              name: cacheEntry.placeName,
              description: cacheEntry.description,
              address: cacheEntry.verifiedAddress,
              placeId: cacheEntry.placeId,
              rating: cacheEntry.googleRating,
              googleTypes: cacheEntry.googleTypes?.split(',').filter(Boolean) || [],
              primaryType: cacheEntry.primaryType || null,
              location: cacheEntry.locationLat && cacheEntry.locationLng ? {
                lat: parseFloat(cacheEntry.locationLat),
                lng: parseFloat(cacheEntry.locationLng)
              } : null
            },
            source: 'ai',
            isVerified: true
          };
        } else {
          failedAttempts.push(aiResult.placeName);
        }
      }
    }

    // Return a placeholder if no verified place found
    return {
      category,
      subcategory,
      place: {
        name: `${districtNameZh}${categoryNameZh}探索`,
        description: `探索${regionNameZh}${districtNameZh}的${subcategoryNameZh}特色。`,
        address: null,
        placeId: null,
        rating: null,
        location: null,
        warning: `該區域目前較少此類型店家`
      },
      source: 'ai',
      isVerified: false
    };
  }

  // New endpoint: Generate a complete itinerary using parallel time-slot AI architecture
  app.post("/api/gacha/itinerary", async (req, res) => {
    try {
      const { countryId, regionId, language = 'zh-TW', itemCount = 8 } = req.body;

      if (!countryId) {
        return res.status(400).json({ error: "countryId is required" });
      }

      // Step 1: Random district selection
      let district;
      if (regionId) {
        district = await storage.getRandomDistrictByRegion(regionId);
      } else {
        district = await storage.getRandomDistrictByCountry(countryId);
      }
      if (!district) {
        return res.status(404).json({ error: "No districts found" });
      }

      const districtWithParents = await storage.getDistrictWithParents(district.id);
      if (!districtWithParents) {
        return res.status(500).json({ error: "Failed to get district info" });
      }

      const getLocalizedName = (item: any, lang: string): string => {
        switch (lang) {
          case 'ja': return item.nameJa || item.nameZh || item.nameEn;
          case 'ko': return item.nameKo || item.nameZh || item.nameEn;
          case 'en': return item.nameEn;
          default: return item.nameZh || item.nameEn;
        }
      };

      const districtNameZh = districtWithParents.district.nameZh;
      const regionNameZh = districtWithParents.region.nameZh;
      const countryNameZh = districtWithParents.country.nameZh;

      // Step 2: Get all subcategories with their parent categories
      const allSubcategories = await storage.getAllSubcategoriesWithCategory();
      if (!allSubcategories || allSubcategories.length === 0) {
        return res.status(404).json({ error: "No subcategories found" });
      }

      // Step 3: Define AI worker distribution based on itemCount
      // Each AI has specific responsibilities per time slot
      type AIWorker = 'ai1_morning' | 'ai2_afternoon' | 'ai3_evening' | 'ai4_night';
      
      interface AITask {
        worker: AIWorker;
        tasks: { type: 'breakfast' | 'lunch' | 'dinner' | 'activity' | 'stay'; count: number }[];
      }
      
      const getAIDistribution = (count: number): AITask[] => {
        switch (count) {
          case 5: return [
            { worker: 'ai1_morning', tasks: [{ type: 'breakfast', count: 1 }, { type: 'activity', count: 1 }] }, // 早餐 + 1項早上活動
            { worker: 'ai2_afternoon', tasks: [{ type: 'lunch', count: 1 }, { type: 'activity', count: 2 }] }  // 午餐 + 2項下午活動
          ];
          case 6: return [
            { worker: 'ai1_morning', tasks: [{ type: 'breakfast', count: 1 }, { type: 'activity', count: 2 }] }, // 早餐 + 2項早上活動
            { worker: 'ai2_afternoon', tasks: [{ type: 'lunch', count: 1 }, { type: 'activity', count: 2 }] }  // 午餐 + 2項下午活動
          ];
          case 7: return [
            { worker: 'ai1_morning', tasks: [{ type: 'breakfast', count: 1 }, { type: 'activity', count: 2 }] },
            { worker: 'ai2_afternoon', tasks: [{ type: 'lunch', count: 1 }, { type: 'activity', count: 2 }] },
            { worker: 'ai3_evening', tasks: [{ type: 'dinner', count: 1 }] }
          ];
          case 8: return [
            { worker: 'ai1_morning', tasks: [{ type: 'breakfast', count: 1 }, { type: 'activity', count: 2 }] },
            { worker: 'ai2_afternoon', tasks: [{ type: 'lunch', count: 1 }, { type: 'activity', count: 2 }] },
            { worker: 'ai3_evening', tasks: [{ type: 'dinner', count: 1 }, { type: 'activity', count: 1 }] }
          ];
          case 9: return [
            { worker: 'ai1_morning', tasks: [{ type: 'breakfast', count: 1 }, { type: 'activity', count: 2 }] },
            { worker: 'ai2_afternoon', tasks: [{ type: 'lunch', count: 1 }, { type: 'activity', count: 2 }] },
            { worker: 'ai3_evening', tasks: [{ type: 'dinner', count: 1 }, { type: 'activity', count: 2 }] }
          ];
          case 10: return [
            { worker: 'ai1_morning', tasks: [{ type: 'breakfast', count: 1 }, { type: 'activity', count: 2 }] },
            { worker: 'ai2_afternoon', tasks: [{ type: 'lunch', count: 1 }, { type: 'activity', count: 2 }] },
            { worker: 'ai3_evening', tasks: [{ type: 'dinner', count: 1 }, { type: 'activity', count: 2 }] },
            { worker: 'ai4_night', tasks: [{ type: 'stay', count: 1 }] }
          ];
          case 11: return [
            { worker: 'ai1_morning', tasks: [{ type: 'breakfast', count: 1 }, { type: 'activity', count: 2 }] },
            { worker: 'ai2_afternoon', tasks: [{ type: 'lunch', count: 1 }, { type: 'activity', count: 2 }] },
            { worker: 'ai3_evening', tasks: [{ type: 'dinner', count: 1 }, { type: 'activity', count: 2 }] },
            { worker: 'ai4_night', tasks: [{ type: 'stay', count: 1 }, { type: 'activity', count: 1 }] }
          ];
          case 12: return [
            { worker: 'ai1_morning', tasks: [{ type: 'breakfast', count: 1 }, { type: 'activity', count: 2 }] },
            { worker: 'ai2_afternoon', tasks: [{ type: 'lunch', count: 1 }, { type: 'activity', count: 2 }] },
            { worker: 'ai3_evening', tasks: [{ type: 'dinner', count: 1 }, { type: 'activity', count: 2 }] },
            { worker: 'ai4_night', tasks: [{ type: 'stay', count: 1 }, { type: 'activity', count: 2 }] }
          ];
          default: return [
            { worker: 'ai1_morning', tasks: [{ type: 'breakfast', count: 1 }, { type: 'activity', count: 2 }] },
            { worker: 'ai2_afternoon', tasks: [{ type: 'lunch', count: 1 }, { type: 'activity', count: 2 }] }
          ];
        }
      };

      const aiDistribution = getAIDistribution(itemCount);
      
      console.log(`\n=== Generating itinerary for ${regionNameZh}${districtNameZh} (${itemCount} items, ${aiDistribution.length} AI workers) ===`);
      console.log(`AI Distribution:`, aiDistribution.map(a => `${a.worker}: ${a.tasks.map(t => `${t.type}×${t.count}`).join('+')}`).join(' | '));

      // === HARDCODED PROBABILITY CONSTANTS ===
      const CACHE_USE_PROBABILITY = 0.25; // 25% chance to use cache
      const COLLECTED_REDUCTION_PROBABILITY = 0.40; // 40% reduction for collected items
      
      // Step 4: Select subcategory using 1/N category probability (excluding food/stay for activities), then 1/N subcategory probability
      // with time-appropriate filtering to avoid awkward combinations
      const selectSubcategoryForTask = (worker: AIWorker, taskType: string): typeof allSubcategories[0] | null => {
        // Define excluded categories/subcategories per worker to avoid awkward combinations
        const excludedByWorker: Record<AIWorker, { categories: string[]; subcategories: string[] }> = {
          'ai1_morning': { 
            categories: [], 
            subcategories: ['酒吧', 'KTV', '夜市'] // No nightlife in morning
          },
          'ai2_afternoon': { 
            categories: [], 
            subcategories: ['早午餐'] // No breakfast in afternoon
          },
          'ai3_evening': { 
            categories: [], 
            subcategories: ['早午餐', '咖啡廳'] // No breakfast/cafe at dinner
          },
          'ai4_night': { 
            categories: [], 
            subcategories: ['早午餐', '咖啡廳'] // No breakfast at night
          }
        };

        // For specific task types, filter directly
        if (taskType === 'breakfast') {
          // Prefer breakfast-appropriate food: 早午餐, 咖啡廳, 在地早餐
          const breakfastSubcats = allSubcategories.filter(s => 
            s.category.code === 'food' && 
            (s.nameZh.includes('早') || s.nameZh.includes('咖啡') || s.nameZh.includes('甜點'))
          );
          // Fallback to any food if no breakfast-specific found
          const fallback = allSubcategories.filter(s => s.category.code === 'food');
          const options = breakfastSubcats.length > 0 ? breakfastSubcats : fallback;
          return options.length > 0 ? options[Math.floor(Math.random() * options.length)] : null;
        } else if (taskType === 'lunch') {
          // Any food subcategory for lunch, excluding late-night options
          const lunchSubcats = allSubcategories.filter(s => 
            s.category.code === 'food' && 
            !s.nameZh.includes('宵夜') && !s.nameZh.includes('酒')
          );
          const fallback = allSubcategories.filter(s => s.category.code === 'food');
          const options = lunchSubcats.length > 0 ? lunchSubcats : fallback;
          return options.length > 0 ? options[Math.floor(Math.random() * options.length)] : null;
        } else if (taskType === 'dinner') {
          // Any food subcategory for dinner
          const dinnerSubcats = allSubcategories.filter(s => 
            s.category.code === 'food' && !s.nameZh.includes('早')
          );
          const fallback = allSubcategories.filter(s => s.category.code === 'food');
          const options = dinnerSubcats.length > 0 ? dinnerSubcats : fallback;
          return options.length > 0 ? options[Math.floor(Math.random() * options.length)] : null;
        } else if (taskType === 'stay') {
          const staySubcats = allSubcategories.filter(s => s.category.code === 'stay');
          return staySubcats.length > 0 ? staySubcats[Math.floor(Math.random() * staySubcats.length)] : null;
        }
        
        // For 'activity' task type: use 1/N category probability (excluding food/stay = 6 categories), then 1/N subcategory probability
        // Step A: Get all 8 categories (excluding food and stay for activities)
        const allCategorySet = new Set<string>();
        allSubcategories.forEach(s => allCategorySet.add(s.category.code));
        const allCategories = Array.from(allCategorySet);
        const activityCategories = allCategories.filter(code => 
          code !== 'food' && code !== 'stay'
        );
        
        if (activityCategories.length === 0) return null;
        
        // Step B: Apply worker-specific exclusions
        const exclusions = excludedByWorker[worker];
        const validCategories = activityCategories.filter(code => !exclusions.categories.includes(code));
        
        if (validCategories.length === 0) return null;
        
        // Step C: Pick random category with 1/N probability (equal chance)
        const selectedCategoryCode = validCategories[Math.floor(Math.random() * validCategories.length)];
        
        // Step D: Get subcategories for this category, excluding awkward ones
        const categorySubcats = allSubcategories.filter(s => 
          s.category.code === selectedCategoryCode &&
          !exclusions.subcategories.includes(s.nameZh) &&
          s.preferredTimeSlot !== 'stay'
        );
        
        if (categorySubcats.length === 0) return null;
        
        // Step E: Pick random subcategory with 1/N probability (equal chance)
        return categorySubcats[Math.floor(Math.random() * categorySubcats.length)];
      };

      const startTime = Date.now();
      let cacheHits = 0;
      let aiGenerated = 0;

      // Helper to build item with merchant promo
      const buildItemWithPromo = async (result: any) => {
        let merchantPromo = null;
        let merchantLink = null;
        
        if (result.place?.place_id) {
          merchantLink = await storage.getPlaceLinkByGooglePlaceId(result.place.place_id);
        }
        if (!merchantLink && result.place?.name) {
          merchantLink = await storage.getPlaceLinkByPlace(result.place.name, districtNameZh, regionNameZh);
        }
        
        if (merchantLink && merchantLink.isPromoActive && merchantLink.promoTitle) {
          merchantPromo = {
            merchantId: merchantLink.merchantId,
            title: merchantLink.promoTitle,
            description: merchantLink.promoDescription,
            imageUrl: merchantLink.promoImageUrl
          };
        }

        return {
          category: {
            id: result.category.id,
            code: result.category.code,
            name: getLocalizedName(result.category, language),
            colorHex: result.category.colorHex
          },
          subcategory: {
            id: result.subcategory.id,
            code: result.subcategory.code,
            name: getLocalizedName(result.subcategory, language)
          },
          place: result.place,
          isVerified: result.isVerified,
          source: result.source,
          is_promo_active: !!merchantPromo,
          store_promo: merchantPromo?.title || null,
          merchant_promo: merchantPromo
        };
      };

      // Step 5: Preload cache for this district
      const cachedPlacesForDistrict = await storage.getCachedPlaces(
        districtNameZh,
        regionNameZh,
        countryNameZh
      );
      const cacheBySubcategory = new Map<string, typeof cachedPlacesForDistrict[0]>();
      for (const cached of cachedPlacesForDistrict) {
        if (!cacheBySubcategory.has(cached.subCategory)) {
          cacheBySubcategory.set(cached.subCategory, cached);
        }
      }

      // Step 6: Get user's collected place names for probability reduction
      const userId = (req as any).user?.id;
      let collectedPlaceNames: Set<string> = new Set();
      if (userId) {
        try {
          const userCollections = await storage.getUserCollections(userId);
          for (const collection of userCollections) {
            if (collection.placeName) {
              collectedPlaceNames.add(collection.placeName);
            }
          }
        } catch (e) {
          console.log("Could not fetch user collections for probability adjustment");
        }
      }
      
      // Step 7: Execute each AI worker in TRUE PARALLEL
      // Each worker handles its assigned tasks (breakfast/lunch/dinner/activity/stay)
      // Tasks within each worker also run in parallel for maximum speed
      const executeAIWorker = async (aiTask: AITask): Promise<any[]> => {
        const usedSubcatIds = new Set<number>();
        
        // Phase 1: Pre-select all subcategories for this worker (synchronous)
        interface TaskItem {
          taskType: string;
          selectedSubcat: typeof allSubcategories[0];
          cached: typeof cachedPlacesForDistrict[0] | null;
          shouldUseCache: boolean;
        }
        const taskItems: TaskItem[] = [];
        
        for (const task of aiTask.tasks) {
          for (let i = 0; i < task.count; i++) {
            let selectedSubcat = selectSubcategoryForTask(aiTask.worker, task.type);
            
            let retries = 0;
            while (selectedSubcat && usedSubcatIds.has(selectedSubcat.id) && retries < 3) {
              selectedSubcat = selectSubcategoryForTask(aiTask.worker, task.type);
              retries++;
            }
            
            if (!selectedSubcat || usedSubcatIds.has(selectedSubcat.id)) continue;
            usedSubcatIds.add(selectedSubcat.id);
            
            const shouldUseCache = Math.random() < CACHE_USE_PROBABILITY;
            const cached = cacheBySubcategory.get(selectedSubcat.nameZh) || null;
            
            taskItems.push({
              taskType: task.type,
              selectedSubcat,
              cached,
              shouldUseCache
            });
          }
        }
        
        console.log(`[${aiTask.worker}] Processing ${taskItems.length} tasks in parallel`);
        
        // Phase 2: Execute all tasks in parallel
        const taskPromises = taskItems.map(async (taskItem) => {
          const { taskType, selectedSubcat, cached, shouldUseCache } = taskItem;
          
          // Try cache first
          if (shouldUseCache && cached && cached.placeName) {
            if (collectedPlaceNames.has(cached.placeName)) {
              if (Math.random() < COLLECTED_REDUCTION_PROBABILITY) {
                console.log(`[${aiTask.worker}] Skipping collected: ${cached.placeName}`);
              } else {
                const item = await buildItemWithPromo({
                  category: selectedSubcat.category,
                  subcategory: selectedSubcat,
                  place: {
                    name: cached.placeName,
                    description: cached.description,
                    place_id: cached.placeId,
                    verified_name: cached.verifiedName,
                    verified_address: cached.verifiedAddress,
                    google_rating: cached.googleRating,
                    lat: cached.locationLat,
                    lng: cached.locationLng,
                    google_types: cached.googleTypes,
                    primary_type: cached.primaryType
                  },
                  isVerified: cached.isLocationVerified,
                  source: 'cache'
                });
                return { ...item, aiWorker: aiTask.worker, taskType };
              }
            } else {
              const item = await buildItemWithPromo({
                category: selectedSubcat.category,
                subcategory: selectedSubcat,
                place: {
                  name: cached.placeName,
                  description: cached.description,
                  place_id: cached.placeId,
                  verified_name: cached.verifiedName,
                  verified_address: cached.verifiedAddress,
                  google_rating: cached.googleRating,
                  lat: cached.locationLat,
                  lng: cached.locationLng,
                  google_types: cached.googleTypes,
                  primary_type: cached.primaryType
                },
                isVerified: cached.isLocationVerified,
                source: 'cache'
              });
              return { ...item, aiWorker: aiTask.worker, taskType };
            }
          }
          
          // Generate with AI (runs in parallel with other tasks)
          const result = await generatePlaceForSubcategory(
            districtNameZh, regionNameZh, countryNameZh,
            selectedSubcat.category, selectedSubcat, language,
            []
          );

          if (result && result.place?.name) {
            // Skip if AI returned "no match found" type response
            const desc = result.place.description || '';
            if (desc.includes('無符合條件') || desc.includes('目前無符合') || desc.includes('沒有符合')) {
              console.log(`[${aiTask.worker}] Skipping no-match result: ${result.place.name}`);
              return null;
            }
            
            if (collectedPlaceNames.has(result.place.name)) {
              if (Math.random() < COLLECTED_REDUCTION_PROBABILITY) {
                console.log(`[${aiTask.worker}] Skipping collected AI: ${result.place.name}`);
                return null;
              }
            }
            
            const item = await buildItemWithPromo(result);
            return { ...item, aiWorker: aiTask.worker, taskType };
          }
          
          return null;
        });
        
        // Wait for all tasks to complete in parallel
        const results = await Promise.all(taskPromises);
        
        // Normalize place names by removing common suffixes/variations
        // Returns original trimmed name if normalization results in empty string
        const normalizePlaceName = (name: string): string => {
          if (!name) return '';
          const trimmed = name.trim();
          const normalized = trimmed
            .replace(/[（(][^）)]*[）)]/g, '') // Remove content in parentheses
            .replace(/旅遊服務園區|生態園區|園區|服務中心|遊客中心|觀光工廠|休閒農場/g, '')
            .replace(/\s+/g, '')
            .trim();
          // Fall back to original if normalization removes everything
          return normalized || trimmed;
        };
        
        // Filter out null results AND deduplicate by Google Place ID (or normalized name as fallback)
        const seenPlaceIds = new Set<string>();
        return results.filter((item): item is NonNullable<typeof item> => {
          if (item === null) return false;
          const placeId = item.place?.place_id || item.place?.placeId;
          const placeName = item.place?.name;
          const normalizedName = normalizePlaceName(placeName || '');
          // Use Place ID as primary dedup key, fall back to normalized name
          const dedupKey = placeId || normalizedName;
          if (!dedupKey || seenPlaceIds.has(dedupKey)) {
            console.log(`[Dedup] Skipping duplicate: ${placeName} (key: ${dedupKey})`);
            return false;
          }
          seenPlaceIds.add(dedupKey);
          return true;
        });
      };

      // Run ALL AI workers in TRUE PARALLEL (not sequential!)
      console.log(`\n=== Starting ${aiDistribution.length} AI workers in PARALLEL ===`);
      const parallelStartTime = Date.now();
      
      const workerPromises = aiDistribution.map(aiTask => {
        const workerStart = Date.now();
        return executeAIWorker(aiTask).then(result => {
          console.log(`[${aiTask.worker}] Completed in ${Date.now() - workerStart}ms (${result.length} items)`);
          return result;
        });
      });
      
      const workerResults = await Promise.all(workerPromises);
      console.log(`=== All workers completed in ${Date.now() - parallelStartTime}ms (parallel execution) ===\n`);

      // Normalize place names by removing common suffixes/variations
      // Returns original trimmed name if normalization results in empty string
      const normalizePlaceName = (name: string): string => {
        if (!name) return '';
        const trimmed = name.trim();
        const normalized = trimmed
          .replace(/[（(][^）)]*[）)]/g, '') // Remove content in parentheses
          .replace(/旅遊服務園區|生態園區|園區|服務中心|遊客中心|觀光工廠|休閒農場/g, '')
          .replace(/\s+/g, '')
          .trim();
        // Fall back to original if normalization removes everything
        return normalized || trimmed;
      };
      
      // Merge results in order: ai1_morning -> ai2_afternoon -> ai3_evening -> ai4_night
      // Use Google Place ID for deduplication to avoid same location with different names
      const items: any[] = [];
      const globalSeenPlaceIds = new Set<string>();
      
      for (const workerItems of workerResults) {
        for (const item of workerItems) {
          const placeId = item.place?.place_id || item.place?.placeId;
          const placeName = item.place?.name;
          const normalizedName = normalizePlaceName(placeName || '');
          const dedupKey = placeId || normalizedName;
          
          if (dedupKey && !globalSeenPlaceIds.has(dedupKey)) {
            globalSeenPlaceIds.add(dedupKey);
            items.push(item);
            if (item.source === 'cache') cacheHits++;
            else aiGenerated++;
          } else {
            console.log(`[Global Dedup] Skipping: ${placeName} (key: ${dedupKey})`);
          }
        }
      }

      // === BACKFILL PHASE: Try to fill missing slots ===
      let shortageWarning: string | null = null;
      const usedSubcatIds = new Set<number>(items.map(i => i.subcategory?.id).filter(Boolean));
      
      if (items.length < itemCount) {
        const missing = itemCount - items.length;
        console.log(`\n=== BACKFILL: Need ${missing} more items ===`);
        
        let backfillAttempts = 0;
        const maxBackfillAttempts = missing * 3;
        
        // Clone and shuffle to avoid mutating original array
        const availableSubcats = allSubcategories
          .filter(s => !usedSubcatIds.has(s.id))
          .slice()
          .sort(() => Math.random() - 0.5);
        
        for (const subcat of availableSubcats) {
          if (items.length >= itemCount || backfillAttempts >= maxBackfillAttempts) break;
          backfillAttempts++;
          
          console.log(`[Backfill] Trying: ${subcat.category?.nameZh} - ${subcat.nameZh}`);
          const result = await generatePlaceForSubcategory(
            districtNameZh, regionNameZh, countryNameZh,
            subcat.category, subcat, language, []
          );
          
          if (result && result.place?.name) {
            // Skip if AI returned "no match found" type response
            const desc = result.place.description || '';
            if (desc.includes('無符合條件') || desc.includes('目前無符合') || desc.includes('沒有符合')) {
              console.log(`[Backfill] Skipping no-match result: ${result.place.name}`);
              continue;
            }
            
            const placeId = result.place.place_id || result.place.placeId;
            const normalizedName = normalizePlaceName(result.place.name);
            const dedupKey = placeId || normalizedName;
            if (!globalSeenPlaceIds.has(dedupKey)) {
              globalSeenPlaceIds.add(dedupKey);
              usedSubcatIds.add(subcat.id);
              const item = await buildItemWithPromo(result);
              items.push({ ...item, aiWorker: 'backfill', taskType: 'backfill' });
              aiGenerated++;
              console.log(`[Backfill] Added: ${result.place.name}`);
            }
          }
        }
      }
      
      // Always set warning when below target
      if (items.length < itemCount) {
        shortageWarning = language === 'zh-TW' 
          ? `此區域的觀光資源有限，僅找到 ${items.length} 個地點`
          : language === 'ja'
          ? `このエリアでは ${items.length} 件のスポットのみ見つかりました`
          : language === 'ko'
          ? `이 지역에서 ${items.length}개의 장소만 찾았습니다`
          : `Only ${items.length} spots found in this area`;
        console.log(`[Shortage] Warning: ${shortageWarning}`);
      }

      const duration = Date.now() - startTime;
      console.log(`Generated ${items.length}/${itemCount} items in ${duration}ms (cache: ${cacheHits}, AI: ${aiGenerated}, workers: ${aiDistribution.length})`);

      // Return the complete itinerary
      res.json({
        success: true,
        itinerary: {
          location: {
            district: {
              id: district.id,
              code: district.code,
              name: getLocalizedName(districtWithParents.district, language),
              nameZh: districtNameZh
            },
            region: {
              id: districtWithParents.region.id,
              code: districtWithParents.region.code,
              name: getLocalizedName(districtWithParents.region, language),
              nameZh: regionNameZh
            },
            country: {
              id: districtWithParents.country.id,
              code: districtWithParents.country.code,
              name: getLocalizedName(districtWithParents.country, language)
            }
          },
          items,
          meta: {
            totalItems: items.length,
            requestedItems: itemCount,
            cacheHits,
            aiGenerated,
            verifiedCount: items.filter(i => i.isVerified).length,
            shortageWarning
          }
        }
      });
    } catch (error) {
      console.error("Itinerary generation error:", error);
      res.status(500).json({ error: "Failed to generate itinerary" });
    }
  });

  // Keep original single pull endpoint for backward compatibility
  app.post("/api/gacha/pull", async (req, res) => {
    try {
      const { countryId, regionId, language = 'zh-TW' } = req.body;

      if (!countryId) {
        return res.status(400).json({ error: "countryId is required" });
      }

      // Step 1: Random district selection
      let district;
      if (regionId) {
        district = await storage.getRandomDistrictByRegion(regionId);
      } else {
        district = await storage.getRandomDistrictByCountry(countryId);
      }
      if (!district) {
        return res.status(404).json({ error: "No districts found" });
      }

      const districtWithParents = await storage.getDistrictWithParents(district.id);
      if (!districtWithParents) {
        return res.status(500).json({ error: "Failed to get district info" });
      }

      // Step 2: Random category and subcategory selection
      const category = await storage.getRandomCategory();
      if (!category) {
        return res.status(404).json({ error: "No categories found" });
      }
      
      const subcategory = await storage.getRandomSubcategoryByCategory(category.id);
      if (!subcategory) {
        return res.status(404).json({ error: "No subcategories found" });
      }

      // Get names for response
      const getLocalizedName = (item: any, lang: string): string => {
        switch (lang) {
          case 'ja': return item.nameJa || item.nameZh || item.nameEn;
          case 'ko': return item.nameKo || item.nameZh || item.nameEn;
          case 'en': return item.nameEn;
          default: return item.nameZh || item.nameEn;
        }
      };

      const districtNameZh = districtWithParents.district.nameZh;
      const regionNameZh = districtWithParents.region.nameZh;
      const countryNameZh = districtWithParents.country.nameZh;

      // Generate place for this subcategory
      const result = await generatePlaceForSubcategory(
        districtNameZh,
        regionNameZh,
        countryNameZh,
        category,
        subcategory,
        language
      );

      if (!result) {
        return res.status(500).json({ error: "Failed to generate place" });
      }

      // Return the gacha result
      res.json({
        success: true,
        pull: {
          location: {
            district: {
              id: district.id,
              code: district.code,
              name: getLocalizedName(districtWithParents.district, language),
              nameZh: districtNameZh
            },
            region: {
              id: districtWithParents.region.id,
              code: districtWithParents.region.code,
              name: getLocalizedName(districtWithParents.region, language),
              nameZh: regionNameZh
            },
            country: {
              id: districtWithParents.country.id,
              code: districtWithParents.country.code,
              name: getLocalizedName(districtWithParents.country, language)
            }
          },
          category: {
            id: result.category.id,
            code: result.category.code,
            name: getLocalizedName(result.category, language),
            colorHex: result.category.colorHex
          },
          subcategory: {
            id: result.subcategory.id,
            code: result.subcategory.code,
            name: getLocalizedName(result.subcategory, language)
          },
          place: result.place,
          meta: {
            source: result.source,
            isVerified: result.isVerified
          }
        }
      });
    } catch (error) {
      console.error("Gacha pull error:", error);
      res.status(500).json({ error: "Failed to perform gacha pull" });
    }
  });

  // ============ Gacha V2 - Places Pool Based ============
  
  // Gacha pool preview - show jackpot places for a district
  app.get("/api/gacha/pool/:city/:district", async (req, res) => {
    try {
      const { city, district } = req.params;
      
      if (!city || !district) {
        return res.status(400).json({ error: "city and district are required" });
      }

      const decodedCity = decodeURIComponent(city);
      const decodedDistrict = decodeURIComponent(district);
      
      // Get jackpot places: rating > 4.5 or has merchantId
      const jackpotPlaces = await storage.getJackpotPlaces(decodedCity, decodedDistrict);
      
      res.json({
        success: true,
        pool: {
          city: decodedCity,
          district: decodedDistrict,
          jackpots: jackpotPlaces.map(p => ({
            id: p.id,
            placeName: p.placeName,
            category: p.category,
            rating: p.rating,
            hasMerchant: !!p.merchantId,
            isPromoActive: p.isPromoActive,
          })),
          totalInPool: jackpotPlaces.length,
        }
      });
    } catch (error) {
      console.error("Gacha pool error:", error);
      res.status(500).json({ error: "Failed to get gacha pool" });
    }
  });

  // GET /api/gacha/pool/:city - 用城市名稱查詢獎池預覽
  app.get("/api/gacha/pool/:city", async (req, res) => {
    try {
      const { city } = req.params;
      const decodedCity = decodeURIComponent(city);
      
      // 取得該城市的所有快取地點作為獎池
      const places = await storage.getPlaceCacheByCity(decodedCity);
      
      // 篩選高評分的地點作為大獎
      const jackpots = places.filter(p => {
        const rating = p.googleRating ? parseFloat(p.googleRating) : 0;
        return rating >= 4.5;
      }).slice(0, 20);

      res.json({
        success: true,
        pool: {
          city: decodedCity,
          jackpots: jackpots.map(p => ({
            id: p.id,
            placeName: p.placeName,
            category: p.category,
            subCategory: p.subCategory,
            rating: p.googleRating,
          })),
          totalInPool: places.length,
          jackpotCount: jackpots.length,
        }
      });
    } catch (error) {
      console.error("Gacha pool by city error:", error);
      res.status(500).json({ error: "Failed to get gacha pool" });
    }
  });

  // GET /api/gacha/pool - 用 regionId 查詢獎池
  app.get("/api/gacha/pool", async (req, res) => {
    try {
      const { regionId, city } = req.query;
      
      if (!regionId && !city) {
        return res.status(400).json({ error: "regionId or city is required" });
      }

      let cityName = city as string;
      
      // 如果提供 regionId，查詢對應的城市名稱
      if (regionId && !city) {
        const parsedRegionId = parseInt(regionId as string);
        if (isNaN(parsedRegionId)) {
          return res.status(400).json({ error: "Invalid regionId" });
        }
        const region = await storage.getRegionById(parsedRegionId);
        if (!region) {
          return res.status(404).json({ error: "Region not found" });
        }
        cityName = region.nameZh;
      }

      // 取得該城市的所有快取地點作為獎池
      const places = await storage.getPlaceCacheByCity(cityName);
      
      // 篩選高評分或有商家的地點作為大獎
      const jackpots = places.filter(p => {
        const rating = p.googleRating ? parseFloat(p.googleRating) : 0;
        return rating >= 4.5;
      }).slice(0, 20);

      res.json({
        success: true,
        pool: {
          city: cityName,
          jackpots: jackpots.map(p => ({
            id: p.id,
            placeName: p.placeName,
            category: p.category,
            subCategory: p.subCategory,
            rating: p.googleRating,
          })),
          totalInPool: places.length,
          jackpotCount: jackpots.length,
        }
      });
    } catch (error) {
      console.error("Gacha pool by region error:", error);
      res.status(500).json({ error: "Failed to get gacha pool" });
    }
  });

  // GET /api/gacha/prize-pool - 查看獎池（高稀有度優惠券）
  app.get("/api/gacha/prize-pool", async (req, res) => {
    try {
      const { regionId } = req.query;
      
      if (!regionId) {
        return res.status(400).json({ error: "regionId is required" });
      }

      const parsedRegionId = parseInt(regionId as string);
      if (isNaN(parsedRegionId)) {
        return res.status(400).json({ error: "Invalid regionId" });
      }

      // 取得該地區的高稀有度優惠券 (SP, SSR)
      const prizePoolCoupons = await storage.getRegionPrizePoolCoupons(parsedRegionId);

      // 追蹤獎池查看數據
      for (const coupon of prizePoolCoupons) {
        if (coupon.merchantId) {
          try {
            await storage.incrementAnalyticsCounter(coupon.merchantId, coupon.placeLinkId, 'prizePoolViews');
          } catch (e) {
            console.error("Failed to track prize pool view:", e);
          }
        }
      }

      res.json({
        success: true,
        coupons: prizePoolCoupons.map(c => ({
          id: c.id,
          tier: c.rarity || c.tier || 'R',
          name: c.title || c.name,
          merchantName: c.merchantName || c.businessName,
          placeName: c.placeName,
          terms: c.terms,
        }))
      });
    } catch (error) {
      console.error("Get prize pool error:", error);
      res.status(500).json({ error: "Failed to get prize pool" });
    }
  });

  // Gacha pull V2 - from verified places pool with weighted selection
  app.post("/api/gacha/pull/v2", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      const { city, district, itemCount = 5 } = req.body;
      
      if (!city || !district) {
        return res.status(400).json({ error: "city and district are required" });
      }

      // Get current hour to determine time slot
      const hour = new Date().getHours();
      let timeSlots: string[] = [];
      
      if (hour >= 6 && hour < 10) {
        timeSlots = ['morning', 'FOOD'];
      } else if (hour >= 10 && hour < 14) {
        timeSlots = ['lunch', 'FOOD', 'SPOT'];
      } else if (hour >= 14 && hour < 17) {
        timeSlots = ['afternoon', 'SPOT', 'SHOP', 'EXP'];
      } else if (hour >= 17 && hour < 21) {
        timeSlots = ['dinner', 'FOOD', 'FUN'];
      } else {
        timeSlots = ['evening', 'FUN', 'FOOD'];
      }

      // Get all places in the pool for this district
      const allPlaces = await storage.getPlacesByDistrict(city, district);
      
      if (allPlaces.length === 0) {
        return res.json({
          success: true,
          items: [],
          meta: {
            message: "No places found in this district. Run seed to populate.",
            city,
            district,
          }
        });
      }

      // Get user's collected places for de-weighting
      const userCollections = userId ? await storage.getUserCollections(userId) : [];
      const collectedPlaceNames = new Set(userCollections.map(c => c.placeName));

      // Calculate weights for each place
      const weightedPlaces = allPlaces.map(place => {
        let weight = 1.0;
        
        // Boost places matching time slot categories
        if (timeSlots.includes(place.category)) {
          weight *= 1.5;
        }
        
        // Boost high-rated places
        if (place.rating && place.rating >= 4.5) {
          weight *= 1.3;
        }
        
        // Boost merchant places with active promo
        if (place.merchantId && place.isPromoActive) {
          weight *= 1.4;
        }
        
        // De-weight already collected places by 45%
        if (collectedPlaceNames.has(place.placeName)) {
          weight *= 0.55;
        }
        
        return { place, weight };
      });

      // Weighted random selection without replacement
      const selectedPlaces: typeof allPlaces = [];
      const availablePlaces = [...weightedPlaces];

      for (let i = 0; i < Math.min(itemCount, allPlaces.length) && availablePlaces.length > 0; i++) {
        const totalWeight = availablePlaces.reduce((sum, p) => sum + p.weight, 0);
        let random = Math.random() * totalWeight;
        
        for (let j = 0; j < availablePlaces.length; j++) {
          random -= availablePlaces[j].weight;
          if (random <= 0) {
            selectedPlaces.push(availablePlaces[j].place);
            availablePlaces.splice(j, 1);
            break;
          }
        }
      }

      // Determine coupon drops for each place
      const RARITY_DROP_RATES: Record<string, number> = {
        SP: 0.02,
        SSR: 0.08,
        SR: 0.15,
        S: 0.20,
        R: 0.35,
      };

      const items = await Promise.all(selectedPlaces.map(async (place) => {
        let couponDrop = null;
        
        // Check if this place has active coupons
        const coupons = await storage.getCouponsByPlaceId(place.id);
        const activeCoupons = coupons.filter(c => c.isActive && !c.archived && c.remainingQuantity > 0);
        
        if (activeCoupons.length > 0) {
          // Roll for each coupon based on rarity
          for (const coupon of activeCoupons) {
            const dropRate = coupon.dropRate || RARITY_DROP_RATES[coupon.rarity || 'R'] || 0.35;
            if (Math.random() < dropRate) {
              couponDrop = {
                id: coupon.id,
                title: coupon.title,
                code: coupon.code,
                rarity: coupon.rarity,
                terms: coupon.terms,
              };
              break;
            }
          }
        }

        return {
          id: place.id,
          placeName: place.placeName,
          category: place.category,
          subcategory: place.subcategory,
          description: place.description,
          address: place.address,
          rating: place.rating,
          locationLat: place.locationLat,
          locationLng: place.locationLng,
          googlePlaceId: place.googlePlaceId,
          photoReference: place.photoReference,
          coupon: couponDrop,
        };
      }));

      res.json({
        success: true,
        pull: {
          city,
          district,
          timeSlot: timeSlots[0],
          items,
        },
        meta: {
          totalItems: items.length,
          requestedItems: itemCount,
          poolSize: allPlaces.length,
          couponDrops: items.filter(i => i.coupon).length,
        }
      });
    } catch (error) {
      console.error("Gacha pull v2 error:", error);
      res.status(500).json({ error: "Failed to perform gacha pull" });
    }
  });

  // ============ Gacha V3 - Official Pool with Coupon Drop ============
  
  app.post("/api/gacha/pull/v3", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) {
        return res.status(401).json({ error: "Authentication required" });
      }

      const pullSchema = z.object({
        city: z.string().min(1),
        district: z.string().min(1),
        count: z.number().int().min(1).max(10).optional().default(5),
      });

      const validated = pullSchema.parse(req.body);
      const { city, district, count } = validated;

      const pulledPlaces = await storage.getOfficialPlacesByDistrict(city, district, count);
      
      if (pulledPlaces.length === 0) {
        return res.json({
          success: true,
          places: [],
          couponsWon: [],
          meta: {
            message: "No places found in this district pool.",
            city,
            district,
          }
        });
      }

      const placesResult: Array<{
        id: number;
        placeName: string;
        category: string;
        subcategory?: string | null;
        description?: string | null;
        address?: string | null;
        rating?: number | null;
        locationLat?: number | null;
        locationLng?: number | null;
        googlePlaceId?: string | null;
        hasMerchantClaim: boolean;
        couponWon?: {
          id: number;
          title: string;
          code: string;
          terms?: string | null;
        } | null;
      }> = [];
      
      const couponsWon: Array<{
        couponId: number;
        placeId: number;
        placeName: string;
        title: string;
        code: string;
        terms?: string | null;
      }> = [];

      for (const place of pulledPlaces) {
        let couponWon: typeof couponsWon[0] | null = null;
        let hasMerchantClaim = false;

        const claimInfo = await storage.getClaimByOfficialPlaceId(place.id);
        
        if (claimInfo) {
          hasMerchantClaim = true;
          
          const dropRate = claimInfo.claim.couponDropRate ?? 0.1;
          
          // 追蹤圖鑑收錄
          try {
            await storage.incrementAnalyticsCounter(claimInfo.claim.merchantId, claimInfo.claim.id, 'collectedCount');
          } catch (e) {
            console.error("Failed to track collection:", e);
          }
          
          if (Math.random() < dropRate && claimInfo.coupons.length > 0) {
            const randomIndex = Math.floor(Math.random() * claimInfo.coupons.length);
            const wonCoupon = claimInfo.coupons[randomIndex];
            
            couponWon = {
              couponId: wonCoupon.id,
              placeId: place.id,
              placeName: place.placeName,
              title: wonCoupon.title,
              code: wonCoupon.code,
              terms: wonCoupon.terms,
            };
            
            couponsWon.push(couponWon);
            
            // 追蹤優惠券發放
            try {
              await storage.incrementAnalyticsCounter(claimInfo.claim.merchantId, claimInfo.claim.id, 'couponIssuedCount');
            } catch (e) {
              console.error("Failed to track coupon issue:", e);
            }
            
            await storage.saveToCollectionWithCoupon(userId, place, wonCoupon);
          } else {
            await storage.saveToCollectionWithCoupon(userId, place);
          }
        } else {
          await storage.saveToCollectionWithCoupon(userId, place);
        }

        placesResult.push({
          id: place.id,
          placeName: place.placeName,
          category: place.category,
          subcategory: place.subcategory,
          description: place.description,
          address: place.address,
          rating: place.rating,
          locationLat: place.locationLat,
          locationLng: place.locationLng,
          googlePlaceId: place.googlePlaceId,
          hasMerchantClaim,
          couponWon: couponWon ? {
            id: couponWon.couponId,
            title: couponWon.title,
            code: couponWon.code,
            terms: couponWon.terms,
          } : null,
        });
      }

      res.json({
        success: true,
        places: placesResult,
        couponsWon,
        meta: {
          city,
          district,
          totalPlaces: placesResult.length,
          totalCouponsWon: couponsWon.length,
        }
      });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ error: error.errors });
      }
      console.error("Gacha pull v3 error:", error);
      res.status(500).json({ error: "Failed to perform gacha pull" });
    }
  });

  // ============ Gacha V3 - One-Day Itinerary from Official Pool ============
  
  app.post("/api/gacha/itinerary/v3", async (req: any, res) => {
    const userId = req.user?.claims?.sub || 'guest';
    console.log('[Gacha V3] Request received:', { body: req.body, userId });
    
    try {

      // Support both old format (city, district) and new simplified format (regionId, itemCount)
      const itinerarySchema = z.object({
        // New simplified format from mobile app
        regionId: z.number().optional(),
        countryId: z.number().optional(),
        language: z.string().optional(),
        itemCount: z.number().min(1).max(15).optional(),
        // Legacy format
        city: z.string().optional(),
        district: z.string().optional(),
        pace: z.enum(['relaxed', 'moderate', 'packed']).optional(),
      });

      const validated = itinerarySchema.parse(req.body);
      let { city, district, pace } = validated;
      const { regionId, itemCount } = validated;
      
      // ========== 每日抽卡限制檢查 ==========
      const DAILY_PULL_LIMIT = 36; // 每人每天最多抽 36 張卡
      const requestedCount = itemCount || 7; // 預設 7 張
      
      if (userId !== 'guest') {
        const currentDailyCount = await storage.getUserDailyGachaCount(userId);
        const remainingQuota = DAILY_PULL_LIMIT - currentDailyCount;
        
        if (remainingQuota <= 0) {
          return res.status(429).json({
            success: false,
            error: "今日抽卡次數已達上限，請明天再來！",
            code: "DAILY_LIMIT_EXCEEDED",
            dailyLimit: DAILY_PULL_LIMIT,
            currentCount: currentDailyCount,
            remainingQuota: 0
          });
        }
        
        if (requestedCount > remainingQuota) {
          return res.status(400).json({
            success: false,
            error: `今日剩餘額度為 ${remainingQuota} 張，請調整抽取數量`,
            code: "EXCEEDS_REMAINING_QUOTA",
            dailyLimit: DAILY_PULL_LIMIT,
            currentCount: currentDailyCount,
            remainingQuota
          });
        }
      }
      
      // If regionId is provided, look up the city name from database
      if (regionId && !city) {
        const region = await storage.getRegionById(regionId);
        if (!region) {
          return res.status(400).json({ 
            success: false, 
            error: "找不到指定的區域",
            code: "REGION_NOT_FOUND"
          });
        }
        city = region.nameZh;
        console.log('[Gacha V3] Resolved regionId', regionId, 'to city:', city);
      }
      
      // Validate that we have city at minimum
      if (!city) {
        return res.status(400).json({ 
          success: false, 
          error: "請選擇城市（需提供 city 或 regionId）",
          code: "CITY_REQUIRED"
        });
      }
      
      // Convert itemCount to pace if provided
      if (itemCount && !pace) {
        if (itemCount <= 5) pace = 'relaxed';
        else if (itemCount <= 7) pace = 'moderate';
        else pace = 'packed';
      }
      pace = pace || 'moderate';
      
      console.log('[Gacha V3] Validated params:', { city, district, pace, itemCount, userId });

      const itemCounts = { relaxed: 5, moderate: 7, packed: 10 };
      const targetCount = itemCount || itemCounts[pace];

      // ========== Step 1: 錨點策略 (Anchor Strategy) ==========
      // 如果沒有指定 district，從該縣市的鄉鎮區中隨機選一個當核心錨點
      let anchorDistrict = district;
      if (!anchorDistrict && regionId) {
        const districts = await storage.getDistrictsByRegion(regionId);
        if (districts.length > 0) {
          const randomIdx = Math.floor(Math.random() * districts.length);
          anchorDistrict = districts[randomIdx].nameZh;
          console.log('[Gacha V3] Anchor district selected:', anchorDistrict);
        }
      }
      
      // ========== Step 2: 結構化選點 (Structured Selection) ==========
      // 定義類別配比：基本配額 + 權重分配
      const getFoodQuota = (count: number) => count <= 7 ? 2 : 3;
      const getStayQuota = (count: number) => count >= 9 ? 1 : 0;
      
      const foodQuota = getFoodQuota(targetCount);
      const stayQuota = getStayQuota(targetCount);
      const remainingCount = targetCount - foodQuota - stayQuota;
      
      console.log('[Gacha V3] Quotas:', { foodQuota, stayQuota, remainingCount, targetCount });
      
      // 查詢錨點區域的地點
      const anchorPlaces = anchorDistrict 
        ? await storage.getOfficialPlacesByDistrict(city, anchorDistrict, 100)
        : await storage.getOfficialPlacesByCity(city, 100);
      
      console.log('[Gacha V3] Anchor places found:', anchorPlaces.length, 'in', anchorDistrict || city);
      
      if (anchorPlaces.length === 0) {
        const locationDesc = anchorDistrict ? `${city}${anchorDistrict}` : city;
        return res.json({
          success: true,
          itinerary: [],
          couponsWon: [],
          meta: { 
            message: `${locationDesc}目前還沒有上線的景點，我們正在努力擴充中！`,
            code: "NO_PLACES_AVAILABLE",
            city, 
            district: anchorDistrict || null
          }
        });
      }
      
      // 按類別分組
      const groupByCategory = (places: any[]) => {
        const groups: Record<string, any[]> = {};
        for (const p of places) {
          const cat = p.category || '其他';
          if (!groups[cat]) groups[cat] = [];
          groups[cat].push(p);
        }
        return groups;
      };
      
      const anchorByCategory = groupByCategory(anchorPlaces);
      const selectedPlaces: any[] = [];
      const usedIds = new Set<number>();
      
      // 輔助函數：從類別中隨機選取
      const pickFromCategory = (category: string, count: number, fallbackPlaces?: any[]) => {
        const picked: any[] = [];
        let pool = [...(anchorByCategory[category] || [])];
        
        // 如果錨點區不夠，從 fallback 補充
        if (pool.length < count && fallbackPlaces) {
          const fallbackByCategory = groupByCategory(fallbackPlaces);
          pool = [...pool, ...(fallbackByCategory[category] || [])];
        }
        
        // 打亂並選取
        for (let i = pool.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [pool[i], pool[j]] = [pool[j], pool[i]];
        }
        
        for (const p of pool) {
          if (picked.length >= count) break;
          if (!usedIds.has(p.id)) {
            picked.push(p);
            usedIds.add(p.id);
          }
        }
        return picked;
      };
      
      // ========== Step 2a: 擴散備案 (Fallback) ==========
      // 預先查詢整個縣市的地點作為 fallback
      const cityPlaces = anchorDistrict 
        ? await storage.getOfficialPlacesByCity(city, 200)
        : anchorPlaces;
      
      // 選取「食」的基本配額
      const foodPicks = pickFromCategory('食', foodQuota, cityPlaces);
      selectedPlaces.push(...foodPicks);
      console.log('[Gacha V3] Food picks:', foodPicks.length);
      
      // 選取「宿」的基本配額
      if (stayQuota > 0) {
        const stayPicks = pickFromCategory('宿', stayQuota, cityPlaces);
        selectedPlaces.push(...stayPicks);
        console.log('[Gacha V3] Stay picks:', stayPicks.length);
      }
      
      // ========== Step 2b: 權重分配剩餘 ==========
      // 計算各類別權重（基於資料庫數量）
      const cityByCategory = groupByCategory(cityPlaces);
      const categoryWeights: Record<string, number> = {};
      let totalWeight = 0;
      
      for (const [cat, places] of Object.entries(cityByCategory)) {
        // 完全排除「宿」類別從權重分配（住宿只能通過基本配額獲得，最多 1 個）
        if (cat === '宿') {
          continue;
        }
        // 使用等權重（每個類別權重 = 1），避免資料量大的類別（如「食」）佔比過高
        categoryWeights[cat] = 1;
        totalWeight += 1;
      }
      
      // 按權重隨機選取剩餘地點
      let remaining = remainingCount;
      while (remaining > 0 && usedIds.size < cityPlaces.length) {
        // 加權隨機選擇類別
        let rand = Math.random() * totalWeight;
        let selectedCategory = '';
        for (const [cat, weight] of Object.entries(categoryWeights)) {
          rand -= weight;
          if (rand <= 0) {
            selectedCategory = cat;
            break;
          }
        }
        if (!selectedCategory) selectedCategory = Object.keys(categoryWeights)[0];
        
        // 從該類別選一個
        const picks = pickFromCategory(selectedCategory, 1, cityPlaces);
        if (picks.length > 0) {
          selectedPlaces.push(...picks);
          remaining--;
        } else {
          // 該類別沒地點了，降低權重
          categoryWeights[selectedCategory] = 0;
          totalWeight = Object.values(categoryWeights).reduce((a, b) => a + b, 0);
          if (totalWeight === 0) break;
        }
      }
      
      console.log('[Gacha V3] Total selected:', selectedPlaces.length);
      
      // ========== Step 3: 經緯度排序 (Coordinate Sorting) ==========
      // 使用最近鄰居演算法排序
      const sortByCoordinates = (places: any[]) => {
        if (places.length <= 1) return places;
        
        // 分離有效座標和無效座標的地點
        const withCoords = places.filter(p => p.locationLat && p.locationLng);
        const withoutCoords = places.filter(p => !p.locationLat || !p.locationLng);
        
        if (withCoords.length <= 1) return [...withCoords, ...withoutCoords];
        
        const sorted: any[] = [];
        const remaining = [...withCoords];
        
        // 從最北的點開始（早上通常從北邊開始）
        remaining.sort((a, b) => b.locationLat - a.locationLat);
        sorted.push(remaining.shift()!);
        
        // 最近鄰居
        while (remaining.length > 0) {
          const last = sorted[sorted.length - 1];
          let nearestIdx = 0;
          let nearestDist = Infinity;
          
          for (let i = 0; i < remaining.length; i++) {
            const p = remaining[i];
            const dist = Math.sqrt(
              Math.pow(p.locationLat - last.locationLat, 2) +
              Math.pow(p.locationLng - last.locationLng, 2)
            );
            if (dist < nearestDist) {
              nearestDist = dist;
              nearestIdx = i;
            }
          }
          
          sorted.push(remaining.splice(nearestIdx, 1)[0]);
        }
        
        // 無座標的地點加到最後
        return [...sorted, ...withoutCoords];
      };
      
      const coordinateSortedPlaces = sortByCoordinates(selectedPlaces);
      
      // ========== Step 3b: 住宿排最後 ==========
      // 把「宿」類別的地點抽出，放到最後（晚上才入住）
      const stayPlaces = coordinateSortedPlaces.filter(p => p.category === '宿');
      const nonStayPlaces = coordinateSortedPlaces.filter(p => p.category !== '宿');
      const sortedPlaces = [...nonStayPlaces, ...stayPlaces];
      
      console.log('[Gacha V3] After stay reorder:', { nonStay: nonStayPlaces.length, stay: stayPlaces.length });

      // ========== Step 3c: AI 在地人調整順序 ==========
      let finalPlaces = sortedPlaces;
      let aiReorderResult = 'skipped';
      
      if (nonStayPlaces.length >= 3) {
        try {
          const baseUrl = process.env.AI_INTEGRATIONS_GEMINI_BASE_URL;
          const apiKey = process.env.AI_INTEGRATIONS_GEMINI_API_KEY;
          
          const placesInfo = nonStayPlaces.map((p, idx) => ({
            idx: idx + 1,
            name: p.placeName,
            category: p.category,
            address: p.address || ''
          }));
          
          const exampleOrder = Array.from({length: nonStayPlaces.length}, (_, i) => i + 1).join(',');
          const reorderPrompt = `調整以下景點順序（早餐店排前面、夜店排最後）：
${placesInfo.map(p => `${p.idx}.${p.name}(${p.category})`).join(' ')}
只回覆數字順序如：${exampleOrder}`;
          
          const reorderResponse = await fetch(`${baseUrl}/models/gemini-2.5-flash:generateContent`, {
            method: 'POST',
            headers: { 
              'Content-Type': 'application/json',
              'x-goog-api-key': apiKey || ''
            },
            body: JSON.stringify({
              contents: [{ role: 'user', parts: [{ text: reorderPrompt }] }],
              generationConfig: { maxOutputTokens: 500, temperature: 0.2 }
            })
          });
          
          const reorderData = await reorderResponse.json() as { candidates?: Array<{ content?: { parts?: Array<{ text?: string }> } }>, error?: { code?: string; message?: string } };
          const reorderText = reorderData.candidates?.[0]?.content?.parts?.[0]?.text?.trim() || '';
          console.log('[Gacha V3] AI Reorder response:', reorderText);
          
          if (reorderText) {
            if (reorderText === 'OK' || reorderText.includes('OK') || reorderText.includes('順序合理')) {
              aiReorderResult = 'no_change';
            } else {
              const allNumbers = reorderText.match(/\d+/g);
              if (allNumbers && allNumbers.length > 0) {
                const newOrder = allNumbers.map(n => parseInt(n)).filter(n => !isNaN(n) && n >= 1 && n <= nonStayPlaces.length);
                const uniqueOrder = [...new Set(newOrder)];
                
                if (uniqueOrder.length === nonStayPlaces.length) {
                  const reorderedNonStay = uniqueOrder.map(idx => nonStayPlaces[idx - 1]);
                  finalPlaces = [...reorderedNonStay, ...stayPlaces];
                  aiReorderResult = 'reordered';
                  console.log('[Gacha V3] AI reordered:', uniqueOrder);
                } else {
                  aiReorderResult = 'partial_response';
                  console.log('[Gacha V3] AI reorder partial (got', uniqueOrder.length, 'of', nonStayPlaces.length, '), keeping original');
                }
              } else {
                aiReorderResult = 'no_numbers';
                console.log('[Gacha V3] AI returned text without numbers:', reorderText.slice(0, 50));
              }
            }
          } else {
            aiReorderResult = 'empty_response';
          }
        } catch (reorderError) {
          console.error('[Gacha V3] AI reorder failed:', reorderError);
          aiReorderResult = 'error';
        }
      }
      
      console.log('[Gacha V3] AI reorder result:', aiReorderResult);

      const itinerary: Array<{
        id: number;
        placeName: string;
        category: string;
        subCategory?: string | null;
        description?: string | null;
        address?: string | null;
        rating?: number | null;
        locationLat?: number | null;
        locationLng?: number | null;
        googlePlaceId?: string | null;
        timeSlot: string;
        colorHex: string;
        isCoupon: boolean;
        couponData?: { id: number; title: string; code: string; terms?: string | null } | null;
        rarity?: string | null;
      }> = [];
      
      const couponsWon: Array<{ couponId: number; placeId: number; placeName: string; title: string; code: string; terms?: string | null }> = [];
      
      // 時段分配
      const timeSlots = ['breakfast', 'morning', 'lunch', 'afternoon', 'dinner', 'evening'];
      
      for (let i = 0; i < finalPlaces.length; i++) {
        const place = finalPlaces[i];
        const timeSlot = timeSlots[i % timeSlots.length];
        
        let couponWon = null;
        const claimInfo = await storage.getClaimByOfficialPlaceId(place.id);
        
        if (claimInfo) {
          const dropRate = claimInfo.claim.couponDropRate ?? 0.1;
          if (Math.random() < dropRate && claimInfo.coupons.length > 0) {
            const randomIdx = Math.floor(Math.random() * claimInfo.coupons.length);
            const wonCoupon = claimInfo.coupons[randomIdx];
            couponWon = { id: wonCoupon.id, title: wonCoupon.title, code: wonCoupon.code, terms: wonCoupon.terms };
            couponsWon.push({ couponId: wonCoupon.id, placeId: place.id, placeName: place.placeName, title: wonCoupon.title, code: wonCoupon.code, terms: wonCoupon.terms });
            if (userId !== 'guest') {
              await storage.saveToCollectionWithCoupon(userId, place, wonCoupon);
            }
          } else {
            if (userId !== 'guest') {
              await storage.saveToCollectionWithCoupon(userId, place);
            }
          }
        } else {
          if (userId !== 'guest') {
            await storage.saveToCollectionWithCoupon(userId, place);
          }
        }

        // Category 中文映射
        const categoryZhMap: Record<string, string> = {
          'food': '美食', 'stay': '住宿', 'education': '生態文化教育',
          'activity': '遊程體驗', 'entertainment': '娛樂設施', 'scenery': '景點', 'shopping': '購物',
          'experience': '遊程體驗'
        };
        // 顏色映射
        const categoryColorMap: Record<string, string> = {
          'food': '#FF6B6B', 'stay': '#4ECDC4', 'education': '#45B7D1',
          'activity': '#96CEB4', 'entertainment': '#FFEAA7', 'scenery': '#DDA0DD', 'shopping': '#FFB347',
          'experience': '#96CEB4'
        };
        const categoryZh = categoryZhMap[place.category] || place.category;
        const colorHex = categoryColorMap[place.category] || '#6366f1';
        
        // 同時提供攤平格式和巢狀格式，確保向下相容
        itinerary.push({
          id: place.id,
          placeName: place.placeName,
          category: categoryZh,
          subCategory: place.subcategory,
          description: place.description,
          address: place.address,
          rating: place.rating,
          locationLat: place.locationLat,
          locationLng: place.locationLng,
          googlePlaceId: place.googlePlaceId,
          timeSlot,
          colorHex,
          isCoupon: !!couponWon,
          couponData: couponWon,
          rarity: couponWon ? 'SR' : null,
          place: {
            id: place.id,
            placeName: place.placeName,
            category: categoryZh,
            subcategory: place.subcategory,
            description: place.description,
            address: place.address,
            rating: place.rating,
            locationLat: place.locationLat,
            locationLng: place.locationLng,
            googlePlaceId: place.googlePlaceId,
          },
          couponWon,
        });
      }

      // 計算類別統計
      const categoryStats: Record<string, number> = {};
      for (const p of finalPlaces) {
        const cat = p.category || '其他';
        categoryStats[cat] = (categoryStats[cat] || 0) + 1;
      }
      
      // ========== Step 4: AI 生成主題介紹 ==========
      let themeIntro = '';
      try {
        const placeNames = finalPlaces.slice(0, 5).map(p => p.placeName).join('、');
        const prompt = `地點：${placeNames}
任務：為${anchorDistrict || city}一日遊寫一句主題介紹
規則：只輸出20-30個中文字，不要英文、不要解釋、不要標點
範例：悠遊溫泉山海品嚐在地美食的療癒小旅行`;
        
        const baseUrl = process.env.AI_INTEGRATIONS_GEMINI_BASE_URL;
        const apiKey = process.env.AI_INTEGRATIONS_GEMINI_API_KEY;
        const response = await fetch(`${baseUrl}/models/gemini-2.5-flash:generateContent`, {
          method: 'POST',
          headers: { 
            'Content-Type': 'application/json',
            'x-goog-api-key': apiKey || ''
          },
          body: JSON.stringify({
            contents: [{ role: 'user', parts: [{ text: prompt }] }],
            generationConfig: { maxOutputTokens: 100, temperature: 0.5 }
          })
        });
        
        const data = await response.json() as { candidates?: Array<{ content?: { parts?: Array<{ text?: string }> } }>, error?: { code?: string; message?: string } };
        console.log('[Gacha V3] Gemini response:', JSON.stringify(data).slice(0, 500));
        
        if (data.error) {
          console.error('[Gacha V3] Gemini API error:', data.error);
          throw new Error(data.error.message || 'Gemini API error');
        }
        
        let rawTheme = data.candidates?.[0]?.content?.parts?.[0]?.text?.trim() || '';
        // 清理格式標記和英文內容
        themeIntro = rawTheme
          .replace(/\*\*/g, '')  // 移除加粗
          .replace(/\s*\(\d+字?\)\s*/g, '')  // 移除字數標記
          .replace(/[a-zA-Z]+/g, '')  // 移除所有英文
          .replace(/["""''`*#\-_]/g, '')  // 移除引號和特殊符號
          .replace(/\s+/g, '')  // 移除空白
          .replace(/[.,!?;:。，！？；：、]/g, '')  // 移除標點
          .trim();
        console.log('[Gacha V3] AI Theme (raw):', rawTheme, '-> (clean):', themeIntro);
        
        // 如果清理後太短或太長，使用 fallback
        if (!themeIntro || themeIntro.length < 8 || themeIntro.length > 50) {
          themeIntro = `探索${anchorDistrict || city}的在地風情`;
        }
      } catch (aiError) {
        console.error('[Gacha V3] AI theme generation failed:', aiError);
        themeIntro = `探索${anchorDistrict || city}的在地風情`;
      }
      
      // 成功後遞增每日抽卡計數
      let newDailyCount = 0;
      let remainingQuota = DAILY_PULL_LIMIT;
      if (userId !== 'guest') {
        newDailyCount = await storage.incrementUserDailyGachaCount(userId, itinerary.length);
        remainingQuota = DAILY_PULL_LIMIT - newDailyCount;
      }
      
      res.json({
        success: true,
        targetDistrict: anchorDistrict || city,
        city,
        country: '台灣',
        themeIntro,
        itinerary,
        couponsWon,
        meta: {
          city,
          anchorDistrict,
          pace,
          totalPlaces: itinerary.length,
          totalCouponsWon: couponsWon.length,
          categoryDistribution: categoryStats,
          sortingMethod: aiReorderResult === 'reordered' ? 'ai_reordered' : 'coordinate',
          aiReorderResult,
          dailyLimit: DAILY_PULL_LIMIT,
          dailyPullCount: newDailyCount,
          remainingQuota
        }
      });
    } catch (error) {
      console.error("[Gacha V3] Error:", error);
      
      if (error instanceof z.ZodError) {
        const firstError = error.errors[0];
        return res.status(400).json({ 
          success: false,
          error: firstError?.message || "請求參數格式錯誤",
          code: "INVALID_PARAMS",
          details: error.errors
        });
      }
      
      res.status(500).json({ 
        success: false,
        error: "扭蛋系統暫時無法使用，請稍後再試",
        code: "INTERNAL_ERROR"
      });
    }
  });

  // ============ Merchant Registration ============
  app.post("/api/merchant/register", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) {
        return res.status(401).json({ error: "Authentication required" });
      }

      // Check if merchant already exists
      let merchant = await storage.getMerchantByUserId(userId);
      if (merchant) {
        return res.json({ success: true, merchant, isNew: false });
      }

      // Get user info
      const user = await storage.getUser(userId);
      const name = req.body.name || user?.firstName || 'Merchant';
      const email = req.body.email || user?.email || '';

      // Create new merchant
      merchant = await storage.createMerchant({
        userId,
        name,
        email,
        subscriptionPlan: 'free'
      });

      res.json({ success: true, merchant, isNew: true });
    } catch (error) {
      console.error("Merchant registration error:", error);
      res.status(500).json({ error: "Failed to register merchant" });
    }
  });

  app.get("/api/merchant/me", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) {
        return res.status(401).json({ error: "Authentication required" });
      }

      const merchant = await storage.getMerchantByUserId(userId);
      if (!merchant) {
        return res.json({ merchant: null });
      }

      res.json({ merchant });
    } catch (error) {
      console.error("Get merchant error:", error);
      res.status(500).json({ error: "Failed to get merchant info" });
    }
  });

  // ============ Merchant Daily Seed Code ============
  // Get daily seed code
  app.get("/api/merchant/daily-code", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) {
        return res.status(401).json({ error: "Authentication required" });
      }

      const merchant = await storage.getMerchantByUserId(userId);
      if (!merchant) {
        return res.status(403).json({ error: "Merchant registration required" });
      }

      const codeData = await storage.getMerchantDailySeedCode(merchant.id);
      
      // Check if code needs to be regenerated (new day)
      const today = new Date().toDateString();
      const codeDate = codeData?.updatedAt ? new Date(codeData.updatedAt).toDateString() : null;
      
      if (!codeData || codeDate !== today) {
        // Generate new daily code
        const newCode = crypto.randomBytes(4).toString('hex').toUpperCase();
        await storage.updateMerchantDailySeedCode(merchant.id, newCode);
        return res.json({ code: newCode, generatedAt: new Date() });
      }

      res.json({ code: codeData.seedCode, generatedAt: codeData.updatedAt });
    } catch (error) {
      console.error("Get daily code error:", error);
      res.status(500).json({ error: "Failed to get daily code" });
    }
  });

  // Verify daily code (for check-in verification)
  app.post("/api/merchant/verify-code", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) {
        return res.status(401).json({ error: "Authentication required" });
      }

      const { merchantId, code } = req.body;
      if (!merchantId || !code) {
        return res.status(400).json({ error: "merchantId and code are required" });
      }

      const codeData = await storage.getMerchantDailySeedCode(merchantId);
      if (!codeData) {
        return res.status(404).json({ error: "No code found for this merchant" });
      }

      // Check if code is from today
      const today = new Date().toDateString();
      const codeDate = new Date(codeData.updatedAt).toDateString();
      if (codeDate !== today) {
        return res.status(400).json({ error: "Code has expired", isValid: false });
      }

      const isValid = codeData.seedCode === code.toUpperCase();
      res.json({ isValid, merchantId });
    } catch (error) {
      console.error("Verify code error:", error);
      res.status(500).json({ error: "Failed to verify code" });
    }
  });

  // ============ Merchant Credits ============
  // Get merchant credit balance
  app.get("/api/merchant/credits", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) {
        return res.status(401).json({ error: "Authentication required" });
      }

      const merchant = await storage.getMerchantByUserId(userId);
      if (!merchant) {
        return res.status(403).json({ error: "Merchant registration required" });
      }

      res.json({ 
        creditBalance: merchant.creditBalance || 0,
        subscriptionPlan: merchant.subscriptionPlan 
      });
    } catch (error) {
      console.error("Get credits error:", error);
      res.status(500).json({ error: "Failed to get credits" });
    }
  });

  // Purchase credits - supports both Stripe and Recur payment providers
  app.post("/api/merchant/credits/purchase", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) {
        return res.status(401).json({ error: "Authentication required" });
      }

      const merchant = await storage.getMerchantByUserId(userId);
      if (!merchant) {
        return res.status(403).json({ error: "Merchant registration required" });
      }

      const { amount, provider } = req.body;
      if (!amount || amount < 100) {
        return res.status(400).json({ error: "Minimum purchase amount is 100 credits" });
      }

      const paymentProvider = provider === 'recur' ? 'recur' : 'stripe';

      // Create pending transaction
      const transaction = await storage.createTransaction({
        merchantId: merchant.id,
        amount,
        paymentStatus: 'pending',
        paymentMethod: paymentProvider,
      });

      // Generate checkout URL based on provider
      let checkoutUrl: string | null = null;
      
      if (paymentProvider === 'stripe') {
        try {
          const stripeClient = await getUncachableStripeClient();
          const session = await stripeClient.checkout.sessions.create({
            mode: 'payment',
            line_items: [{
              price_data: {
                currency: 'twd',
                product_data: {
                  name: `${amount} 平台點數`,
                  description: `購買 ${amount} 點平台點數`,
                },
                unit_amount: amount * 100,
              },
              quantity: 1,
            }],
            metadata: {
              transactionId: transaction.id.toString(),
              merchantId: merchant.id.toString(),
              amount: amount.toString(),
              type: 'credits_purchase',
            },
            success_url: `${process.env.REPLIT_DEV_DOMAIN ? `https://${process.env.REPLIT_DEV_DOMAIN}` : 'https://gacha-travel--s8869420.replit.app'}/merchant/credits?success=true`,
            cancel_url: `${process.env.REPLIT_DEV_DOMAIN ? `https://${process.env.REPLIT_DEV_DOMAIN}` : 'https://gacha-travel--s8869420.replit.app'}/merchant/credits?canceled=true`,
          });
          checkoutUrl = session.url;
        } catch (stripeError) {
          console.error("Stripe checkout error:", stripeError);
          return res.status(500).json({ error: "Failed to create Stripe checkout session" });
        }
      } else if (paymentProvider === 'recur') {
        // Recur (PAYUNi) checkout - generate payment URL
        // Note: This requires PAYUNi API integration
        const recurSecretKey = process.env.RECUR_SECRET_KEY;
        if (!recurSecretKey) {
          return res.status(500).json({ error: "Recur payment not configured" });
        }
        // For now, return pending status - actual Recur integration would generate a payment URL
        checkoutUrl = null; // TODO: Implement PAYUNi/Recur checkout URL generation
      }

      res.json({ 
        transactionId: transaction.id,
        amount,
        provider: paymentProvider,
        checkoutUrl,
        status: 'pending',
        message: checkoutUrl ? '請前往付款頁面完成付款' : '請完成付款以獲得點數'
      });
    } catch (error) {
      console.error("Purchase credits error:", error);
      res.status(500).json({ error: "Failed to create purchase request" });
    }
  });

  // Get merchant transaction history
  app.get("/api/merchant/transactions", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) {
        return res.status(401).json({ error: "Authentication required" });
      }

      const merchant = await storage.getMerchantByUserId(userId);
      if (!merchant) {
        return res.status(403).json({ error: "Merchant registration required" });
      }

      const transactions = await storage.getTransactionsByMerchantId(merchant.id);
      res.json({ transactions });
    } catch (error) {
      console.error("Get transactions error:", error);
      res.status(500).json({ error: "Failed to get transactions" });
    }
  });

  // ============ Specialist Routes ============
  // Register as specialist
  app.post("/api/specialist/register", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) {
        return res.status(401).json({ error: "Authentication required" });
      }

      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ error: "User not found" });
      }

      // Check if already a specialist
      const existing = await storage.getSpecialistByUserId(userId);
      if (existing) {
        return res.status(400).json({ error: "Already registered as specialist" });
      }

      const { name, serviceRegion } = req.body;
      if (!name || !serviceRegion) {
        return res.status(400).json({ error: "name and serviceRegion are required" });
      }

      const specialist = await storage.createSpecialist({
        userId,
        name,
        serviceRegion,
        isAvailable: false, // Start as unavailable until admin approves
        maxTravelers: 5,
        currentTravelers: 0,
      });

      res.status(201).json({ specialist });
    } catch (error) {
      console.error("Specialist registration error:", error);
      res.status(500).json({ error: "Failed to register as specialist" });
    }
  });

  // Get current specialist profile
  app.get("/api/specialist/me", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) {
        return res.status(401).json({ error: "Authentication required" });
      }

      const specialist = await storage.getSpecialistByUserId(userId);
      res.json({ specialist: specialist || null });
    } catch (error) {
      console.error("Get specialist error:", error);
      res.status(500).json({ error: "Failed to get specialist profile" });
    }
  });

  // Toggle online status
  app.post("/api/specialist/toggle-online", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) {
        return res.status(401).json({ error: "Authentication required" });
      }

      const specialist = await storage.getSpecialistByUserId(userId);
      if (!specialist) {
        return res.status(403).json({ error: "Specialist registration required" });
      }

      if (!specialist.isAvailable) {
        // Toggle to available
        const updated = await storage.updateSpecialist(specialist.id, {
          isAvailable: true,
        });
        return res.json({ isAvailable: updated?.isAvailable });
      } else {
        // Toggle to unavailable
        const updated = await storage.updateSpecialist(specialist.id, {
          isAvailable: false,
        });
        return res.json({ isAvailable: updated?.isAvailable });
      }
    } catch (error) {
      console.error("Toggle online error:", error);
      res.status(500).json({ error: "Failed to toggle online status" });
    }
  });

  // Get active service relations for specialist
  app.get("/api/specialist/services", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) {
        return res.status(401).json({ error: "Authentication required" });
      }

      const specialist = await storage.getSpecialistByUserId(userId);
      if (!specialist) {
        return res.status(403).json({ error: "Specialist registration required" });
      }

      const relations = await storage.getActiveServiceRelationsBySpecialist(specialist.id);
      res.json({ services: relations });
    } catch (error) {
      console.error("Get services error:", error);
      res.status(500).json({ error: "Failed to get services" });
    }
  });

  // ============ Traveler Service Routes ============
  // Request a specialist (auto-match by region)
  app.post("/api/service/request", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) {
        return res.status(401).json({ error: "Authentication required" });
      }

      const { region } = req.body;
      if (!region) {
        return res.status(400).json({ error: "region is required" });
      }

      // Check if already has active service
      const existing = await storage.getActiveServiceRelationByTraveler(userId);
      if (existing) {
        return res.status(400).json({ error: "Already have an active service session" });
      }

      // Find available specialist in region
      const specialist = await storage.findAvailableSpecialist(region);
      if (!specialist) {
        return res.status(404).json({ error: "No available specialists in your region" });
      }

      // Create service relation
      const relation = await storage.createServiceRelation({
        travelerId: userId,
        specialistId: specialist.id,
        region,
      });

      res.status(201).json({ 
        service: relation,
        specialist: {
          id: specialist.id,
          name: specialist.name,
          serviceRegion: specialist.serviceRegion,
        }
      });
    } catch (error) {
      console.error("Request service error:", error);
      res.status(500).json({ error: "Failed to request specialist" });
    }
  });

  // Get current service for traveler
  app.get("/api/service/current", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) {
        return res.status(401).json({ error: "Authentication required" });
      }

      const relation = await storage.getActiveServiceRelationByTraveler(userId);
      if (!relation) {
        return res.json({ service: null });
      }

      const specialist = await storage.getSpecialistById(relation.specialistId);
      res.json({ 
        service: relation,
        specialist: specialist ? {
          id: specialist.id,
          name: specialist.name,
          serviceRegion: specialist.serviceRegion,
        } : null
      });
    } catch (error) {
      console.error("Get current service error:", error);
      res.status(500).json({ error: "Failed to get current service" });
    }
  });

  // End service and rate specialist
  app.post("/api/service/:id/end", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) {
        return res.status(401).json({ error: "Authentication required" });
      }

      const serviceId = parseInt(req.params.id);
      const { rating } = req.body;

      const relation = await storage.getServiceRelationById(serviceId);
      if (!relation) {
        return res.status(404).json({ error: "Service not found" });
      }

      if (relation.travelerId !== userId) {
        return res.status(403).json({ error: "Not authorized to end this service" });
      }

      const updated = await storage.endServiceRelation(serviceId, rating);

      res.json({ success: true, service: updated });
    } catch (error) {
      console.error("End service error:", error);
      res.status(500).json({ error: "Failed to end service" });
    }
  });

  // ============ Merchant Place Claim Routes ============
  app.get("/api/merchant/places/search", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) {
        return res.status(401).json({ error: "Authentication required" });
      }

      const { query, district, city } = req.query;
      if (!query || query.length < 2) {
        return res.status(400).json({ error: "Query must be at least 2 characters" });
      }

      const places = await storage.searchPlacesForClaim(query, district, city);
      res.json({ places });
    } catch (error) {
      console.error("Place search error:", error);
      res.status(500).json({ error: "Failed to search places" });
    }
  });

  app.post("/api/merchant/places/claim", isAuthenticated, async (req: any, res) => {
    try {
      console.log("[ClaimAPI] Request body:", JSON.stringify(req.body));
      
      const userId = req.user?.claims?.sub;
      if (!userId) {
        console.log("[ClaimAPI] No userId found");
        return res.status(401).json({ error: "Authentication required" });
      }
      console.log("[ClaimAPI] userId:", userId);

      const merchant = await storage.getMerchantByUserId(userId);
      if (!merchant) {
        console.log("[ClaimAPI] No merchant found for userId:", userId);
        return res.status(403).json({ error: "You must be a registered merchant to claim places" });
      }
      console.log("[ClaimAPI] merchant:", merchant.id, merchant.businessName);

      let { placeName, district, city, country, placeCacheId, googlePlaceId } = req.body;
      console.log("[ClaimAPI] Parsed fields:", { placeName, district, city, country, placeCacheId, googlePlaceId });
      
      // Handle case where placeCacheId is actually a Google Place ID string (starts with "ChIJ")
      if (placeCacheId && typeof placeCacheId === 'string' && placeCacheId.startsWith('ChIJ')) {
        console.log("[ClaimAPI] Detected Google Place ID in placeCacheId field, moving to googlePlaceId");
        googlePlaceId = placeCacheId;
        placeCacheId = null;
      }
      
      // Ensure placeCacheId is a number if provided
      if (placeCacheId && typeof placeCacheId === 'string') {
        const parsed = parseInt(placeCacheId, 10);
        placeCacheId = isNaN(parsed) ? null : parsed;
      }
      
      if (!placeName || !district || !city || !country) {
        console.log("[ClaimAPI] Missing fields:", { placeName: !!placeName, district: !!district, city: !!city, country: !!country });
        return res.status(400).json({ error: "Missing required fields", details: { placeName: !!placeName, district: !!district, city: !!city, country: !!country } });
      }

      // Check if place is already claimed - prefer Google Place ID check
      let existingLink = null;
      if (googlePlaceId) {
        existingLink = await storage.getPlaceLinkByGooglePlaceId(googlePlaceId);
      }
      if (!existingLink) {
        existingLink = await storage.getPlaceLinkByPlace(placeName, district, city);
      }
      
      if (existingLink) {
        console.log("[ClaimAPI] Place already claimed:", existingLink.id);
        return res.status(409).json({ error: "This place is already claimed by another merchant" });
      }

      console.log("[ClaimAPI] Creating link with:", { merchantId: merchant.id, placeCacheId, googlePlaceId, placeName, district, city, country });
      const link = await storage.createMerchantPlaceLink({
        merchantId: merchant.id,
        placeCacheId: placeCacheId || null,
        googlePlaceId: googlePlaceId || null,
        placeName,
        district,
        city,
        country,
        status: 'approved'
      });

      console.log("[ClaimAPI] Link created:", link.id);
      res.json({ success: true, link });
    } catch (error: any) {
      console.error("[ClaimAPI] Error:", error.message, error.stack);
      res.status(500).json({ error: "Failed to claim place", details: error.message });
    }
  });

  app.get("/api/merchant/places", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) {
        return res.status(401).json({ error: "Authentication required" });
      }

      const merchant = await storage.getMerchantByUserId(userId);
      if (!merchant) {
        return res.status(403).json({ error: "Merchant account required" });
      }

      const links = await storage.getMerchantPlaceLinks(merchant.id);
      res.json({ places: links });
    } catch (error) {
      console.error("Get merchant places error:", error);
      res.status(500).json({ error: "Failed to get merchant places" });
    }
  });

  app.put("/api/merchant/places/:linkId", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) {
        return res.status(401).json({ error: "Authentication required" });
      }

      const merchant = await storage.getMerchantByUserId(userId);
      if (!merchant) {
        return res.status(403).json({ error: "Merchant account required" });
      }

      const linkId = parseInt(req.params.linkId);
      const { promoTitle, promoDescription, promoImageUrl, isPromoActive } = req.body;

      const updated = await storage.updateMerchantPlaceLink(linkId, {
        promoTitle,
        promoDescription,
        promoImageUrl,
        isPromoActive
      });

      res.json({ success: true, link: updated });
    } catch (error) {
      console.error("Update merchant place error:", error);
      res.status(500).json({ error: "Failed to update place" });
    }
  });

  // ============ Merchant Products Routes ============
  app.get("/api/merchant/products", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) {
        return res.status(401).json({ error: "Authentication required" });
      }

      const merchant = await storage.getMerchantByUserId(userId);
      if (!merchant) {
        return res.status(403).json({ error: "Merchant account required" });
      }

      const products = await storage.getMerchantProducts(merchant.id);
      res.json({ products });
    } catch (error) {
      console.error("Get merchant products error:", error);
      res.status(500).json({ error: "Failed to get products" });
    }
  });

  app.post("/api/merchant/products", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) {
        return res.status(401).json({ error: "Authentication required" });
      }

      const merchant = await storage.getMerchantByUserId(userId);
      if (!merchant) {
        return res.status(403).json({ error: "Merchant account required" });
      }

      const { name, description, price, category, imageUrl, stock } = req.body;
      if (!name || price === undefined) {
        return res.status(400).json({ error: "Name and price are required" });
      }

      const product = await storage.createProduct({
        merchantId: merchant.id,
        name,
        description: description || null,
        price: parseInt(price),
        currency: 'TWD',
        category: category || null,
        imageUrl: imageUrl || null,
        isActive: true,
        stock: stock ? parseInt(stock) : null
      });

      res.json({ success: true, product });
    } catch (error) {
      console.error("Create product error:", error);
      res.status(500).json({ error: "Failed to create product" });
    }
  });

  app.put("/api/merchant/products/:productId", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) {
        return res.status(401).json({ error: "Authentication required" });
      }

      const merchant = await storage.getMerchantByUserId(userId);
      if (!merchant) {
        return res.status(403).json({ error: "Merchant account required" });
      }

      const productId = parseInt(req.params.productId);
      const existing = await storage.getProductById(productId);
      if (!existing || existing.merchantId !== merchant.id) {
        return res.status(404).json({ error: "Product not found" });
      }

      const { name, description, price, category, imageUrl, isActive, stock } = req.body;
      const updated = await storage.updateProduct(productId, {
        name,
        description,
        price: price !== undefined ? parseInt(price) : undefined,
        category,
        imageUrl,
        isActive,
        stock: stock !== undefined ? parseInt(stock) : undefined
      });

      res.json({ success: true, product: updated });
    } catch (error) {
      console.error("Update product error:", error);
      res.status(500).json({ error: "Failed to update product" });
    }
  });

  app.delete("/api/merchant/products/:productId", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) {
        return res.status(401).json({ error: "Authentication required" });
      }

      const merchant = await storage.getMerchantByUserId(userId);
      if (!merchant) {
        return res.status(403).json({ error: "Merchant account required" });
      }

      const productId = parseInt(req.params.productId);
      const existing = await storage.getProductById(productId);
      if (!existing || existing.merchantId !== merchant.id) {
        return res.status(404).json({ error: "Product not found" });
      }

      await storage.deleteProduct(productId);
      res.json({ success: true });
    } catch (error) {
      console.error("Delete product error:", error);
      res.status(500).json({ error: "Failed to delete product" });
    }
  });

  // ============ Merchant Daily Code & Credits Routes ============
  
  // GET /api/merchant/daily-code - Get or generate daily verification code
  app.get("/api/merchant/daily-code", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) {
        return res.status(401).json(createErrorResponse(ErrorCode.AUTH_REQUIRED));
      }

      const merchant = await storage.getMerchantByUserId(userId);
      if (!merchant) {
        return res.status(403).json(createErrorResponse(ErrorCode.MERCHANT_REQUIRED));
      }

      const existingCode = await storage.getMerchantDailySeedCode(merchant.id);
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      
      // Check if code exists and was updated today
      if (existingCode && existingCode.updatedAt) {
        const codeDate = new Date(existingCode.updatedAt);
        codeDate.setHours(0, 0, 0, 0);
        
        if (codeDate.getTime() === today.getTime()) {
          return res.json({ 
            seedCode: existingCode.seedCode,
            updatedAt: existingCode.updatedAt,
            expiresAt: new Date(today.getTime() + 24 * 60 * 60 * 1000),
          });
        }
      }

      // Generate new daily code
      const newCode = crypto.randomBytes(4).toString('hex').toUpperCase();
      const updated = await storage.updateMerchantDailySeedCode(merchant.id, newCode);
      
      res.json({
        seedCode: newCode,
        updatedAt: updated?.codeUpdatedAt || new Date(),
        expiresAt: new Date(today.getTime() + 24 * 60 * 60 * 1000),
      });
    } catch (error) {
      console.error("Get daily code error:", error);
      res.status(500).json({ error: "取得核銷碼失敗", code: "SERVER_ERROR" });
    }
  });

  // POST /api/merchant/verify - Verify a daily code
  app.post("/api/merchant/verify", async (req, res) => {
    try {
      const verifySchema = z.object({
        merchantId: z.number(),
        code: z.string().min(1),
      });
      
      const validated = verifySchema.parse(req.body);
      
      const merchant = await storage.getMerchantById(validated.merchantId);
      if (!merchant) {
        return res.status(404).json({ ...createErrorResponse(ErrorCode.MERCHANT_NOT_FOUND), valid: false });
      }

      const existingCode = await storage.getMerchantDailySeedCode(merchant.id);
      if (!existingCode) {
        return res.status(400).json({ ...createErrorResponse(ErrorCode.NO_CODE_SET), valid: false });
      }

      // Check if code is expired (not from today)
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      const codeDate = new Date(existingCode.updatedAt);
      codeDate.setHours(0, 0, 0, 0);
      
      if (codeDate.getTime() !== today.getTime()) {
        return res.status(400).json({ ...createErrorResponse(ErrorCode.CODE_EXPIRED), valid: false });
      }

      // Verify the code
      const isValid = existingCode.seedCode.toUpperCase() === validated.code.toUpperCase();
      
      if (isValid) {
        res.json({ 
          valid: true, 
          merchantName: merchant.name,
          message: "核銷碼驗證成功" 
        });
      } else {
        res.status(400).json({ 
          error: "核銷碼錯誤", 
          code: "INVALID_CODE", 
          valid: false 
        });
      }
    } catch (error: any) {
      console.error("Verify code error:", error);
      if (error.name === 'ZodError') {
        return res.status(400).json({ error: "輸入資料格式錯誤", code: "VALIDATION_ERROR", valid: false });
      }
      res.status(500).json({ error: "驗證失敗", code: "SERVER_ERROR", valid: false });
    }
  });

  // POST /api/merchant/credits/purchase - Purchase credits with dual payment support
  app.post("/api/merchant/credits/purchase", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) {
        return res.status(401).json(createErrorResponse(ErrorCode.AUTH_REQUIRED));
      }

      const merchant = await storage.getMerchantByUserId(userId);
      if (!merchant) {
        return res.status(403).json(createErrorResponse(ErrorCode.MERCHANT_REQUIRED));
      }

      const purchaseSchema = z.object({
        amount: z.number().min(100).max(100000), // Credits to purchase
        provider: z.enum(['stripe', 'recur']),
        successUrl: z.string().url().optional(),
        cancelUrl: z.string().url().optional(),
      });

      const validated = purchaseSchema.parse(req.body);
      
      // Calculate price (1 TWD = 1 credit for simplicity)
      const price = validated.amount;

      if (validated.provider === 'stripe') {
        // Stripe payment flow
        const { stripeService } = await import('./stripeService');
        const { getStripePublishableKey } = await import('./stripeClient');
        
        const baseUrl = process.env.REPLIT_DEV_DOMAIN 
          ? `https://${process.env.REPLIT_DEV_DOMAIN}`
          : process.env.REPLIT_DOMAINS?.split(',')[0] 
            ? `https://${process.env.REPLIT_DOMAINS.split(',')[0]}`
            : 'https://localhost:5000';

        const successUrl = validated.successUrl || `${baseUrl}/merchant/credits/success?session_id={CHECKOUT_SESSION_ID}`;
        const cancelUrl = validated.cancelUrl || `${baseUrl}/merchant/credits`;

        // Create a transaction record
        const transaction = await storage.createTransaction({
          merchantId: merchant.id,
          amount: validated.amount,
          price: price,
          provider: 'stripe',
          paymentStatus: 'pending',
          paymentMethod: 'stripe_checkout',
        });

        // Create Stripe payment intent
        const paymentIntent = await stripeService.createPaymentIntent(
          price * 100, // Stripe uses cents
          'twd',
          merchant.userId,
          { 
            transactionId: transaction.id.toString(),
            merchantId: merchant.id.toString(),
            credits: validated.amount.toString(),
          }
        );

        res.json({
          provider: 'stripe',
          transactionId: transaction.id,
          clientSecret: paymentIntent.client_secret,
          publishableKey: await getStripePublishableKey(),
          amount: validated.amount,
          price: price,
        });
      } else if (validated.provider === 'recur') {
        // Recur payment flow - placeholder for actual Recur integration
        // Create a transaction record
        const transaction = await storage.createTransaction({
          merchantId: merchant.id,
          amount: validated.amount,
          price: price,
          provider: 'recur',
          paymentStatus: 'pending',
          paymentMethod: 'recur_pay',
        });

        // TODO: Integrate with Recur Helper function when available
        // For now, return the transaction details for frontend to handle
        res.json({
          provider: 'recur',
          transactionId: transaction.id,
          amount: validated.amount,
          price: price,
          message: "請使用 Recur 支付介面完成付款",
          // recurPaymentUrl would be generated here when Recur is integrated
        });
      }
    } catch (error: any) {
      console.error("Purchase credits error:", error);
      if (error.name === 'ZodError') {
        return res.status(400).json({ error: "輸入資料格式錯誤", code: "VALIDATION_ERROR" });
      }
      res.status(500).json({ error: "購買失敗", code: "SERVER_ERROR" });
    }
  });

  // POST /api/merchant/credits/confirm - Confirm payment and add credits
  app.post("/api/merchant/credits/confirm", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) {
        return res.status(401).json({ error: "Authentication required" });
      }

      const merchant = await storage.getMerchantByUserId(userId);
      if (!merchant) {
        return res.status(403).json({ error: "商家帳號必要" });
      }

      const { transactionId, externalOrderId } = req.body;
      
      const transaction = await storage.getTransactionById(transactionId);
      if (!transaction || transaction.merchantId !== merchant.id) {
        return res.status(404).json({ error: "交易不存在" });
      }

      if (transaction.paymentStatus === 'paid') {
        return res.status(400).json({ error: "此交易已完成" });
      }

      // Update transaction status
      await storage.updateTransactionStatus(transactionId, 'paid');
      
      // Add credits to merchant
      await storage.updateMerchantCreditBalance(merchant.id, transaction.amount);

      res.json({
        success: true,
        creditsAdded: transaction.amount,
        newBalance: (merchant.creditBalance || 0) + transaction.amount,
      });
    } catch (error) {
      console.error("Confirm credits error:", error);
      res.status(500).json({ error: "確認付款失敗" });
    }
  });

  // ============ Specialist Auto-Matching Routes ============
  
  // POST /api/specialist/match - Auto-match traveler with available specialist
  app.post("/api/specialist/match", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) {
        return res.status(401).json(createErrorResponse(ErrorCode.AUTH_REQUIRED));
      }

      const matchSchema = z.object({
        region: z.string().min(1),
      });

      const validated = matchSchema.parse(req.body);
      
      // Check if traveler already has an active service
      const existingService = await storage.getActiveServiceRelationByTraveler(userId);
      if (existingService) {
        const specialist = await storage.getSpecialistById(existingService.specialistId);
        return res.json({
          matched: true,
          existing: true,
          serviceId: existingService.id,
          specialist: specialist ? {
            id: specialist.id,
            name: specialist.name,
            region: specialist.serviceRegion,
          } : null,
          twilioChannelSid: existingService.twilioChannelSid,
        });
      }

      // Find available specialist in the region
      const specialist = await storage.findAvailableSpecialist(validated.region);
      
      if (!specialist) {
        return res.status(404).json({ 
          error: `目前 ${validated.region} 地區沒有可用的專員，請稍後再試`, 
          code: "NO_SPECIALIST_AVAILABLE",
          matched: false,
        });
      }

      // Create service relation
      const serviceRelation = await storage.createServiceRelation({
        specialistId: specialist.id,
        travelerId: userId,
        region: validated.region,
        status: 'active',
      });

      // Update specialist's current traveler count
      await storage.updateSpecialist(specialist.id, {
        currentTravelers: specialist.currentTravelers + 1,
      });

      res.json({
        matched: true,
        existing: false,
        serviceId: serviceRelation.id,
        specialist: {
          id: specialist.id,
          name: specialist.name,
          region: specialist.serviceRegion,
        },
        message: `已成功媒合專員 ${specialist.name}`,
      });
    } catch (error: any) {
      console.error("Specialist match error:", error);
      if (error.name === 'ZodError') {
        return res.status(400).json({ error: "輸入資料格式錯誤", code: "VALIDATION_ERROR" });
      }
      res.status(500).json({ error: "媒合失敗", code: "SERVER_ERROR" });
    }
  });

  // POST /api/specialist/service/:serviceId/end - End a service relation
  app.post("/api/specialist/service/:serviceId/end", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) {
        return res.status(401).json({ error: "Authentication required" });
      }

      const serviceId = parseInt(req.params.serviceId);
      const { rating } = req.body;

      const service = await storage.getServiceRelationById(serviceId);
      if (!service) {
        return res.status(404).json({ error: "服務不存在" });
      }

      // Verify user is part of this service
      const specialist = await storage.getSpecialistByUserId(userId);
      const isSpecialist = specialist && specialist.id === service.specialistId;
      const isTraveler = service.travelerId === userId;

      if (!isSpecialist && !isTraveler) {
        return res.status(403).json({ error: "無權限結束此服務" });
      }

      // End the service
      const endedService = await storage.endServiceRelation(serviceId, rating);

      // Decrease specialist's current traveler count
      if (specialist || service.specialistId) {
        const sp = specialist || await storage.getSpecialistById(service.specialistId);
        if (sp && sp.currentTravelers > 0) {
          await storage.updateSpecialist(sp.id, {
            currentTravelers: sp.currentTravelers - 1,
          });
        }
      }

      res.json({
        success: true,
        service: endedService,
        message: "服務已結束",
      });
    } catch (error) {
      console.error("End service error:", error);
      res.status(500).json({ error: "結束服務失敗" });
    }
  });

  // ============ Twilio Chat Routes ============
  // GET /api/chat/token - Get Twilio Conversations token for chat
  app.get("/api/chat/token", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) {
        return res.status(401).json({ error: "Authentication required" });
      }

      const accountSid = process.env.TWILIO_ACCOUNT_SID;
      const apiKeySid = process.env.TWILIO_API_KEY_SID;
      const apiKeySecret = process.env.TWILIO_API_KEY_SECRET;
      const conversationsServiceSid = process.env.TWILIO_CONVERSATIONS_SERVICE_SID;

      if (!accountSid || !apiKeySid || !apiKeySecret || !conversationsServiceSid) {
        console.error("Missing Twilio credentials");
        return res.status(500).json({ error: "Chat service not configured" });
      }

      const token = new AccessToken(accountSid, apiKeySid, apiKeySecret, {
        identity: userId,
        ttl: 3600
      });

      const chatGrant = new ChatGrant({
        serviceSid: conversationsServiceSid
      });
      token.addGrant(chatGrant);

      res.json({ 
        token: token.toJwt(),
        identity: userId
      });
    } catch (error) {
      console.error("Twilio token error:", error);
      res.status(500).json({ error: "Failed to generate chat token" });
    }
  });

  app.post("/api/chat/conversations", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) {
        return res.status(401).json({ error: "Authentication required" });
      }

      const { friendlyName, uniqueName } = req.body;
      
      const accountSid = process.env.TWILIO_ACCOUNT_SID;
      const apiKeySid = process.env.TWILIO_API_KEY_SID;
      const apiKeySecret = process.env.TWILIO_API_KEY_SECRET;
      const conversationsServiceSid = process.env.TWILIO_CONVERSATIONS_SERVICE_SID;

      if (!accountSid || !apiKeySid || !apiKeySecret || !conversationsServiceSid) {
        return res.status(500).json({ error: "Chat service not configured" });
      }

      const client = twilio(apiKeySid, apiKeySecret, { accountSid });

      const conversation = await client.conversations.v1
        .services(conversationsServiceSid)
        .conversations
        .create({
          friendlyName: friendlyName || `Trip Chat ${Date.now()}`,
          uniqueName: uniqueName || `trip_${Date.now()}_${userId.slice(0, 8)}`
        });

      // Add the creator as a participant
      await client.conversations.v1
        .services(conversationsServiceSid)
        .conversations(conversation.sid)
        .participants
        .create({ identity: userId });

      res.json({ 
        conversationSid: conversation.sid,
        friendlyName: conversation.friendlyName
      });
    } catch (error: any) {
      console.error("Create conversation error:", error);
      if (error.code === 50433) {
        return res.status(409).json({ error: "Conversation already exists" });
      }
      res.status(500).json({ error: "Failed to create conversation" });
    }
  });

  app.get("/api/chat/conversations", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) {
        return res.status(401).json({ error: "Authentication required" });
      }

      const accountSid = process.env.TWILIO_ACCOUNT_SID;
      const apiKeySid = process.env.TWILIO_API_KEY_SID;
      const apiKeySecret = process.env.TWILIO_API_KEY_SECRET;
      const conversationsServiceSid = process.env.TWILIO_CONVERSATIONS_SERVICE_SID;

      if (!accountSid || !apiKeySid || !apiKeySecret || !conversationsServiceSid) {
        return res.status(500).json({ error: "Chat service not configured" });
      }

      const client = twilio(apiKeySid, apiKeySecret, { accountSid });

      // Get all participant records for this user
      const participants = await client.conversations.v1
        .services(conversationsServiceSid)
        .participantConversations
        .list({ identity: userId, limit: 50 });

      const conversations = participants.map((p: any) => ({
        conversationSid: p.conversationSid,
        friendlyName: p.conversationFriendlyName,
        state: p.conversationState,
        unreadMessagesCount: p.unreadMessagesCount || 0
      }));

      res.json({ conversations });
    } catch (error) {
      console.error("List conversations error:", error);
      res.status(500).json({ error: "Failed to list conversations" });
    }
  });

  app.post("/api/chat/conversations/:conversationSid/join", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) {
        return res.status(401).json({ error: "Authentication required" });
      }

      const { conversationSid } = req.params;
      
      const accountSid = process.env.TWILIO_ACCOUNT_SID;
      const apiKeySid = process.env.TWILIO_API_KEY_SID;
      const apiKeySecret = process.env.TWILIO_API_KEY_SECRET;
      const conversationsServiceSid = process.env.TWILIO_CONVERSATIONS_SERVICE_SID;

      if (!accountSid || !apiKeySid || !apiKeySecret || !conversationsServiceSid) {
        return res.status(500).json({ error: "Chat service not configured" });
      }

      const client = twilio(apiKeySid, apiKeySecret, { accountSid });

      await client.conversations.v1
        .services(conversationsServiceSid)
        .conversations(conversationSid)
        .participants
        .create({ identity: userId });

      res.json({ success: true });
    } catch (error: any) {
      console.error("Join conversation error:", error);
      if (error.code === 50433) {
        return res.json({ success: true, message: "Already a participant" });
      }
      res.status(500).json({ error: "Failed to join conversation" });
    }
  });

  // Delete a conversation
  app.delete("/api/chat/conversations/:conversationSid", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) {
        return res.status(401).json({ error: "Authentication required" });
      }

      const { conversationSid } = req.params;
      const accountSid = process.env.TWILIO_ACCOUNT_SID;
      const apiKeySid = process.env.TWILIO_API_KEY_SID;
      const apiKeySecret = process.env.TWILIO_API_KEY_SECRET;
      const conversationsServiceSid = process.env.TWILIO_CONVERSATIONS_SERVICE_SID;

      if (!accountSid || !apiKeySid || !apiKeySecret || !conversationsServiceSid) {
        return res.status(500).json({ error: "Chat service not configured" });
      }

      const client = twilio(apiKeySid, apiKeySecret, { accountSid });

      await client.conversations.v1
        .services(conversationsServiceSid)
        .conversations(conversationSid)
        .remove();

      res.json({ success: true });
    } catch (error: any) {
      console.error("Delete conversation error:", error);
      res.status(500).json({ error: error.message || "Failed to delete conversation" });
    }
  });

  // Start a call in conversation
  app.post("/api/chat/conversations/:conversationSid/call", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) {
        return res.status(401).json({ error: "Authentication required" });
      }

      const { conversationSid } = req.params;
      
      // For now, we'll generate a simple call URL using Jitsi Meet (free, no API key needed)
      const roomName = `mibu-${conversationSid.replace(/[^a-zA-Z0-9]/g, '')}`;
      const callUrl = `https://meet.jit.si/${roomName}`;

      res.json({ 
        success: true,
        callUrl,
        roomName
      });
    } catch (error: any) {
      console.error("Start call error:", error);
      res.status(500).json({ error: error.message || "Failed to start call" });
    }
  });

  // ============ Twilio Unified Token (Chat + Voice) ============
  app.get("/api/token", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) {
        return res.status(401).json({ error: "Unauthorized" });
      }

      const accountSid = process.env.TWILIO_ACCOUNT_SID;
      const apiKeySid = process.env.TWILIO_API_KEY_SID;
      const apiKeySecret = process.env.TWILIO_API_KEY_SECRET;
      const conversationsServiceSid = process.env.TWILIO_CONVERSATIONS_SERVICE_SID;
      const twimlAppSid = process.env.TWILIO_TWIML_APP_SID;

      if (!accountSid || !apiKeySid || !apiKeySecret) {
        console.error("Missing Twilio credentials");
        return res.status(500).json({ error: "Twilio not configured" });
      }

      const identity = userId;

      const token = new AccessToken(accountSid, apiKeySid, apiKeySecret, {
        identity: identity,
        ttl: 3600
      });

      if (conversationsServiceSid) {
        const chatGrant = new ChatGrant({
          serviceSid: conversationsServiceSid
        });
        token.addGrant(chatGrant);
      }

      if (twimlAppSid) {
        const voiceGrant = new VoiceGrant({
          outgoingApplicationSid: twimlAppSid,
          incomingAllow: true
        });
        token.addGrant(voiceGrant);
      }

      res.json({ 
        token: token.toJwt(),
        identity: identity
      });
    } catch (error) {
      console.error("Twilio unified token error:", error);
      res.status(500).json({ error: "Failed to generate token" });
    }
  });

  // ============ Twilio Voice Webhook ============
  app.post("/api/voice/connect", (req, res) => {
    const { To } = req.body;
    const voiceResponse = new twilio.twiml.VoiceResponse();

    if (To) {
      const callerId = process.env.TWILIO_CALLER_ID;
      const dial = voiceResponse.dial({ callerId: callerId || undefined });
      dial.client(To);
    } else {
      voiceResponse.say("Invalid connection target.");
    }

    res.type('text/xml');
    res.send(voiceResponse.toString());
  });

  // Generate invite link for a conversation
  app.post("/api/chat/conversations/:conversationSid/invite-link", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) {
        return res.status(401).json({ error: "Authentication required" });
      }

      const { conversationSid } = req.params;
      
      // Generate unique invite code
      const inviteCode = `chat_${Date.now()}_${Math.random().toString(36).substring(2, 10)}`;
      const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000); // 7 days

      // Store invite in database
      await storage.createChatInvite({
        conversationSid,
        inviterUserId: userId,
        status: 'pending',
        expiresAt,
      }, inviteCode);

      const baseUrl = process.env.REPL_SLUG 
        ? `https://${process.env.REPL_SLUG}.${process.env.REPL_OWNER?.toLowerCase()}.repl.co`
        : 'http://localhost:5000';
      
      const inviteLink = `${baseUrl}/chat/join/${inviteCode}`;

      res.json({ 
        inviteLink,
        inviteCode,
        expiresAt: expiresAt.toISOString()
      });
    } catch (error) {
      console.error("Generate invite link error:", error);
      res.status(500).json({ error: "Failed to generate invite link" });
    }
  });

  // Accept chat invite
  app.post("/api/chat/invites/:inviteCode/accept", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) {
        return res.status(401).json({ error: "Authentication required" });
      }

      const { inviteCode } = req.params;
      
      // Get invite from database
      const invite = await storage.getChatInviteByCode(inviteCode);
      if (!invite) {
        return res.status(404).json({ error: "Invite not found" });
      }

      if (invite.status !== 'pending') {
        return res.status(400).json({ error: "Invite already used or expired" });
      }

      if (new Date(invite.expiresAt) < new Date()) {
        return res.status(400).json({ error: "Invite has expired" });
      }

      const accountSid = process.env.TWILIO_ACCOUNT_SID;
      const apiKeySid = process.env.TWILIO_API_KEY_SID;
      const apiKeySecret = process.env.TWILIO_API_KEY_SECRET;
      const conversationsServiceSid = process.env.TWILIO_CONVERSATIONS_SERVICE_SID;

      if (!accountSid || !apiKeySid || !apiKeySecret || !conversationsServiceSid) {
        return res.status(500).json({ error: "Chat service not configured" });
      }

      const client = twilio(apiKeySid, apiKeySecret, { accountSid });

      // Add user to conversation
      try {
        await client.conversations.v1
          .services(conversationsServiceSid)
          .conversations(invite.conversationSid)
          .participants
          .create({ identity: userId });
      } catch (err: any) {
        if (err.code !== 50433) { // Not already a participant
          throw err;
        }
      }

      // Mark invite as used
      await storage.updateChatInvite(invite.id, {
        status: 'accepted',
        usedByUserId: userId,
      });

      res.json({ 
        success: true,
        conversationSid: invite.conversationSid
      });
    } catch (error) {
      console.error("Accept invite error:", error);
      res.status(500).json({ error: "Failed to accept invite" });
    }
  });

  // ============ Klook Detection Routes ============
  
  // Detect Klook products in a message
  app.post("/api/klook/detect", isAuthenticated, async (req: any, res) => {
    try {
      const { messageText, conversationSid, messageSid } = req.body;
      
      if (!messageText || !conversationSid || !messageSid) {
        return res.status(400).json({ 
          error: "Missing required fields: messageText, conversationSid, messageSid" 
        });
      }

      const { detectKlookProducts } = await import("./klookService");
      const result = await detectKlookProducts(messageText, conversationSid, messageSid);
      
      res.json({ 
        success: true,
        products: result.products
      });
    } catch (error) {
      console.error("Klook detection error:", error);
      res.status(500).json({ error: "Failed to detect products" });
    }
  });

  // Get highlights for a specific message
  app.get("/api/klook/highlights/:conversationSid/:messageSid", isAuthenticated, async (req: any, res) => {
    try {
      const { conversationSid, messageSid } = req.params;
      
      const { getMessageHighlights } = await import("./klookService");
      const highlights = await getMessageHighlights(conversationSid, messageSid);
      
      res.json({ highlights });
    } catch (error) {
      console.error("Get highlights error:", error);
      res.status(500).json({ error: "Failed to get highlights" });
    }
  });

  // Get all highlights for a conversation
  app.get("/api/klook/highlights/:conversationSid", isAuthenticated, async (req: any, res) => {
    try {
      const { conversationSid } = req.params;
      
      const { getConversationHighlights } = await import("./klookService");
      const highlights = await getConversationHighlights(conversationSid);
      
      res.json({ highlights });
    } catch (error) {
      console.error("Get conversation highlights error:", error);
      res.status(500).json({ error: "Failed to get highlights" });
    }
  });

  // ============ Place Feedback Routes ============
  app.post("/api/feedback/exclude", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) {
        return res.status(401).json({ error: "Authentication required" });
      }

      const { placeName, district, city, placeCacheId } = req.body;
      
      if (!placeName || !district || !city) {
        return res.status(400).json({ 
          error: "Missing required fields: placeName, district, city" 
        });
      }

      const feedback = await storage.incrementPlacePenalty(
        userId,
        placeName,
        district,
        city,
        placeCacheId || undefined
      );

      res.json({
        success: true,
        message: `Place "${placeName}" has been excluded`,
        feedback: {
          id: feedback.id,
          placeName: feedback.placeName,
          penaltyScore: feedback.penaltyScore
        }
      });
    } catch (error) {
      console.error("Feedback exclusion error:", error);
      res.status(500).json({ error: "Failed to exclude place" });
    }
  });

  // ============ Commerce Routes (In-Chat Shopping) ============
  
  // Get all place names that have products (for chat message parsing)
  app.get("/api/commerce/places/names", async (req, res) => {
    try {
      const names = await storage.getPlaceNamesWithProducts();
      res.json({ names });
    } catch (error) {
      console.error("Get place names error:", error);
      res.status(500).json({ error: "Failed to get place names" });
    }
  });

  // Search places by name (for commerce matching)
  app.get("/api/commerce/places/search", async (req, res) => {
    try {
      const query = req.query.q as string;
      if (!query || query.length < 2) {
        return res.json([]);
      }
      const places = await storage.searchPlacesByName(query);
      res.json(places);
    } catch (error) {
      console.error("Place search error:", error);
      res.status(500).json({ error: "Failed to search places" });
    }
  });

  // Get products by place ID
  app.get("/api/commerce/products/place/:placeId", async (req, res) => {
    try {
      const placeId = parseInt(req.params.placeId);
      const products = await storage.getProductsByPlaceId(placeId);
      res.json(products);
    } catch (error) {
      console.error("Get products error:", error);
      res.status(500).json({ error: "Failed to get products" });
    }
  });

  // Get products by place name (for chat matching)
  app.get("/api/commerce/products/by-name", async (req, res) => {
    try {
      const placeName = req.query.name as string;
      if (!placeName) {
        return res.json({ products: [] });
      }
      const products = await storage.getProductsByPlaceName(placeName);
      res.json({ products });
    } catch (error) {
      console.error("Get products by name error:", error);
      res.status(500).json({ error: "Failed to get products" });
    }
  });

  // Get cart items
  app.get("/api/commerce/cart", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) {
        return res.status(401).json({ error: "Authentication required" });
      }
      const items = await storage.getCartItems(userId);
      res.json({ items });
    } catch (error) {
      console.error("Get cart error:", error);
      res.status(500).json({ error: "Failed to get cart" });
    }
  });

  // Add to cart
  app.post("/api/commerce/cart", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) {
        return res.status(401).json({ error: "Authentication required" });
      }
      const parsed = insertCartItemSchema.safeParse({ ...req.body, userId });
      if (!parsed.success) {
        return res.status(400).json({ error: "Invalid cart item data" });
      }
      const cartItem = await storage.addToCart(parsed.data);
      const product = await storage.getProductById(cartItem.productId);
      res.json({ item: { ...cartItem, product } });
    } catch (error) {
      console.error("Add to cart error:", error);
      res.status(500).json({ error: "Failed to add to cart" });
    }
  });

  // Update cart item quantity
  app.patch("/api/commerce/cart/:itemId", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) {
        return res.status(401).json({ error: "Authentication required" });
      }
      const itemId = parseInt(req.params.itemId);
      const { quantity } = req.body;
      if (typeof quantity !== 'number' || quantity < 1) {
        return res.status(400).json({ error: "Invalid quantity" });
      }
      const item = await storage.updateCartItemQuantity(itemId, quantity);
      res.json(item);
    } catch (error) {
      console.error("Update cart item error:", error);
      res.status(500).json({ error: "Failed to update cart item" });
    }
  });

  // Remove from cart
  app.delete("/api/commerce/cart/:itemId", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) {
        return res.status(401).json({ error: "Authentication required" });
      }
      const itemId = parseInt(req.params.itemId);
      await storage.removeFromCart(itemId);
      res.json({ success: true });
    } catch (error) {
      console.error("Remove from cart error:", error);
      res.status(500).json({ error: "Failed to remove from cart" });
    }
  });

  // Clear cart
  app.delete("/api/commerce/cart", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) {
        return res.status(401).json({ error: "Authentication required" });
      }
      await storage.clearCart(userId);
      res.json({ success: true });
    } catch (error) {
      console.error("Clear cart error:", error);
      res.status(500).json({ error: "Failed to clear cart" });
    }
  });

  // Checkout - Create Stripe session
  app.post("/api/commerce/checkout", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) {
        return res.status(401).json({ error: "Authentication required" });
      }

      const cartItems = await storage.getCartItems(userId);
      if (cartItems.length === 0) {
        return res.status(400).json({ error: "Cart is empty" });
      }

      const stripe = (await import('stripe')).default;
      const stripeClient = new stripe(process.env.STRIPE_SECRET_KEY!);

      const lineItems = cartItems.map(item => ({
        price_data: {
          currency: item.product.currency.toLowerCase(),
          product_data: {
            name: item.product.name,
            description: item.product.description || undefined,
          },
          unit_amount: item.product.price,
        },
        quantity: item.quantity,
      }));

      const totalAmount = cartItems.reduce((sum, item) => sum + item.product.price * item.quantity, 0);

      // Create order first
      const order = await storage.createOrder({
        userId,
        status: 'pending',
        totalAmount,
        currency: 'TWD',
        items: cartItems.map(item => ({
          productId: item.productId,
          name: item.product.name,
          price: item.product.price,
          quantity: item.quantity,
        })),
      });

      const session = await stripeClient.checkout.sessions.create({
        payment_method_types: ['card'],
        line_items: lineItems,
        mode: 'payment',
        success_url: `${req.headers.origin}/checkout/success?session_id={CHECKOUT_SESSION_ID}`,
        cancel_url: `${req.headers.origin}/checkout/cancel`,
        metadata: {
          orderId: order.id.toString(),
          userId,
        },
      });

      // Update order with session ID
      await storage.updateOrderStatus(order.id, 'pending', session.id);

      res.json({ sessionId: session.id, url: session.url });
    } catch (error) {
      console.error("Checkout error:", error);
      res.status(500).json({ error: "Failed to create checkout session" });
    }
  });

  // Get user orders
  app.get("/api/commerce/orders", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) {
        return res.status(401).json({ error: "Authentication required" });
      }
      const orders = await storage.getUserOrders(userId);
      res.json(orders);
    } catch (error) {
      console.error("Get orders error:", error);
      res.status(500).json({ error: "Failed to get orders" });
    }
  });

  // ============ Place Application Routes (商家地點申請) ============

  // 商家建立草稿地點
  app.post("/api/merchant/place-drafts", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) return res.status(401).json({ error: "Authentication required" });

      const merchant = await storage.getMerchantByUserId(userId);
      if (!merchant) return res.status(403).json({ error: "Merchant account required" });

      const validated = insertPlaceDraftSchema.parse({ ...req.body, merchantId: merchant.id });
      const draft = await storage.createPlaceDraft(validated);
      
      // 自動建立申請紀錄
      const application = await storage.createPlaceApplication({
        merchantId: merchant.id,
        placeDraftId: draft.id,
      });

      res.json({ draft, application });
    } catch (error) {
      if (error instanceof z.ZodError) return res.status(400).json({ error: error.errors });
      console.error("Create place draft error:", error);
      res.status(500).json({ error: "Failed to create place draft" });
    }
  });

  // 取得商家的草稿地點
  app.get("/api/merchant/place-drafts", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) return res.status(401).json({ error: "Authentication required" });

      const merchant = await storage.getMerchantByUserId(userId);
      if (!merchant) return res.status(403).json({ error: "Merchant account required" });

      const drafts = await storage.getPlaceDraftsByMerchant(merchant.id);
      res.json({ drafts });
    } catch (error) {
      console.error("Get place drafts error:", error);
      res.status(500).json({ error: "Failed to get place drafts" });
    }
  });

  // 取得商家的申請紀錄
  app.get("/api/merchant/applications", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) return res.status(401).json({ error: "Authentication required" });

      const merchant = await storage.getMerchantByUserId(userId);
      if (!merchant) return res.status(403).json({ error: "Merchant account required" });

      const applications = await storage.getPlaceApplicationsByMerchant(merchant.id);
      res.json({ applications });
    } catch (error) {
      console.error("Get applications error:", error);
      res.status(500).json({ error: "Failed to get applications" });
    }
  });

  // 管理員：取得待審核申請（包含草稿和商家詳情）
  app.get("/api/admin/applications/pending", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) return res.status(401).json({ error: "Authentication required" });

      const user = await storage.getUser(userId);
      if (user?.role !== 'admin') return res.status(403).json({ error: "Admin access required" });

      const applications = await storage.getPendingApplicationsWithDetails();
      res.json({ applications });
    } catch (error) {
      console.error("Get pending applications error:", error);
      res.status(500).json({ error: "Failed to get pending applications" });
    }
  });

  // 管理員：審核申請（通過/退回）
  app.patch("/api/admin/applications/:id/review", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) return res.status(401).json({ error: "Authentication required" });

      const user = await storage.getUser(userId);
      if (user?.role !== 'admin') return res.status(403).json({ error: "Admin access required" });

      const applicationId = parseInt(req.params.id);
      const { status, reviewNotes } = req.body;

      if (!['approved', 'rejected'].includes(status)) {
        return res.status(400).json({ error: "Status must be 'approved' or 'rejected'" });
      }

      const application = await storage.getPlaceApplicationById(applicationId);
      if (!application) return res.status(404).json({ error: "Application not found" });

      // 更新申請狀態
      const updated = await storage.updatePlaceApplication(applicationId, {
        status,
        reviewedBy: userId,
        reviewedAt: new Date(),
        reviewNotes,
      });

      // 同時更新草稿狀態
      await storage.updatePlaceDraft(application.placeDraftId, { status });

      // 如果通過，將地點發布到 place_cache
      if (status === 'approved') {
        const draft = await storage.getPlaceDraftById(application.placeDraftId);
        if (draft) {
          const districtInfo = await storage.getDistrictWithParents(draft.districtId);
          if (districtInfo) {
            const categories = await storage.getCategories();
            const category = categories.find(c => c.id === draft.categoryId);
            const subcategories = await storage.getSubcategoriesByCategory(draft.categoryId);
            const subcategory = subcategories.find(s => s.id === draft.subcategoryId);

            const newPlace = await storage.savePlaceToCache({
              placeName: draft.placeName,
              description: draft.description || '',
              category: category?.code || '',
              subCategory: subcategory?.nameZh || '',
              district: districtInfo.district.nameZh,
              city: districtInfo.region.nameZh,
              country: districtInfo.country.nameZh,
              placeId: draft.googlePlaceId || undefined,
              locationLat: draft.locationLat || undefined,
              locationLng: draft.locationLng || undefined,
              verifiedAddress: draft.address || undefined,
            });

            // 更新申請紀錄的 placeCacheId
            await storage.updatePlaceApplication(applicationId, { placeCacheId: newPlace.id });

            // 自動建立商家認領連結
            await storage.createMerchantPlaceLink({
              merchantId: application.merchantId,
              placeCacheId: newPlace.id,
              googlePlaceId: draft.googlePlaceId || undefined,
              placeName: draft.placeName,
              district: districtInfo.district.nameZh,
              city: districtInfo.region.nameZh,
              country: districtInfo.country.nameZh,
              status: 'approved',
            });
          }
        }
      }

      res.json({ application: updated });
    } catch (error) {
      console.error("Review application error:", error);
      res.status(500).json({ error: "Failed to review application" });
    }
  });

  // ============ Admin Place Draft Routes (管理員地點草稿) ============

  // 管理員：建立草稿地點（無需商家帳號）
  app.post("/api/admin/place-drafts", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) return res.status(401).json({ error: "Authentication required" });

      const user = await storage.getUser(userId);
      if (user?.role !== 'admin') return res.status(403).json({ error: "Admin access required" });

      const validated = insertPlaceDraftSchema.parse({ ...req.body, source: 'ai' });
      const draft = await storage.createPlaceDraft(validated);

      res.json({ draft });
    } catch (error) {
      if (error instanceof z.ZodError) return res.status(400).json({ error: error.errors });
      console.error("Admin create place draft error:", error);
      res.status(500).json({ error: "Failed to create place draft" });
    }
  });

  // 管理員：取得所有草稿地點
  app.get("/api/admin/place-drafts", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) return res.status(401).json({ error: "Authentication required" });

      const user = await storage.getUser(userId);
      if (user?.role !== 'admin') return res.status(403).json({ error: "Admin access required" });

      const drafts = await storage.getAllPlaceDrafts();
      res.json({ drafts });
    } catch (error) {
      console.error("Admin get place drafts error:", error);
      res.status(500).json({ error: "Failed to get place drafts" });
    }
  });

  // 管理員：直接發布草稿到行程卡池（跳過申請流程）
  app.post("/api/admin/place-drafts/:id/publish", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) return res.status(401).json({ error: "Authentication required" });

      const user = await storage.getUser(userId);
      if (user?.role !== 'admin') return res.status(403).json({ error: "Admin access required" });

      const draftId = parseInt(req.params.id);
      const draft = await storage.getPlaceDraftById(draftId);
      if (!draft) return res.status(404).json({ error: "Draft not found" });

      const districtInfo = await storage.getDistrictWithParents(draft.districtId);
      if (!districtInfo) return res.status(400).json({ error: "Invalid district" });

      const categories = await storage.getCategories();
      const category = categories.find(c => c.id === draft.categoryId);
      const subcategories = await storage.getSubcategoriesByCategory(draft.categoryId);
      const subcategory = subcategories.find(s => s.id === draft.subcategoryId);

      const newPlace = await storage.savePlaceToCache({
        placeName: draft.placeName,
        description: draft.description || '',
        category: category?.code || '',
        subCategory: subcategory?.nameZh || '',
        district: districtInfo.district.nameZh,
        city: districtInfo.region.nameZh,
        country: districtInfo.country.nameZh,
        placeId: draft.googlePlaceId || undefined,
        locationLat: draft.locationLat || undefined,
        locationLng: draft.locationLng || undefined,
        verifiedAddress: draft.address || undefined,
      });

      // 發布後從 drafts 刪除（不只是標記 approved）
      await storage.deletePlaceDraft(draftId);

      res.json({ placeCache: newPlace, published: true });
    } catch (error) {
      console.error("Admin publish place draft error:", error);
      res.status(500).json({ error: "Failed to publish place draft" });
    }
  });

  // 管理員：刪除草稿地點
  app.delete("/api/admin/place-drafts/:id", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) return res.status(401).json({ error: "Authentication required" });

      const user = await storage.getUser(userId);
      if (user?.role !== 'admin') return res.status(403).json({ error: "Admin access required" });

      const draftId = parseInt(req.params.id);
      const draft = await storage.getPlaceDraftById(draftId);
      if (!draft) return res.status(404).json({ error: "Draft not found" });

      // 刪除前先存入 place_feedback 排除表，避免 AI 再次生成
      const districtInfo = await storage.getDistrictWithParents(draft.districtId);
      if (districtInfo) {
        await storage.createPlaceFeedback({
          userId: userId,
          placeName: draft.placeName,
          district: districtInfo.district.nameZh,
          city: districtInfo.region.nameZh,
          penaltyScore: 100, // 高分代表完全排除
        });
      }

      await storage.deletePlaceDraft(draftId);
      res.json({ success: true, message: "Draft deleted and added to exclusion list" });
    } catch (error: any) {
      console.error("Error deleting draft:", error);
      res.status(500).json({ error: "Failed to delete draft" });
    }
  });

  // 管理員：更新草稿地點（名稱、描述）
  app.patch("/api/admin/place-drafts/:id", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) return res.status(401).json({ error: "Authentication required" });

      const user = await storage.getUser(userId);
      if (user?.role !== 'admin') return res.status(403).json({ error: "Admin access required" });

      const draftId = parseInt(req.params.id);
      const draft = await storage.getPlaceDraftById(draftId);
      if (!draft) return res.status(404).json({ error: "Draft not found" });

      const updateSchema = z.object({
        placeName: z.string().min(1).optional(),
        description: z.string().optional(),
      });

      const validated = updateSchema.parse(req.body);
      const updated = await storage.updatePlaceDraft(draftId, validated);
      res.json({ draft: updated });
    } catch (error) {
      if (error instanceof z.ZodError) return res.status(400).json({ error: error.errors });
      console.error("Admin update place draft error:", error);
      res.status(500).json({ error: "Failed to update place draft" });
    }
  });

  // 管理員：用 AI 重新生成草稿描述
  app.post("/api/admin/place-drafts/:id/regenerate-description", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) return res.status(401).json({ error: "Authentication required" });

      const user = await storage.getUser(userId);
      if (user?.role !== 'admin') return res.status(403).json({ error: "Admin access required" });

      const draftId = parseInt(req.params.id);
      const draft = await storage.getPlaceDraftById(draftId);
      if (!draft) return res.status(404).json({ error: "Draft not found" });

      const districtInfo = await storage.getDistrictWithParents(draft.districtId);
      const categories = await storage.getCategories();
      const category = categories.find(c => c.id === draft.categoryId);
      const subcategories = await storage.getSubcategoriesByCategory(draft.categoryId);
      const subcategory = subcategories.find(s => s.id === draft.subcategoryId);

      const prompt = `你是一位專業的旅遊作家。請為以下景點撰寫一段吸引觀光客的介紹文字（繁體中文，50-100字）：

景點名稱：${draft.placeName}
類別：${category?.nameZh || ''} / ${subcategory?.nameZh || ''}
地區：${districtInfo?.country?.nameZh || ''} ${districtInfo?.region?.nameZh || ''} ${districtInfo?.district?.nameZh || ''}
${draft.address ? `地址：${draft.address}` : ''}

請直接輸出介紹文字，不需要標題或其他格式。文字應該生動有趣，突出景點特色，吸引遊客前往。`;

      const newDescription = await callGemini(prompt);
      const cleanDescription = newDescription.trim();

      const updated = await storage.updatePlaceDraft(draftId, { description: cleanDescription });
      res.json({ draft: updated, description: cleanDescription });
    } catch (error) {
      console.error("Admin regenerate description error:", error);
      res.status(500).json({ error: "Failed to regenerate description" });
    }
  });

  // 管理員：篩選草稿地點（支援星級/評論數篩選）
  app.get("/api/admin/place-drafts/filter", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) return res.status(401).json({ error: "Authentication required" });

      const user = await storage.getUser(userId);
      if (user?.role !== 'admin') return res.status(403).json({ error: "Admin access required" });

      const minRating = req.query.minRating ? parseFloat(req.query.minRating) : undefined;
      const minReviewCount = req.query.minReviewCount ? parseInt(req.query.minReviewCount) : undefined;
      const status = req.query.status || 'pending';

      const drafts = await storage.getFilteredPlaceDrafts({ minRating, minReviewCount, status });
      
      res.json({ 
        drafts,
        filters: { minRating, minReviewCount, status },
        count: drafts.length
      });
    } catch (error) {
      console.error("Admin filter place drafts error:", error);
      res.status(500).json({ error: "Failed to filter place drafts" });
    }
  });

  // 管理員：一鍵批次發布（支援篩選條件）
  app.post("/api/admin/place-drafts/batch-publish", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) return res.status(401).json({ error: "Authentication required" });

      const user = await storage.getUser(userId);
      if (user?.role !== 'admin') return res.status(403).json({ error: "Admin access required" });

      const batchPublishSchema = z.object({
        minRating: z.number().min(0).max(5).optional(),
        minReviewCount: z.number().min(0).optional(),
        ids: z.array(z.number()).optional(), // 可選：指定 ID 列表
      });

      const validated = batchPublishSchema.parse(req.body);
      
      // 取得符合條件的草稿
      let draftsToPublish;
      if (validated.ids && validated.ids.length > 0) {
        // 使用指定的 ID 列表
        const allDrafts = await storage.getFilteredPlaceDrafts({ status: 'pending' });
        draftsToPublish = allDrafts.filter(d => validated.ids!.includes(d.id));
      } else {
        // 使用篩選條件
        draftsToPublish = await storage.getFilteredPlaceDrafts({
          minRating: validated.minRating,
          minReviewCount: validated.minReviewCount,
          status: 'pending'
        });
      }

      if (draftsToPublish.length === 0) {
        return res.json({ success: true, published: 0, message: "No drafts match the criteria" });
      }

      const categories = await storage.getCategories();
      const publishedIds: number[] = [];
      const errors: Array<{ id: number; placeName: string; error: string }> = [];

      for (const draft of draftsToPublish) {
        try {
          const districtInfo = await storage.getDistrictWithParents(draft.districtId);
          if (!districtInfo) {
            errors.push({ id: draft.id, placeName: draft.placeName, error: "Invalid district" });
            continue;
          }

          const category = categories.find(c => c.id === draft.categoryId);
          const subcategories = await storage.getSubcategoriesByCategory(draft.categoryId);
          const subcategory = subcategories.find(s => s.id === draft.subcategoryId);

          await storage.savePlaceToCache({
            placeName: draft.placeName,
            description: draft.description || '',
            category: category?.code || '',
            subCategory: subcategory?.nameZh || '',
            district: districtInfo.district.nameZh,
            city: districtInfo.region.nameZh,
            country: districtInfo.country.nameZh,
            placeId: draft.googlePlaceId || undefined,
            locationLat: draft.locationLat || undefined,
            locationLng: draft.locationLng || undefined,
            verifiedAddress: draft.address || undefined,
          });

          publishedIds.push(draft.id);
        } catch (e: any) {
          errors.push({ id: draft.id, placeName: draft.placeName, error: e.message });
        }
      }

      // 批次刪除已發布的草稿
      if (publishedIds.length > 0) {
        await storage.batchDeletePlaceDrafts(publishedIds);
      }

      res.json({
        success: true,
        published: publishedIds.length,
        failed: errors.length,
        errors: errors.length > 0 ? errors : undefined,
        message: `Successfully published ${publishedIds.length} places`
      });
    } catch (error) {
      if (error instanceof z.ZodError) return res.status(400).json({ error: error.errors });
      console.error("Admin batch publish error:", error);
      res.status(500).json({ error: "Failed to batch publish" });
    }
  });

  // 管理員：批次 AI 重新生成描述
  app.post("/api/admin/place-drafts/batch-regenerate", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) return res.status(401).json({ error: "Authentication required" });

      const user = await storage.getUser(userId);
      if (user?.role !== 'admin') return res.status(403).json({ error: "Admin access required" });

      const { ids, filter } = req.body as {
        ids?: number[];
        filter?: { minRating?: number; minReviewCount?: number };
      };

      let draftsToRegenerate: PlaceDraft[] = [];

      if (ids && ids.length > 0) {
        const allDrafts = await storage.getAllPlaceDrafts();
        draftsToRegenerate = allDrafts.filter(d => ids.includes(d.id) && d.status === 'pending');
      } else if (filter) {
        draftsToRegenerate = await storage.getFilteredPlaceDrafts({
          ...filter,
          status: 'pending'
        });
      } else {
        return res.status(400).json({ error: "必須提供 ids 或 filter 參數" });
      }

      if (draftsToRegenerate.length === 0) {
        return res.json({ success: true, regenerated: 0, failed: 0, message: "沒有符合條件的草稿" });
      }

      // 預載分類和地區資料以提高效率
      const categories = await storage.getCategories();
      const allSubcategories: Map<number, Subcategory[]> = new Map();

      const regeneratedIds: number[] = [];
      const errors: { id: number; placeName: string; error: string }[] = [];

      for (const draft of draftsToRegenerate) {
        try {
          // 取得地區資訊
          const districtInfo = await storage.getDistrictWithParents(draft.districtId);
          const category = categories.find(c => c.id === draft.categoryId);
          
          // 快取子分類
          if (!allSubcategories.has(draft.categoryId)) {
            const subs = await storage.getSubcategoriesByCategory(draft.categoryId);
            allSubcategories.set(draft.categoryId, subs);
          }
          const subcategory = allSubcategories.get(draft.categoryId)?.find(s => s.id === draft.subcategoryId);

          // 使用更詳細的 prompt 生成更好的描述
          const prompt = `你是一位資深的旅遊作家和行銷專家。請為以下景點撰寫一段精彩、生動、吸引人的介紹文字。

景點名稱：${draft.placeName}
類別：${category?.nameZh || ''} / ${subcategory?.nameZh || ''}
地區：${districtInfo?.country?.nameZh || ''} ${districtInfo?.region?.nameZh || ''} ${districtInfo?.district?.nameZh || ''}
${draft.address ? `地址：${draft.address}` : ''}
${draft.googleRating ? `Google評分：${draft.googleRating}星` : ''}

撰寫要求：
1. 字數：80-120字（繁體中文）
2. 風格：生動活潑，富有感染力
3. 內容：突出景點特色、獨特體驗、推薦理由
4. 語氣：像是當地人熱情推薦給好友的口吻
5. 避免：空洞的形容詞堆砌，要有具體的描述

請直接輸出介紹文字，不需要標題或其他格式。`;

          const newDescription = await callGemini(prompt);
          const cleanDescription = newDescription.trim();

          await storage.updatePlaceDraft(draft.id, { description: cleanDescription });
          regeneratedIds.push(draft.id);
          
          console.log(`[BatchRegenerate] Regenerated description for: ${draft.placeName}`);
        } catch (e: any) {
          console.error(`[BatchRegenerate] Failed for ${draft.placeName}:`, e.message);
          errors.push({ id: draft.id, placeName: draft.placeName, error: e.message });
        }
      }

      res.json({
        success: true,
        regenerated: regeneratedIds.length,
        failed: errors.length,
        regeneratedIds,
        errors: errors.length > 0 ? errors : undefined,
        message: `成功重新生成 ${regeneratedIds.length} 筆描述`
      });
    } catch (error) {
      console.error("Admin batch regenerate error:", error);
      res.status(500).json({ error: "批次重新生成失敗" });
    }
  });

  // 管理員：回填現有草稿的 Google 評論數
  app.post("/api/admin/place-drafts/backfill-review-count", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) return res.status(401).json({ error: "Authentication required" });

      const user = await storage.getUser(userId);
      if (user?.role !== 'admin') return res.status(403).json({ error: "Admin access required" });

      const { limit = 50 } = req.body as { limit?: number };

      // 取得沒有評論數的待審核草稿
      const allDrafts = await storage.getAllPlaceDrafts();
      const draftsToUpdate = allDrafts.filter(d => 
        d.status === 'pending' && 
        d.googleReviewCount === null && 
        d.googlePlaceId
      ).slice(0, limit);

      if (draftsToUpdate.length === 0) {
        return res.json({ success: true, updated: 0, failed: 0, message: "沒有需要回填的草稿" });
      }

      const updatedIds: number[] = [];
      const errors: { id: number; placeName: string; error: string }[] = [];

      for (const draft of draftsToUpdate) {
        try {
          // 使用 Place Details API 取得評論數
          const GOOGLE_MAPS_API_KEY = process.env.GOOGLE_MAPS_API_KEY;
          if (!GOOGLE_MAPS_API_KEY) {
            throw new Error("GOOGLE_MAPS_API_KEY not configured");
          }

          const url = `https://maps.googleapis.com/maps/api/place/details/json?place_id=${draft.googlePlaceId}&fields=user_ratings_total,rating&key=${GOOGLE_MAPS_API_KEY}&language=zh-TW`;
          const response = await fetch(url);
          const data = await response.json();

          if (data.status === 'OK' && data.result) {
            const updateData: any = {};
            if (data.result.user_ratings_total !== undefined) {
              updateData.googleReviewCount = data.result.user_ratings_total;
            }
            if (data.result.rating !== undefined && draft.googleRating === null) {
              updateData.googleRating = data.result.rating;
            }

            if (Object.keys(updateData).length > 0) {
              await storage.updatePlaceDraft(draft.id, updateData);
              updatedIds.push(draft.id);
              console.log(`[BackfillReviewCount] Updated ${draft.placeName}: reviewCount=${updateData.googleReviewCount}`);
            }
          } else {
            console.log(`[BackfillReviewCount] No data for ${draft.placeName}: ${data.status}`);
          }

          // 避免 API 速率限制
          await new Promise(resolve => setTimeout(resolve, 100));
        } catch (e: any) {
          console.error(`[BackfillReviewCount] Failed for ${draft.placeName}:`, e.message);
          errors.push({ id: draft.id, placeName: draft.placeName, error: e.message });
        }
      }

      res.json({
        success: true,
        updated: updatedIds.length,
        failed: errors.length,
        remaining: allDrafts.filter(d => d.status === 'pending' && d.googleReviewCount === null && d.googlePlaceId).length - updatedIds.length,
        errors: errors.length > 0 ? errors : undefined,
        message: `成功回填 ${updatedIds.length} 筆評論數`
      });
    } catch (error) {
      console.error("Admin backfill review count error:", error);
      res.status(500).json({ error: "回填評論數失敗" });
    }
  });

  // 管理員：批次 AI 審核快取資料
  app.post("/api/admin/place-cache/batch-review", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) return res.status(401).json({ error: "Authentication required" });

      const user = await storage.getUser(userId);
      if (user?.role !== 'admin') return res.status(403).json({ error: "Admin access required" });

      const { limit = 50 } = req.body as { limit?: number };

      // 取得尚未審核的快取資料
      const unreviewed = await storage.getUnreviewedPlaceCache(limit);
      
      if (unreviewed.length === 0) {
        const stats = await storage.getPlaceCacheReviewStats();
        return res.json({ 
          success: true, 
          reviewed: 0, 
          passed: 0,
          deleted: 0,
          remaining: 0,
          stats,
          message: "所有快取資料都已審核完成" 
        });
      }

      const passedIds: number[] = [];
      const movedToDraftIds: number[] = [];
      const errors: { id: number; placeName: string; error: string }[] = [];

      // 預載分類和地區資料以提高效率
      const categories = await storage.getCategories();
      const allSubcategories = await storage.getAllSubcategoriesWithCategory();

      for (const place of unreviewed) {
        try {
          const reviewResult = await reviewPlaceWithAI(
            place.placeName,
            place.description,
            place.category,
            place.subCategory,
            place.district,
            place.city
          );

          console.log(`[CacheReview] ${place.placeName}: ${reviewResult.passed ? 'PASS' : 'FAIL'} - ${reviewResult.reason} (confidence: ${reviewResult.confidence})`);

          if (reviewResult.passed && reviewResult.confidence >= 0.6) {
            // 通過審核，標記為已審核
            await storage.markPlaceCacheReviewed(place.id, true);
            passedIds.push(place.id);
          } else {
            // 未通過審核，移至草稿表並記錄原因
            // 查找對應的分類 ID（place_cache 現在使用英文 code）
            const category = categories.find(c => c.code === place.category);
            const subcategory = allSubcategories.find(s => s.nameZh === place.subCategory);
            
            // 查找對應的地區 ID
            const districtInfo = await storage.getDistrictByNames(place.district, place.city, place.country);
            
            if (districtInfo) {
              // 建立草稿，包含退回原因
              const rejectionNote = `[AI審核不通過] ${reviewResult.reason} (信心度: ${(reviewResult.confidence * 100).toFixed(0)}%)`;
              
              await storage.createPlaceDraft({
                source: 'ai',
                placeName: place.placeName,
                description: `${rejectionNote}\n\n原描述：${place.description}`,
                categoryId: category?.id || 1,
                subcategoryId: subcategory?.id || 1,
                districtId: districtInfo.district.id,
                regionId: districtInfo.region.id,
                countryId: districtInfo.country.id,
                address: place.verifiedAddress || undefined,
                googlePlaceId: place.placeId || undefined,
                googleRating: place.googleRating ? parseFloat(place.googleRating) : undefined,
                locationLat: place.locationLat || undefined,
                locationLng: place.locationLng || undefined,
                status: 'pending', // 設為人工待審
              });
              
              // 刪除快取中的記錄
              await storage.deletePlaceCache(place.id);
              movedToDraftIds.push(place.id);
              console.log(`[CacheReview] Moved to drafts: ${place.placeName} - ${reviewResult.reason}`);
            } else {
              // 找不到地區資訊，標記為已審核但失敗
              await storage.markPlaceCacheReviewed(place.id, true);
              errors.push({ id: place.id, placeName: place.placeName, error: `找不到地區資訊: ${place.district}, ${place.city}` });
            }
          }

          // 避免 API 速率限制
          await new Promise(resolve => setTimeout(resolve, 200));
        } catch (e: any) {
          console.error(`[CacheReview] Error for ${place.placeName}:`, e.message);
          errors.push({ id: place.id, placeName: place.placeName, error: e.message });
        }
      }

      const stats = await storage.getPlaceCacheReviewStats();

      res.json({
        success: true,
        reviewed: passedIds.length + movedToDraftIds.length,
        passed: passedIds.length,
        movedToDraft: movedToDraftIds.length,
        remaining: stats.unreviewed,
        stats,
        errors: errors.length > 0 ? errors : undefined,
        message: `審核完成：${passedIds.length} 筆通過，${movedToDraftIds.length} 筆移至草稿`
      });
    } catch (error) {
      console.error("Admin cache review error:", error);
      res.status(500).json({ error: "快取審核失敗" });
    }
  });

  // 管理員：取得快取審核統計
  app.get("/api/admin/place-cache/review-stats", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) return res.status(401).json({ error: "Authentication required" });

      const user = await storage.getUser(userId);
      if (user?.role !== 'admin') return res.status(403).json({ error: "Admin access required" });

      const stats = await storage.getPlaceCacheReviewStats();
      res.json(stats);
    } catch (error) {
      console.error("Get cache review stats error:", error);
      res.status(500).json({ error: "Failed to get review stats" });
    }
  });

  // ============ Admin User Management Routes ============

  // 管理員：取得待審核用戶
  app.get("/api/admin/users/pending", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) return res.status(401).json({ error: "Authentication required" });

      const user = await storage.getUser(userId);
      if (user?.role !== 'admin') return res.status(403).json({ error: "Admin access required" });

      const pendingUsers = await storage.getPendingApprovalUsers();
      res.json({ 
        users: pendingUsers.map(u => ({
          id: u.id,
          email: u.email,
          firstName: u.firstName,
          lastName: u.lastName,
          role: u.role,
          provider: u.provider,
          isApproved: u.isApproved,
          createdAt: u.createdAt,
        }))
      });
    } catch (error) {
      console.error("Get pending users error:", error);
      res.status(500).json({ error: "Failed to get pending users" });
    }
  });

  // 管理員：審核用戶（通過/拒絕）
  app.patch("/api/admin/users/:id/approve", isAuthenticated, async (req: any, res) => {
    try {
      const adminId = req.user?.claims?.sub;
      if (!adminId) return res.status(401).json({ error: "Authentication required" });

      const admin = await storage.getUser(adminId);
      if (admin?.role !== 'admin') return res.status(403).json({ error: "Admin access required" });

      const targetUserId = req.params.id;
      const { approved } = req.body;

      if (typeof approved !== 'boolean') {
        return res.status(400).json({ error: "approved must be a boolean" });
      }

      const targetUser = await storage.getUser(targetUserId);
      if (!targetUser) return res.status(404).json({ error: "User not found" });

      const updated = await storage.updateUser(targetUserId, { isApproved: approved });
      res.json({ 
        success: true, 
        user: {
          id: updated?.id,
          email: updated?.email,
          role: updated?.role,
          isApproved: updated?.isApproved,
        }
      });
    } catch (error) {
      console.error("Approve user error:", error);
      res.status(500).json({ error: "Failed to approve user" });
    }
  });

  // 管理員：取得所有用戶
  app.get("/api/admin/users", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) return res.status(401).json({ error: "Authentication required" });

      const user = await storage.getUser(userId);
      if (user?.role !== 'admin') return res.status(403).json({ error: "Admin access required" });

      const allUsers = await storage.getAllUsers();
      res.json({ 
        users: allUsers.map(u => ({
          id: u.id,
          email: u.email,
          firstName: u.firstName,
          lastName: u.lastName,
          role: u.role,
          provider: u.provider,
          isApproved: u.isApproved,
          isActive: u.isActive,
          createdAt: u.createdAt,
        }))
      });
    } catch (error) {
      console.error("Get all users error:", error);
      res.status(500).json({ error: "Failed to get users" });
    }
  });

  // ============ Admin Global Exclusions (全域排除地點) ============

  // 取得全域排除清單
  app.get("/api/admin/global-exclusions", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) return res.status(401).json({ error: "Authentication required" });

      const user = await storage.getUser(userId);
      if (user?.role !== 'admin') return res.status(403).json({ error: "Admin access required" });

      const { district, city } = req.query;
      const exclusions = await storage.getGlobalExclusions(
        district as string | undefined,
        city as string | undefined
      );
      res.json({ exclusions });
    } catch (error) {
      console.error("Get global exclusions error:", error);
      res.status(500).json({ error: "Failed to get global exclusions" });
    }
  });

  // 新增全域排除地點
  app.post("/api/admin/global-exclusions", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) return res.status(401).json({ error: "Authentication required" });

      const user = await storage.getUser(userId);
      if (user?.role !== 'admin') return res.status(403).json({ error: "Admin access required" });

      const schema = z.object({
        placeName: z.string().min(1),
        district: z.string().min(1),
        city: z.string().min(1),
      });

      const validated = schema.parse(req.body);
      const exclusion = await storage.addGlobalExclusion(validated);
      res.json({ success: true, exclusion });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ error: error.errors });
      }
      console.error("Add global exclusion error:", error);
      res.status(500).json({ error: "Failed to add global exclusion" });
    }
  });

  // 移除全域排除地點
  app.delete("/api/admin/global-exclusions/:id", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) return res.status(401).json({ error: "Authentication required" });

      const user = await storage.getUser(userId);
      if (user?.role !== 'admin') return res.status(403).json({ error: "Admin access required" });

      const exclusionId = parseInt(req.params.id);
      const removed = await storage.removeGlobalExclusion(exclusionId);
      
      if (!removed) {
        return res.status(404).json({ error: "Exclusion not found" });
      }
      
      res.json({ success: true, message: "Global exclusion removed" });
    } catch (error) {
      console.error("Remove global exclusion error:", error);
      res.status(500).json({ error: "Failed to remove global exclusion" });
    }
  });

  // ============ Announcements & Events API (公告與活動管理) ============
  
  // Helper: Check if user has admin access (via activeRole or super admin)
  const hasAdminAccess = async (req: any): Promise<boolean> => {
    const userId = req.user?.claims?.sub;
    if (!userId) return false;
    
    const user = await storage.getUser(userId);
    if (!user) return false;
    
    const SUPER_ADMIN_EMAIL = 's8869420@gmail.com';
    const isSuperAdmin = user.email === SUPER_ADMIN_EMAIL;
    
    // Get activeRole from JWT or session
    const activeRole = req.jwtUser?.activeRole || (req.session as any)?.activeRole || user.role;
    
    // Allow if super admin or activeRole is 'admin'
    return isSuperAdmin || activeRole === 'admin';
  };

  // 取得所有公告 (管理端)
  app.get("/api/admin/announcements", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) return res.status(401).json({ error: "Authentication required" });

      if (!(await hasAdminAccess(req))) {
        return res.status(403).json({ error: "Admin access required" });
      }

      const announcements = await storage.getAllAnnouncements();
      res.json({ announcements });
    } catch (error) {
      console.error("Get announcements error:", error);
      res.status(500).json({ error: "Failed to get announcements" });
    }
  });

  // 取得有效的公告 (前台用)
  app.get("/api/announcements", async (req: any, res) => {
    try {
      const { type } = req.query;
      const validTypes = ['announcement', 'flash_event', 'holiday_event'];
      const announcementType = validTypes.includes(type as string) ? type as 'announcement' | 'flash_event' | 'holiday_event' : undefined;
      
      const announcements = await storage.getActiveAnnouncements(announcementType);
      res.json({ announcements });
    } catch (error) {
      console.error("Get active announcements error:", error);
      res.status(500).json({ error: "Failed to get announcements" });
    }
  });

  // 新增公告/活動
  app.post("/api/admin/announcements", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) return res.status(401).json({ error: "Authentication required" });

      if (!(await hasAdminAccess(req))) {
        return res.status(403).json({ error: "Admin access required" });
      }

      const schema = z.object({
        type: z.enum(['announcement', 'flash_event', 'holiday_event']).default('announcement'),
        title: z.string().min(1),
        content: z.string().min(1),
        imageUrl: z.string().url().optional().nullable(),
        linkUrl: z.string().url().optional().nullable(),
        startDate: z.string().datetime().optional(),
        endDate: z.string().datetime().optional().nullable(),
        isActive: z.boolean().default(true),
        priority: z.number().int().default(0),
      });

      const validated = schema.parse(req.body);
      
      const announcement = await storage.createAnnouncement({
        ...validated,
        startDate: validated.startDate ? new Date(validated.startDate) : new Date(),
        endDate: validated.endDate ? new Date(validated.endDate) : null,
        createdBy: userId,
      });
      
      res.json({ success: true, announcement });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ error: error.errors });
      }
      console.error("Create announcement error:", error);
      res.status(500).json({ error: "Failed to create announcement" });
    }
  });

  // 更新公告/活動
  app.patch("/api/admin/announcements/:id", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) return res.status(401).json({ error: "Authentication required" });

      if (!(await hasAdminAccess(req))) {
        return res.status(403).json({ error: "Admin access required" });
      }

      const announcementId = parseInt(req.params.id);
      const schema = z.object({
        type: z.enum(['announcement', 'flash_event', 'holiday_event']).optional(),
        title: z.string().min(1).optional(),
        content: z.string().min(1).optional(),
        imageUrl: z.string().url().optional().nullable(),
        linkUrl: z.string().url().optional().nullable(),
        startDate: z.string().datetime().optional(),
        endDate: z.string().datetime().optional().nullable(),
        isActive: z.boolean().optional(),
        priority: z.number().int().optional(),
      });

      const validated = schema.parse(req.body);
      
      const updateData: any = { ...validated };
      if (validated.startDate) updateData.startDate = new Date(validated.startDate);
      if (validated.endDate) updateData.endDate = new Date(validated.endDate);
      
      const announcement = await storage.updateAnnouncement(announcementId, updateData);
      
      if (!announcement) {
        return res.status(404).json({ error: "Announcement not found" });
      }
      
      res.json({ success: true, announcement });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ error: error.errors });
      }
      console.error("Update announcement error:", error);
      res.status(500).json({ error: "Failed to update announcement" });
    }
  });

  // 刪除公告/活動
  app.delete("/api/admin/announcements/:id", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) return res.status(401).json({ error: "Authentication required" });

      if (!(await hasAdminAccess(req))) {
        return res.status(403).json({ error: "Admin access required" });
      }

      const announcementId = parseInt(req.params.id);
      await storage.deleteAnnouncement(announcementId);
      
      res.json({ success: true, message: "Announcement deleted" });
    } catch (error) {
      console.error("Delete announcement error:", error);
      res.status(500).json({ error: "Failed to delete announcement" });
    }
  });

  // 手動觸發清除過期活動
  app.post("/api/admin/announcements/cleanup", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) return res.status(401).json({ error: "Authentication required" });

      if (!(await hasAdminAccess(req))) {
        return res.status(403).json({ error: "Admin access required" });
      }

      const deletedCount = await storage.deleteExpiredEvents();
      
      res.json({ success: true, deletedCount, message: `Deleted ${deletedCount} expired events` });
    } catch (error) {
      console.error("Cleanup expired events error:", error);
      res.status(500).json({ error: "Failed to cleanup expired events" });
    }
  });

  registerStripeRoutes(app);

  // ============ Ad Placements API (廣告設定) ============

  // 取得廣告設定（前端用）
  app.get("/api/ads/placements", async (req, res) => {
    try {
      const { placement, platform } = req.query;
      
      if (placement) {
        const ad = await storage.getAdPlacement(placement as string, platform as string);
        if (!ad) {
          return res.json({ ad: null });
        }
        return res.json({ 
          ad: {
            placementKey: ad.placementKey,
            platform: ad.platform,
            adUnitIdIos: ad.adUnitIdIos,
            adUnitIdAndroid: ad.adUnitIdAndroid,
            adType: ad.adType,
            fallbackImageUrl: ad.fallbackImageUrl,
            fallbackLinkUrl: ad.fallbackLinkUrl,
            showFrequency: ad.showFrequency,
            metadata: ad.metadata
          }
        });
      }
      
      const allAds = await storage.getAllAdPlacements();
      res.json({ ads: allAds.filter(a => a.isActive).map(ad => ({
        placementKey: ad.placementKey,
        platform: ad.platform,
        adType: ad.adType,
        showFrequency: ad.showFrequency
      })) });
    } catch (error) {
      console.error("Get ad placements error:", error);
      res.status(500).json({ error: "Failed to get ad placements" });
    }
  });

  // Admin: 列出所有廣告設定
  app.get("/api/admin/ads", isAuthenticated, async (req: any, res) => {
    try {
      if (!(await hasAdminAccess(req))) {
        return res.status(403).json({ error: "Admin access required" });
      }
      const ads = await storage.getAllAdPlacements();
      res.json({ ads });
    } catch (error) {
      console.error("Get all ads error:", error);
      res.status(500).json({ error: "Failed to get ads" });
    }
  });

  // Admin: 新增廣告設定
  app.post("/api/admin/ads", isAuthenticated, async (req: any, res) => {
    try {
      if (!(await hasAdminAccess(req))) {
        return res.status(403).json({ error: "Admin access required" });
      }
      
      const validatedData = insertAdPlacementSchema.parse(req.body);
      const ad = await storage.createAdPlacement(validatedData);
      res.json({ success: true, ad });
    } catch (error: any) {
      if (error.name === 'ZodError') {
        return res.status(400).json({ error: "Invalid ad placement data", details: error.errors });
      }
      console.error("Create ad error:", error);
      res.status(500).json({ error: "Failed to create ad" });
    }
  });

  // Admin: 更新廣告設定
  app.patch("/api/admin/ads/:id", isAuthenticated, async (req: any, res) => {
    try {
      if (!(await hasAdminAccess(req))) {
        return res.status(403).json({ error: "Admin access required" });
      }
      
      if (!req.body || Object.keys(req.body).length === 0) {
        return res.status(400).json({ error: "At least one field must be provided for update" });
      }
      
      const allowedFields = ['placementKey', 'platform', 'adUnitIdIos', 'adUnitIdAndroid', 'adType', 'fallbackImageUrl', 'fallbackLinkUrl', 'isActive', 'showFrequency', 'metadata'];
      const nullableFields = ['adUnitIdIos', 'adUnitIdAndroid', 'fallbackImageUrl', 'fallbackLinkUrl', 'metadata'];
      const filteredBody: Record<string, any> = {};
      for (const key of allowedFields) {
        if (key in req.body && req.body[key] !== undefined) {
          if (req.body[key] === null && !nullableFields.includes(key)) {
            return res.status(400).json({ error: `Field '${key}' cannot be null` });
          }
          filteredBody[key] = req.body[key];
        }
      }
      
      if (Object.keys(filteredBody).length === 0) {
        return res.status(400).json({ error: "No valid fields provided for update" });
      }
      
      const partialSchema = insertAdPlacementSchema.partial();
      const validatedData = partialSchema.parse(filteredBody);
      
      const ad = await storage.updateAdPlacement(parseInt(req.params.id), validatedData);
      if (!ad) {
        return res.status(404).json({ error: "Ad placement not found" });
      }
      res.json({ success: true, ad });
    } catch (error: any) {
      if (error.name === 'ZodError') {
        return res.status(400).json({ error: "Invalid ad placement data", details: error.errors });
      }
      console.error("Update ad error:", error);
      res.status(500).json({ error: "Failed to update ad" });
    }
  });

  // Admin: 刪除廣告設定
  app.delete("/api/admin/ads/:id", isAuthenticated, async (req: any, res) => {
    try {
      if (!(await hasAdminAccess(req))) {
        return res.status(403).json({ error: "Admin access required" });
      }
      await storage.deleteAdPlacement(parseInt(req.params.id));
      res.json({ success: true });
    } catch (error) {
      console.error("Delete ad error:", error);
      res.status(500).json({ error: "Failed to delete ad" });
    }
  });

  // ============ User Notifications API (未讀通知) ============

  // 取得使用者未讀通知狀態
  app.get("/api/notifications", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub || req.jwtUser?.userId;
      if (!userId) return res.status(401).json({ error: "Authentication required" });

      const notifications = await storage.getUserNotifications(userId);
      const unreadItembox = await storage.getUnreadInventoryCount(userId);
      
      const result: Record<string, number> = { itembox: unreadItembox };
      notifications.forEach(n => {
        result[n.notificationType] = n.unreadCount;
      });
      
      res.json({ notifications: result });
    } catch (error) {
      console.error("Get notifications error:", error);
      res.status(500).json({ error: "Failed to get notifications" });
    }
  });

  // 標記通知已讀
  app.post("/api/notifications/:type/seen", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub || req.jwtUser?.userId;
      if (!userId) return res.status(401).json({ error: "Authentication required" });

      await storage.markNotificationsSeen(userId, req.params.type);
      res.json({ success: true });
    } catch (error) {
      console.error("Mark notifications seen error:", error);
      res.status(500).json({ error: "Failed to mark notifications seen" });
    }
  });

  // ============ User Inventory API (道具箱) ============

  // 取得使用者道具箱 (30格遊戲風格)
  app.get("/api/inventory", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub || req.jwtUser?.userId;
      if (!userId) return res.status(401).json({ error: "Authentication required" });

      const items = await storage.getUserInventory(userId);
      const slotCount = await storage.getInventorySlotCount(userId);
      const isFull = slotCount >= INVENTORY_MAX_SLOTS;
      
      // 標記過期的優惠券 (不刪除，變灰色)
      const now = new Date();
      const enrichedItems = items.map(item => {
        const isExpired = item.validUntil && new Date(item.validUntil) < now;
        return {
          ...item,
          isExpired: isExpired || item.isExpired,
          status: isExpired ? 'expired' : item.status
        };
      });
      
      res.json({ 
        items: enrichedItems,
        slotCount,
        maxSlots: INVENTORY_MAX_SLOTS,
        isFull
      });
    } catch (error) {
      console.error("Get inventory error:", error);
      res.status(500).json({ error: "Failed to get inventory" });
    }
  });

  // 取得單一道具詳情
  app.get("/api/inventory/:id", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub || req.jwtUser?.userId;
      if (!userId) return res.status(401).json({ error: "Authentication required" });

      const item = await storage.getInventoryItemById(parseInt(req.params.id), userId);
      if (!item) {
        return res.status(404).json({ error: "Item not found" });
      }
      
      // 檢查是否過期
      const now = new Date();
      const isExpired = item.validUntil && new Date(item.validUntil) < now;
      
      res.json({ 
        item: {
          ...item,
          isExpired: isExpired || item.isExpired,
          status: isExpired ? 'expired' : item.status
        }
      });
    } catch (error) {
      console.error("Get inventory item error:", error);
      res.status(500).json({ error: "Failed to get inventory item" });
    }
  });

  // 標記道具已讀
  app.post("/api/inventory/:id/read", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub || req.jwtUser?.userId;
      if (!userId) return res.status(401).json({ error: "Authentication required" });

      await storage.markInventoryItemRead(parseInt(req.params.id));
      res.json({ success: true });
    } catch (error) {
      console.error("Mark inventory read error:", error);
      res.status(500).json({ error: "Failed to mark inventory read" });
    }
  });

  // 刪除道具 (軟刪除)
  app.delete("/api/inventory/:id", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub || req.jwtUser?.userId;
      if (!userId) return res.status(401).json({ error: "Authentication required" });

      const success = await storage.softDeleteInventoryItem(parseInt(req.params.id), userId);
      if (!success) {
        return res.status(404).json({ error: "Item not found or already deleted" });
      }
      
      res.json({ success: true, message: "Item deleted" });
    } catch (error) {
      console.error("Delete inventory item error:", error);
      res.status(500).json({ error: "Failed to delete item" });
    }
  });

  // ============ Coupon Redemption API (優惠券核銷) ============

  // 提交優惠券核銷（用戶輸入核銷碼）
  app.post("/api/inventory/:id/redeem", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub || req.jwtUser?.userId;
      if (!userId) return res.status(401).json({ error: "Authentication required" });

      const { redemptionCode } = req.body;
      const inventoryItemId = parseInt(req.params.id);

      // Get inventory item
      const item = await storage.getInventoryItemById(inventoryItemId, userId);
      if (!item) {
        return res.status(404).json({ error: "Inventory item not found" });
      }
      
      // 檢查是否已過期 (變灰色的優惠券無法核銷)
      const now = new Date();
      if (item.validUntil && new Date(item.validUntil) < now) {
        return res.status(400).json({ error: "此優惠券已過期", isExpired: true });
      }
      
      // 檢查是否已核銷
      if (item.isRedeemed || item.status === 'redeemed') {
        return res.status(400).json({ error: "此優惠券已使用", isRedeemed: true });
      }
      
      if (!item.merchantId) {
        return res.status(400).json({ error: "This item cannot be redeemed" });
      }

      // Verify merchant daily seed code
      const merchantCode = await storage.getMerchantDailySeedCode(item.merchantId);
      if (!merchantCode) {
        return res.status(400).json({ error: "Merchant has no active redemption code" });
      }

      // Check if code is from today
      const today = new Date();
      const codeDate = new Date(merchantCode.updatedAt);
      if (today.toDateString() !== codeDate.toDateString()) {
        return res.status(400).json({ error: "Redemption code expired, please get today's code" });
      }

      // Verify code
      if (redemptionCode.toUpperCase() !== merchantCode.seedCode.toUpperCase()) {
        return res.status(400).json({ error: "Invalid redemption code" });
      }

      // Create and verify redemption record with 3-minute expiry
      const expiresAt = new Date(Date.now() + 3 * 60 * 1000);
      const redemption = await storage.createAndVerifyCouponRedemption({
        userId,
        userInventoryId: inventoryItemId,
        merchantId: item.merchantId,
        redemptionCode: redemptionCode.toUpperCase(),
        expiresAt
      });

      // 追蹤優惠券使用
      try {
        await storage.incrementAnalyticsCounter(item.merchantId, null, 'couponUsageCount');
      } catch (e) {
        console.error("Failed to track coupon usage:", e);
      }

      res.json({ 
        success: true, 
        message: "Coupon redeemed! It will be removed in 3 minutes.",
        expiresAt: redemption.expiresAt,
        redemptionId: redemption.id
      });
    } catch (error) {
      console.error("Redeem coupon error:", error);
      res.status(500).json({ error: "Failed to redeem coupon" });
    }
  });

  // ============ Collection API (圖鑑) ============

  // 取得圖鑑（含商家優惠狀態）
  app.get("/api/collection/with-promo", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub || req.jwtUser?.userId;
      if (!userId) return res.status(401).json({ error: "Authentication required" });

      const collections = await storage.getCollectionWithPromoStatus(userId);
      
      // 按國家 -> 地區 -> 類別分組
      const grouped: Record<string, Record<string, Record<string, any[]>>> = {};
      
      collections.forEach(item => {
        const country = item.country || 'Unknown';
        const city = item.city || 'Unknown';
        const category = item.category || 'Other';
        
        if (!grouped[country]) grouped[country] = {};
        if (!grouped[country][city]) grouped[country][city] = {};
        if (!grouped[country][city][category]) grouped[country][city][category] = [];
        
        grouped[country][city][category].push(item);
      });
      
      res.json({ 
        collections,
        grouped,
        hasPromoItems: collections.some(c => c.hasPromo)
      });
    } catch (error) {
      console.error("Get collection with promo error:", error);
      res.status(500).json({ error: "Failed to get collection" });
    }
  });

  // 自動存入圖鑑（行程生成後調用）
  app.post("/api/collection/auto-save", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub || req.jwtUser?.userId;
      if (!userId) return res.status(401).json({ error: "Authentication required" });

      const { placeName, country, city, district, category, subcategory, description, address, placeId, rating, locationLat, locationLng } = req.body;

      // Check if already exists
      const exists = await storage.checkCollectionExists(userId, placeName, district || '');
      if (exists) {
        return res.json({ success: true, message: "Already in collection", isNew: false });
      }

      // Check for merchant promo
      const merchantLink = await storage.getMerchantPlaceLinkByPlaceName(placeName, district || '', city);
      
      const collection = await storage.addToCollection({
        userId,
        placeName,
        country,
        city,
        district,
        category,
        subcategory,
        description,
        address,
        placeId,
        rating,
        locationLat,
        locationLng
      });

      // Increment unread count for collection
      await storage.incrementUnreadCount(userId, 'collection');

      res.json({ 
        success: true, 
        isNew: true,
        collection,
        hasPromo: merchantLink?.isPromoActive || false,
        promoTitle: merchantLink?.promoTitle,
        promoDescription: merchantLink?.promoDescription
      });
    } catch (error) {
      console.error("Auto-save collection error:", error);
      res.status(500).json({ error: "Failed to save to collection" });
    }
  });

  // Merchant: 取得今日核銷碼
  app.get("/api/merchant/redemption-code", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub || req.jwtUser?.userId;
      if (!userId) return res.status(401).json({ error: "Authentication required" });

      const merchant = await storage.getMerchantByUserId(userId);
      if (!merchant) {
        return res.status(404).json({ error: "Merchant profile not found" });
      }

      const code = await storage.getMerchantDailySeedCode(merchant.id);
      
      // Check if code is from today, if not generate new one
      const today = new Date();
      if (!code || today.toDateString() !== new Date(code.updatedAt).toDateString()) {
        const crypto = await import('crypto');
        const newCode = crypto.randomBytes(4).toString('hex').toUpperCase();
        await storage.updateMerchantDailySeedCode(merchant.id, newCode);
        return res.json({ 
          code: newCode, 
          updatedAt: new Date(),
          expiresAt: new Date(today.setHours(23, 59, 59, 999))
        });
      }

      res.json({ 
        code: code.seedCode, 
        updatedAt: code.updatedAt,
        expiresAt: new Date(today.setHours(23, 59, 59, 999))
      });
    } catch (error) {
      console.error("Get redemption code error:", error);
      res.status(500).json({ error: "Failed to get redemption code" });
    }
  });

  // ============ Admin: Coupon Rarity Config (優惠券機率設定) ============

  // 取得所有機率設定
  app.get("/api/admin/rarity-config", isAuthenticated, async (req: any, res) => {
    try {
      if (!(await hasAdminAccess(req))) {
        return res.status(403).json({ error: "Admin access required" });
      }
      const configs = await storage.getAllRarityConfigs();
      const globalConfig = await storage.getGlobalRarityConfig();
      res.json({ 
        configs, 
        globalConfig: globalConfig || {
          spRate: 2, ssrRate: 8, srRate: 15, sRate: 23, rRate: 32
        }
      });
    } catch (error) {
      console.error("Get rarity configs error:", error);
      res.status(500).json({ error: "Failed to get rarity configs" });
    }
  });

  // 更新全域機率設定
  app.post("/api/admin/rarity-config", isAuthenticated, async (req: any, res) => {
    try {
      if (!(await hasAdminAccess(req))) {
        return res.status(403).json({ error: "Admin access required" });
      }
      
      const validatedData = insertCouponRarityConfigSchema.parse({
        ...req.body,
        configKey: req.body.configKey || 'global'
      });
      
      // 驗證總機率不超過100%
      const total = (validatedData.spRate || 2) + (validatedData.ssrRate || 8) + 
                    (validatedData.srRate || 15) + (validatedData.sRate || 23) + 
                    (validatedData.rRate || 32);
      if (total > 100) {
        return res.status(400).json({ error: "Total probability cannot exceed 100%" });
      }
      
      const config = await storage.upsertRarityConfig(validatedData);
      res.json({ success: true, config });
    } catch (error: any) {
      if (error.name === 'ZodError') {
        return res.status(400).json({ error: "Invalid rarity config data", details: error.errors });
      }
      console.error("Update rarity config error:", error);
      res.status(500).json({ error: "Failed to update rarity config" });
    }
  });

  // 刪除機率設定
  app.delete("/api/admin/rarity-config/:id", isAuthenticated, async (req: any, res) => {
    try {
      if (!(await hasAdminAccess(req))) {
        return res.status(403).json({ error: "Admin access required" });
      }
      await storage.deleteRarityConfig(parseInt(req.params.id));
      res.json({ success: true });
    } catch (error) {
      console.error("Delete rarity config error:", error);
      res.status(500).json({ error: "Failed to delete rarity config" });
    }
  });

  // 公開 API: 取得當前機率設定 (供前端顯示)
  app.get("/api/rarity-config", async (req, res) => {
    try {
      const config = await storage.getGlobalRarityConfig();
      res.json({ 
        config: config || {
          spRate: 2, ssrRate: 8, srRate: 15, sRate: 23, rRate: 32
        }
      });
    } catch (error) {
      console.error("Get rarity config error:", error);
      res.status(500).json({ error: "Failed to get rarity config" });
    }
  });

  // 公開 API: 道具箱格數上限
  app.get("/api/inventory/config", async (req, res) => {
    res.json({ maxSlots: INVENTORY_MAX_SLOTS });
  });

  // ============ Merchant Analytics Dashboard ============

  // GET /api/merchant/analytics - 取得商家分析數據
  app.get("/api/merchant/analytics", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) {
        return res.status(401).json({ error: "Authentication required" });
      }

      const merchant = await storage.getMerchantByUserId(userId);
      if (!merchant) {
        return res.status(403).json({ error: "Merchant registration required" });
      }

      // 取得商家認領的行程卡列表
      const placeLinks = await storage.getMerchantPlaceLinks(merchant.id);
      
      // 取得追蹤數據統計
      const analyticsSummary = await storage.getMerchantAnalyticsSummary(merchant.id);
      
      // 計算統計數據
      const stats = {
        totalPlaces: placeLinks.length,
        activePlaces: placeLinks.filter(p => p.status === 'approved').length,
        pendingPlaces: placeLinks.filter(p => p.status === 'pending').length,
        promoActivePlaces: placeLinks.filter(p => p.isPromoActive).length,
        merchantLevel: merchant.merchantLevel || 'free',
        subscriptionPlan: merchant.subscriptionPlan,
        status: merchant.status || 'pending',
        creditBalance: merchant.creditBalance || 0,
        // 擴展統計指標
        dailyCollectionCount: analyticsSummary.todayCollected,
        totalCollectionUsers: analyticsSummary.totalCollectors,
        collectionClickCount: analyticsSummary.totalClicks,
        couponUsageRate: analyticsSummary.totalCouponIssued > 0 
          ? Math.round((analyticsSummary.totalCouponUsage / analyticsSummary.totalCouponIssued) * 100) 
          : 0,
        couponTotalUsed: analyticsSummary.totalCouponUsage,
        couponTotalIssued: analyticsSummary.totalCouponIssued,
        prizePoolViewCount: analyticsSummary.totalPrizePoolViews,
      };

      res.json({
        success: true,
        merchant: {
          id: merchant.id,
          businessName: merchant.businessName || merchant.name,
          ownerName: merchant.ownerName,
          status: merchant.status,
          merchantLevel: merchant.merchantLevel,
          subscriptionPlan: merchant.subscriptionPlan,
          creditBalance: merchant.creditBalance,
        },
        stats,
        placeLinks: placeLinks.map(p => ({
          id: p.id,
          placeName: p.placeName,
          district: p.district,
          city: p.city,
          status: p.status,
          cardLevel: p.cardLevel || 'free',
          isPromoActive: p.isPromoActive,
          promoTitle: p.promoTitle,
        }))
      });
    } catch (error) {
      console.error("Get merchant analytics error:", error);
      res.status(500).json({ error: "Failed to get analytics" });
    }
  });

  // POST /api/merchant/apply - 商家申請送審 (使用新的註冊資料)
  app.post("/api/merchant/apply", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) {
        return res.status(401).json({ error: "Authentication required" });
      }

      // 驗證申請資料
      const { ownerName, businessName, taxId, businessCategory, address, phone, mobile, email } = req.body;
      
      if (!ownerName || !businessName || !businessCategory || !address || !mobile || !email) {
        return res.status(400).json({ error: "請填寫所有必填欄位" });
      }

      // 檢查是否已有商家帳號
      let merchant = await storage.getMerchantByUserId(userId);
      
      if (merchant) {
        // 更新現有商家資料並重新送審
        await storage.updateMerchant(merchant.id, {
          ownerName,
          businessName,
          taxId,
          businessCategory,
          address,
          phone,
          mobile,
          email,
          status: 'pending',
        });
        merchant = await storage.getMerchantByUserId(userId);
        return res.json({ success: true, merchant, isNew: false, message: "商家資料已更新，審核中" });
      }

      // 建立新商家
      merchant = await storage.createMerchant({
        userId,
        name: businessName,
        email,
        ownerName,
        businessName,
        taxId,
        businessCategory,
        address,
        phone,
        mobile,
        subscriptionPlan: 'free',
      });

      res.json({ success: true, merchant, isNew: true, message: "商家申請已送出，等待審核" });
    } catch (error) {
      console.error("Merchant apply error:", error);
      res.status(500).json({ error: "商家申請失敗" });
    }
  });

  // GET /api/merchant/coupons - 取得商家的優惠券模板列表
  app.get("/api/merchant/coupons", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) {
        return res.status(401).json({ error: "Authentication required" });
      }

      const merchant = await storage.getMerchantByUserId(userId);
      if (!merchant) {
        return res.status(403).json({ error: "Merchant registration required" });
      }

      const coupons = await storage.getMerchantCoupons(merchant.id);
      res.json({ success: true, coupons });
    } catch (error) {
      console.error("Get merchant coupons error:", error);
      res.status(500).json({ error: "Failed to get coupons" });
    }
  });

  // POST /api/merchant/coupons - 建立新優惠券模板
  app.post("/api/merchant/coupons", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) {
        return res.status(401).json({ error: "Authentication required" });
      }

      const merchant = await storage.getMerchantByUserId(userId);
      if (!merchant) {
        return res.status(403).json({ error: "Merchant registration required" });
      }

      const { name, tier, content, terms, quantity, validUntil, merchantPlaceLinkId, backgroundImageUrl, inventoryImageUrl } = req.body;

      if (!name || !content) {
        return res.status(400).json({ error: "請填寫優惠券名稱與內容" });
      }

      const coupon = await storage.createMerchantCoupon({
        merchantId: merchant.id,
        merchantPlaceLinkId: merchantPlaceLinkId || null,
        name,
        tier: tier || 'R',
        content,
        terms,
        quantity: quantity || -1, // -1 = unlimited
        validUntil: validUntil ? new Date(validUntil) : null,
        backgroundImageUrl,
        inventoryImageUrl,
      });

      res.json({ success: true, coupon });
    } catch (error) {
      console.error("Create merchant coupon error:", error);
      res.status(500).json({ error: "Failed to create coupon" });
    }
  });

  // PUT /api/merchant/coupons/:id - 更新優惠券模板
  app.put("/api/merchant/coupons/:id", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) {
        return res.status(401).json({ error: "Authentication required" });
      }

      const merchant = await storage.getMerchantByUserId(userId);
      if (!merchant) {
        return res.status(403).json({ error: "Merchant registration required" });
      }

      const couponId = parseInt(req.params.id);
      const { name, tier, content, terms, quantity, validUntil, isActive, backgroundImageUrl, inventoryImageUrl } = req.body;

      const coupon = await storage.updateMerchantCoupon(couponId, merchant.id, {
        name,
        tier,
        content,
        terms,
        quantity,
        validUntil: validUntil ? new Date(validUntil) : undefined,
        isActive,
        backgroundImageUrl,
        inventoryImageUrl,
      });

      if (!coupon) {
        return res.status(404).json({ error: "Coupon not found" });
      }

      res.json({ success: true, coupon });
    } catch (error) {
      console.error("Update merchant coupon error:", error);
      res.status(500).json({ error: "Failed to update coupon" });
    }
  });

  // DELETE /api/merchant/coupons/:id - 刪除優惠券模板
  app.delete("/api/merchant/coupons/:id", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) {
        return res.status(401).json({ error: "Authentication required" });
      }

      const merchant = await storage.getMerchantByUserId(userId);
      if (!merchant) {
        return res.status(403).json({ error: "Merchant registration required" });
      }

      const couponId = parseInt(req.params.id);
      const deleted = await storage.deleteMerchantCoupon(couponId, merchant.id);

      if (!deleted) {
        return res.status(404).json({ error: "Coupon not found" });
      }

      res.json({ success: true });
    } catch (error) {
      console.error("Delete merchant coupon error:", error);
      res.status(500).json({ error: "Failed to delete coupon" });
    }
  });

  // ============ Merchant Subscription Upgrade APIs ============
  
  // Subscription plan pricing (monthly, in TWD)
  const MERCHANT_PLAN_PRICES = {
    free: 0,
    pro: 999,      // NT$999/month
    premium: 2999, // NT$2,999/month
  };
  
  const PLACE_CARD_LEVEL_PRICES = {
    free: 0,
    pro: 299,      // NT$299/month per place card
    premium: 599,  // NT$599/month per place card
  };

  // GET /api/merchant/subscription/plans - 取得訂閱方案列表和價格
  app.get("/api/merchant/subscription/plans", async (req, res) => {
    try {
      res.json({
        merchantPlans: [
          {
            id: 'free',
            name: '免費版',
            nameEn: 'Free',
            price: MERCHANT_PLAN_PRICES.free,
            features: ['基本商家資料', '1張免費行程卡', '基本優惠券'],
          },
          {
            id: 'pro',
            name: '專業版',
            nameEn: 'Pro',
            price: MERCHANT_PLAN_PRICES.pro,
            features: ['所有免費版功能', '最多5張行程卡', 'SR等級優惠券', '基本數據分析'],
          },
          {
            id: 'premium',
            name: '旗艦版',
            nameEn: 'Premium',
            price: MERCHANT_PLAN_PRICES.premium,
            features: ['所有專業版功能', '無限行程卡', 'SP/SSR等級優惠券', '進階數據分析', '優先客服支援'],
          },
        ],
        placeCardLevels: [
          {
            id: 'free',
            name: '基礎版',
            nameEn: 'Basic',
            price: PLACE_CARD_LEVEL_PRICES.free,
            features: ['基本展示', '標準曝光'],
          },
          {
            id: 'pro',
            name: '進階版',
            nameEn: 'Pro',
            price: PLACE_CARD_LEVEL_PRICES.pro,
            features: ['優先曝光', '自訂圖片', '促銷標籤'],
          },
          {
            id: 'premium',
            name: '旗艦版',
            nameEn: 'Premium',
            price: PLACE_CARD_LEVEL_PRICES.premium,
            features: ['最高曝光', '影片展示', '專屬推薦', '數據報表'],
          },
        ],
      });
    } catch (error) {
      console.error("Get subscription plans error:", error);
      res.status(500).json({ error: "Failed to get subscription plans" });
    }
  });

  // POST /api/merchant/subscription/upgrade - 建立商家等級升級支付
  app.post("/api/merchant/subscription/upgrade", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) {
        return res.status(401).json({ error: "Authentication required" });
      }

      const merchant = await storage.getMerchantByUserId(userId);
      if (!merchant) {
        return res.status(403).json({ error: "Merchant registration required" });
      }

      const { targetPlan, provider = 'stripe' } = req.body;
      
      if (!['pro', 'premium'].includes(targetPlan)) {
        return res.status(400).json({ error: "Invalid target plan" });
      }

      const currentPlan = merchant.merchantLevel || 'free';
      const planOrder = { free: 0, pro: 1, premium: 2 };
      
      if (planOrder[targetPlan as keyof typeof planOrder] <= planOrder[currentPlan as keyof typeof planOrder]) {
        return res.status(400).json({ error: "Can only upgrade to a higher plan" });
      }

      const price = MERCHANT_PLAN_PRICES[targetPlan as keyof typeof MERCHANT_PLAN_PRICES];
      
      if (provider === 'stripe') {
        const stripeClient = await getUncachableStripeClient();
        const baseUrl = `https://${req.hostname}`;
        
        const session = await stripeClient.checkout.sessions.create({
          payment_method_types: ['card'],
          line_items: [{
            price_data: {
              currency: 'twd',
              product_data: {
                name: `商家等級升級 - ${targetPlan === 'pro' ? '專業版' : '旗艦版'}`,
                description: `從 ${currentPlan} 升級到 ${targetPlan}`,
              },
              unit_amount: price,
              recurring: {
                interval: 'month',
              },
            },
            quantity: 1,
          }],
          mode: 'subscription',
          success_url: `${baseUrl}/merchant/subscription/success?session_id={CHECKOUT_SESSION_ID}&plan=${targetPlan}`,
          cancel_url: `${baseUrl}/merchant/subscription`,
          metadata: {
            merchantId: merchant.id.toString(),
            upgradeType: 'merchant_plan',
            targetPlan,
            currentPlan,
          },
        });

        return res.json({
          provider: 'stripe',
          checkoutUrl: session.url,
          sessionId: session.id,
        });
      }
      
      // Recur payment (for Taiwan local payment)
      return res.json({
        provider: 'recur',
        price,
        merchantId: merchant.id,
        targetPlan,
        message: 'Recur payment integration pending',
      });
    } catch (error) {
      console.error("Merchant subscription upgrade error:", error);
      res.status(500).json({ error: "Failed to create upgrade session" });
    }
  });

  // POST /api/merchant/subscription/confirm - 確認升級 (webhook 或手動確認)
  app.post("/api/merchant/subscription/confirm", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) {
        return res.status(401).json({ error: "Authentication required" });
      }

      const merchant = await storage.getMerchantByUserId(userId);
      if (!merchant) {
        return res.status(403).json({ error: "Merchant registration required" });
      }

      const { sessionId, targetPlan } = req.body;
      
      if (!['pro', 'premium'].includes(targetPlan)) {
        return res.status(400).json({ error: "Invalid target plan" });
      }

      // Verify Stripe session if provided
      if (sessionId) {
        const stripeClient = await getUncachableStripeClient();
        const session = await stripeClient.checkout.sessions.retrieve(sessionId);
        
        if (session.payment_status !== 'paid') {
          return res.status(400).json({ error: "Payment not completed" });
        }
        
        // Verify session belongs to this merchant
        if (session.metadata?.merchantId !== merchant.id.toString()) {
          return res.status(403).json({ error: "Session does not belong to this merchant" });
        }
      }

      // Update merchant plan
      const updatedMerchant = await storage.updateMerchant(merchant.id, {
        merchantLevel: targetPlan,
        subscriptionPlan: targetPlan,
      });

      res.json({
        success: true,
        merchant: updatedMerchant,
        message: `Successfully upgraded to ${targetPlan} plan`,
      });
    } catch (error) {
      console.error("Confirm subscription upgrade error:", error);
      res.status(500).json({ error: "Failed to confirm upgrade" });
    }
  });

  // POST /api/merchant/places/:linkId/upgrade - 升級行程卡等級
  app.post("/api/merchant/places/:linkId/upgrade", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) {
        return res.status(401).json({ error: "Authentication required" });
      }

      const merchant = await storage.getMerchantByUserId(userId);
      if (!merchant) {
        return res.status(403).json({ error: "Merchant registration required" });
      }

      const linkId = parseInt(req.params.linkId);
      const { targetLevel, provider = 'stripe' } = req.body;
      
      if (!['pro', 'premium'].includes(targetLevel)) {
        return res.status(400).json({ error: "Invalid target level" });
      }

      // Get current place card
      const placeLinks = await storage.getMerchantPlaceLinks(merchant.id);
      const placeLink = placeLinks.find(link => link.id === linkId);
      if (!placeLink) {
        return res.status(404).json({ error: "Place card not found" });
      }

      const currentLevel = placeLink.cardLevel || 'free';
      const levelOrder = { free: 0, pro: 1, premium: 2 };
      
      if (levelOrder[targetLevel as keyof typeof levelOrder] <= levelOrder[currentLevel as keyof typeof levelOrder]) {
        return res.status(400).json({ error: "Can only upgrade to a higher level" });
      }

      const price = PLACE_CARD_LEVEL_PRICES[targetLevel as keyof typeof PLACE_CARD_LEVEL_PRICES];
      
      if (provider === 'stripe') {
        const stripeClient = await getUncachableStripeClient();
        const baseUrl = `https://${req.hostname}`;
        
        const session = await stripeClient.checkout.sessions.create({
          payment_method_types: ['card'],
          line_items: [{
            price_data: {
              currency: 'twd',
              product_data: {
                name: `行程卡升級 - ${targetLevel === 'pro' ? '進階版' : '旗艦版'}`,
                description: `行程卡 #${linkId} 從 ${currentLevel} 升級到 ${targetLevel}`,
              },
              unit_amount: price,
              recurring: {
                interval: 'month',
              },
            },
            quantity: 1,
          }],
          mode: 'subscription',
          success_url: `${baseUrl}/merchant/places/${linkId}/success?session_id={CHECKOUT_SESSION_ID}&level=${targetLevel}`,
          cancel_url: `${baseUrl}/merchant/places`,
          metadata: {
            merchantId: merchant.id.toString(),
            placeLinkId: linkId.toString(),
            upgradeType: 'place_card_level',
            targetLevel,
            currentLevel,
          },
        });

        return res.json({
          provider: 'stripe',
          checkoutUrl: session.url,
          sessionId: session.id,
        });
      }
      
      return res.json({
        provider: 'recur',
        price,
        placeLinkId: linkId,
        targetLevel,
        message: 'Recur payment integration pending',
      });
    } catch (error) {
      console.error("Place card upgrade error:", error);
      res.status(500).json({ error: "Failed to create upgrade session" });
    }
  });

  // POST /api/merchant/places/:linkId/upgrade/confirm - 確認行程卡升級
  app.post("/api/merchant/places/:linkId/upgrade/confirm", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) {
        return res.status(401).json({ error: "Authentication required" });
      }

      const merchant = await storage.getMerchantByUserId(userId);
      if (!merchant) {
        return res.status(403).json({ error: "Merchant registration required" });
      }

      const linkId = parseInt(req.params.linkId);
      const { sessionId, targetLevel } = req.body;
      
      if (!['pro', 'premium'].includes(targetLevel)) {
        return res.status(400).json({ error: "Invalid target level" });
      }

      // Verify place belongs to merchant
      const allPlaceLinks = await storage.getMerchantPlaceLinks(merchant.id);
      const placeLink = allPlaceLinks.find(link => link.id === linkId);
      if (!placeLink) {
        return res.status(404).json({ error: "Place card not found" });
      }

      // Verify Stripe session if provided
      if (sessionId) {
        const stripeClient = await getUncachableStripeClient();
        const session = await stripeClient.checkout.sessions.retrieve(sessionId);
        
        if (session.payment_status !== 'paid') {
          return res.status(400).json({ error: "Payment not completed" });
        }
        
        if (session.metadata?.placeLinkId !== linkId.toString()) {
          return res.status(403).json({ error: "Session does not belong to this place card" });
        }
      }

      // Update place card level
      const updatedPlaceLink = await storage.updateMerchantPlaceLink(linkId, {
        cardLevel: targetLevel,
      });

      res.json({
        success: true,
        placeLink: updatedPlaceLink,
        message: `Successfully upgraded place card to ${targetLevel} level`,
      });
    } catch (error) {
      console.error("Confirm place card upgrade error:", error);
      res.status(500).json({ error: "Failed to confirm upgrade" });
    }
  });

  // GET /api/merchant/subscription - 取得當前訂閱狀態
  app.get("/api/merchant/subscription", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) {
        return res.status(401).json({ error: "Authentication required" });
      }

      const merchant = await storage.getMerchantByUserId(userId);
      if (!merchant) {
        return res.status(403).json({ error: "Merchant registration required" });
      }

      // Get place cards with their levels
      const placeLinks = await storage.getMerchantPlaceLinks(merchant.id);
      
      res.json({
        merchantId: merchant.id,
        merchantLevel: merchant.merchantLevel || 'free',
        subscriptionPlan: merchant.subscriptionPlan || 'free',
        placeCards: placeLinks.map(link => ({
          id: link.id,
          placeName: link.placeName,
          cardLevel: link.cardLevel || 'free',
        })),
        limits: {
          maxPlaceCards: merchant.merchantLevel === 'premium' ? Infinity : 
                         merchant.merchantLevel === 'pro' ? 5 : 1,
          currentPlaceCards: placeLinks.length,
          canAddMoreCards: merchant.merchantLevel === 'premium' || 
                          (merchant.merchantLevel === 'pro' && placeLinks.length < 5) ||
                          (merchant.merchantLevel === 'free' && placeLinks.length < 1),
        },
      });
    } catch (error) {
      console.error("Get merchant subscription error:", error);
      res.status(500).json({ error: "Failed to get subscription status" });
    }
  });

  // POST /api/admin/sync-database - Super Admin: Full database sync from seed files
  app.post("/api/admin/sync-database", async (req: any, res) => {
    try {
      const authHeader = req.headers.authorization;
      if (!authHeader || !authHeader.startsWith('Bearer ')) {
        return res.status(401).json({ error: "Authorization required" });
      }
      
      const adminKey = authHeader.split(' ')[1];
      const expectedKey = process.env.SUPER_ADMIN_PASSWORD;
      
      if (!expectedKey || adminKey !== expectedKey) {
        return res.status(403).json({ error: "Invalid admin key" });
      }

      const fs = await import('fs');
      const path = await import('path');
      const seedDir = path.join(process.cwd(), 'server/seed');
      
      const results: Record<string, { total: number; inserted: number; skipped: number; errors: number }> = {};

      const syncOrder = [
        'countries',
        'regions', 
        'districts',
        'categories',
        'subcategories',
        'service_plans',
        'places',
        'place_cache'
      ];

      for (const tableName of syncOrder) {
        const seedPath = path.join(seedDir, `${tableName}-seed.json`);
        
        if (!fs.existsSync(seedPath)) {
          results[tableName] = { total: 0, inserted: 0, skipped: 0, errors: 0 };
          continue;
        }

        const seedData = JSON.parse(fs.readFileSync(seedPath, 'utf-8'));
        if (!Array.isArray(seedData)) {
          results[tableName] = { total: 0, inserted: 0, skipped: 0, errors: 0 };
          continue;
        }

        let inserted = 0, skipped = 0, errors = 0;

        for (const record of seedData) {
          try {
            const syncResult = await storage.syncRecord(tableName, record);
            if (syncResult === 'inserted') inserted++;
            else if (syncResult === 'skipped') skipped++;
          } catch (err) {
            console.error(`Failed to sync ${tableName} record:`, err);
            errors++;
          }
        }

        results[tableName] = { total: seedData.length, inserted, skipped, errors };
      }

      const summary = Object.entries(results).map(([table, r]) => 
        `${table}: ${r.inserted} inserted, ${r.skipped} skipped, ${r.errors} errors`
      ).join('\n');

      res.json({
        success: true,
        results,
        summary,
      });
    } catch (error) {
      console.error("Sync database error:", error);
      res.status(500).json({ error: "Failed to sync database" });
    }
  });

  const httpServer = createServer(app);
  return httpServer;
}


=== File: server/seed.ts ===

import { db } from "./db";
import { countries, regions, districts, categories, subcategories } from "@shared/schema";
import { eq } from "drizzle-orm";

async function seed() {
  console.log("Starting database seed...");

  // ============ COUNTRIES ============
  const [taiwan] = await db.insert(countries).values({
    code: "TW",
    nameEn: "Taiwan",
    nameZh: "台灣",
    nameJa: "台湾",
    nameKo: "대만",
    isActive: true,
  }).onConflictDoNothing().returning();

  let taiwanId = taiwan?.id;
  if (!taiwanId) {
    const [existing] = await db.select().from(countries).where(eq(countries.code, "TW")).limit(1);
    taiwanId = existing?.id;
  }
  
  if (!taiwanId) {
    const existing = await db.select().from(countries).limit(1);
    console.log("Using existing country:", existing[0]?.id);
    taiwanId = existing[0]?.id;
  }

  console.log("Country seeded:", taiwanId);

  // ============ REGIONS (Taiwan Cities/Counties - 縣市) ============
  const regionData = [
    { code: "taipei_city", nameEn: "Taipei City", nameZh: "台北市", nameJa: "台北市", nameKo: "타이베이시" },
    { code: "new_taipei_city", nameEn: "New Taipei City", nameZh: "新北市", nameJa: "新北市", nameKo: "신베이시" },
    { code: "taoyuan_city", nameEn: "Taoyuan City", nameZh: "桃園市", nameJa: "桃園市", nameKo: "타오위안시" },
    { code: "taichung_city", nameEn: "Taichung City", nameZh: "台中市", nameJa: "台中市", nameKo: "타이중시" },
    { code: "tainan_city", nameEn: "Tainan City", nameZh: "台南市", nameJa: "台南市", nameKo: "타이난시" },
    { code: "kaohsiung_city", nameEn: "Kaohsiung City", nameZh: "高雄市", nameJa: "高雄市", nameKo: "가오슝시" },
    { code: "keelung_city", nameEn: "Keelung City", nameZh: "基隆市", nameJa: "基隆市", nameKo: "지룽시" },
    { code: "hsinchu_city", nameEn: "Hsinchu City", nameZh: "新竹市", nameJa: "新竹市", nameKo: "신주시" },
    { code: "chiayi_city", nameEn: "Chiayi City", nameZh: "嘉義市", nameJa: "嘉義市", nameKo: "자이시" },
    { code: "hsinchu_county", nameEn: "Hsinchu County", nameZh: "新竹縣", nameJa: "新竹県", nameKo: "신주현" },
    { code: "miaoli_county", nameEn: "Miaoli County", nameZh: "苗栗縣", nameJa: "苗栗県", nameKo: "먀오리현" },
    { code: "changhua_county", nameEn: "Changhua County", nameZh: "彰化縣", nameJa: "彰化県", nameKo: "창화현" },
    { code: "nantou_county", nameEn: "Nantou County", nameZh: "南投縣", nameJa: "南投県", nameKo: "난터우현" },
    { code: "yunlin_county", nameEn: "Yunlin County", nameZh: "雲林縣", nameJa: "雲林県", nameKo: "윈린현" },
    { code: "chiayi_county", nameEn: "Chiayi County", nameZh: "嘉義縣", nameJa: "嘉義県", nameKo: "자이현" },
    { code: "pingtung_county", nameEn: "Pingtung County", nameZh: "屏東縣", nameJa: "屏東県", nameKo: "핑둥현" },
    { code: "yilan_county", nameEn: "Yilan County", nameZh: "宜蘭縣", nameJa: "宜蘭県", nameKo: "이란현" },
    { code: "hualien_county", nameEn: "Hualien County", nameZh: "花蓮縣", nameJa: "花蓮県", nameKo: "화롄현" },
    { code: "taitung_county", nameEn: "Taitung County", nameZh: "台東縣", nameJa: "台東県", nameKo: "타이둥현" },
    { code: "penghu_county", nameEn: "Penghu County", nameZh: "澎湖縣", nameJa: "澎湖県", nameKo: "펑후현" },
    { code: "kinmen_county", nameEn: "Kinmen County", nameZh: "金門縣", nameJa: "金門県", nameKo: "진먼현" },
    { code: "lienchiang_county", nameEn: "Lienchiang County", nameZh: "連江縣", nameJa: "連江県", nameKo: "롄장현" },
  ];

  const insertedRegions: Record<string, number> = {};
  
  // Check if regions already exist
  const existingRegions = await db.select().from(regions);
  const existingRegionCodes = new Set(existingRegions.map(r => r.code));
  
  for (const region of regionData) {
    // Skip if region already exists
    if (existingRegionCodes.has(region.code)) {
      continue;
    }
    const [inserted] = await db.insert(regions).values({
      countryId: taiwanId!,
      ...region,
      isActive: true,
    }).returning();
    if (inserted) insertedRegions[region.code] = inserted.id;
  }

  const allRegions = await db.select().from(regions);
  const regionMap: Record<string, number> = {};
  allRegions.forEach(r => { regionMap[r.code] = r.id; });

  console.log("Regions (Cities/Counties) seeded:", Object.keys(regionMap).length);

  // ============ DISTRICTS (鄉鎮市區) - 完整 368 個行政區 ============
  const districtData: Record<string, Array<{ code: string; nameEn: string; nameZh: string; nameJa: string; nameKo: string }>> = {
    taipei_city: [
      { code: "zhongzheng", nameEn: "Zhongzheng District", nameZh: "中正區", nameJa: "中正区", nameKo: "중정구" },
      { code: "datong", nameEn: "Datong District", nameZh: "大同區", nameJa: "大同区", nameKo: "대동구" },
      { code: "zhongshan", nameEn: "Zhongshan District", nameZh: "中山區", nameJa: "中山区", nameKo: "중산구" },
      { code: "songshan", nameEn: "Songshan District", nameZh: "松山區", nameJa: "松山区", nameKo: "송산구" },
      { code: "daan", nameEn: "Da'an District", nameZh: "大安區", nameJa: "大安区", nameKo: "다안구" },
      { code: "wanhua", nameEn: "Wanhua District", nameZh: "萬華區", nameJa: "萬華区", nameKo: "만화구" },
      { code: "xinyi", nameEn: "Xinyi District", nameZh: "信義區", nameJa: "信義区", nameKo: "신의구" },
      { code: "shilin", nameEn: "Shilin District", nameZh: "士林區", nameJa: "士林区", nameKo: "사림구" },
      { code: "beitou", nameEn: "Beitou District", nameZh: "北投區", nameJa: "北投区", nameKo: "북투구" },
      { code: "neihu", nameEn: "Neihu District", nameZh: "內湖區", nameJa: "内湖区", nameKo: "내호구" },
      { code: "nangang", nameEn: "Nangang District", nameZh: "南港區", nameJa: "南港区", nameKo: "남항구" },
      { code: "wenshan", nameEn: "Wenshan District", nameZh: "文山區", nameJa: "文山区", nameKo: "문산구" },
    ],
    new_taipei_city: [
      { code: "banqiao", nameEn: "Banqiao District", nameZh: "板橋區", nameJa: "板橋区", nameKo: "판교구" },
      { code: "sanchong", nameEn: "Sanchong District", nameZh: "三重區", nameJa: "三重区", nameKo: "삼중구" },
      { code: "zhonghe", nameEn: "Zhonghe District", nameZh: "中和區", nameJa: "中和区", nameKo: "중화구" },
      { code: "yonghe", nameEn: "Yonghe District", nameZh: "永和區", nameJa: "永和区", nameKo: "영화구" },
      { code: "xinzhuang", nameEn: "Xinzhuang District", nameZh: "新莊區", nameJa: "新荘区", nameKo: "신장구" },
      { code: "xindian", nameEn: "Xindian District", nameZh: "新店區", nameJa: "新店区", nameKo: "신점구" },
      { code: "tucheng", nameEn: "Tucheng District", nameZh: "土城區", nameJa: "土城区", nameKo: "토성구" },
      { code: "luzhou", nameEn: "Luzhou District", nameZh: "蘆洲區", nameJa: "蘆洲区", nameKo: "노주구" },
      { code: "shulin", nameEn: "Shulin District", nameZh: "樹林區", nameJa: "樹林区", nameKo: "수림구" },
      { code: "yingge", nameEn: "Yingge District", nameZh: "鶯歌區", nameJa: "鶯歌区", nameKo: "앵가구" },
      { code: "sanxia", nameEn: "Sanxia District", nameZh: "三峽區", nameJa: "三峽区", nameKo: "삼협구" },
      { code: "danshui", nameEn: "Tamsui District", nameZh: "淡水區", nameJa: "淡水区", nameKo: "담수구" },
      { code: "xizhi", nameEn: "Xizhi District", nameZh: "汐止區", nameJa: "汐止区", nameKo: "석지구" },
      { code: "ruifang", nameEn: "Ruifang District", nameZh: "瑞芳區", nameJa: "瑞芳区", nameKo: "서방구" },
      { code: "wugu", nameEn: "Wugu District", nameZh: "五股區", nameJa: "五股区", nameKo: "오고구" },
      { code: "taishan", nameEn: "Taishan District", nameZh: "泰山區", nameJa: "泰山区", nameKo: "태산구" },
      { code: "linkou", nameEn: "Linkou District", nameZh: "林口區", nameJa: "林口区", nameKo: "임구구" },
      { code: "shenkeng", nameEn: "Shenkeng District", nameZh: "深坑區", nameJa: "深坑区", nameKo: "심갱구" },
      { code: "shiding", nameEn: "Shiding District", nameZh: "石碇區", nameJa: "石碇区", nameKo: "석정구" },
      { code: "pinglin", nameEn: "Pinglin District", nameZh: "坪林區", nameJa: "坪林区", nameKo: "평림구" },
      { code: "sanzhi", nameEn: "Sanzhi District", nameZh: "三芝區", nameJa: "三芝区", nameKo: "삼지구" },
      { code: "shimen", nameEn: "Shimen District", nameZh: "石門區", nameJa: "石門区", nameKo: "석문구" },
      { code: "bali", nameEn: "Bali District", nameZh: "八里區", nameJa: "八里区", nameKo: "팔리구" },
      { code: "pingxi", nameEn: "Pingxi District", nameZh: "平溪區", nameJa: "平溪区", nameKo: "평계구" },
      { code: "shuangxi", nameEn: "Shuangxi District", nameZh: "雙溪區", nameJa: "双溪区", nameKo: "쌍계구" },
      { code: "gongliao", nameEn: "Gongliao District", nameZh: "貢寮區", nameJa: "貢寮区", nameKo: "공료구" },
      { code: "jinshan", nameEn: "Jinshan District", nameZh: "金山區", nameJa: "金山区", nameKo: "금산구" },
      { code: "wanli", nameEn: "Wanli District", nameZh: "萬里區", nameJa: "萬里区", nameKo: "만리구" },
      { code: "wulai", nameEn: "Wulai District", nameZh: "烏來區", nameJa: "烏来区", nameKo: "오래구" },
    ],
    taoyuan_city: [
      { code: "taoyuan_dist", nameEn: "Taoyuan District", nameZh: "桃園區", nameJa: "桃園区", nameKo: "도원구" },
      { code: "zhongli", nameEn: "Zhongli District", nameZh: "中壢區", nameJa: "中壢区", nameKo: "중력구" },
      { code: "daxi", nameEn: "Daxi District", nameZh: "大溪區", nameJa: "大渓区", nameKo: "대계구" },
      { code: "yangmei", nameEn: "Yangmei District", nameZh: "楊梅區", nameJa: "楊梅区", nameKo: "양매구" },
      { code: "luzhu", nameEn: "Luzhu District", nameZh: "蘆竹區", nameJa: "蘆竹区", nameKo: "노죽구" },
      { code: "dayuan", nameEn: "Dayuan District", nameZh: "大園區", nameJa: "大園区", nameKo: "대원구" },
      { code: "guishan", nameEn: "Guishan District", nameZh: "龜山區", nameJa: "亀山区", nameKo: "귀산구" },
      { code: "bade", nameEn: "Bade District", nameZh: "八德區", nameJa: "八德区", nameKo: "팔덕구" },
      { code: "longtan", nameEn: "Longtan District", nameZh: "龍潭區", nameJa: "龍潭区", nameKo: "용담구" },
      { code: "pingzhen", nameEn: "Pingzhen District", nameZh: "平鎮區", nameJa: "平鎮区", nameKo: "평진구" },
      { code: "xinwu", nameEn: "Xinwu District", nameZh: "新屋區", nameJa: "新屋区", nameKo: "신옥구" },
      { code: "guanyin", nameEn: "Guanyin District", nameZh: "觀音區", nameJa: "観音区", nameKo: "관음구" },
      { code: "fuxing", nameEn: "Fuxing District", nameZh: "復興區", nameJa: "復興区", nameKo: "부흥구" },
    ],
    taichung_city: [
      { code: "central", nameEn: "Central District", nameZh: "中區", nameJa: "中区", nameKo: "중구" },
      { code: "east", nameEn: "East District", nameZh: "東區", nameJa: "東区", nameKo: "동구" },
      { code: "south", nameEn: "South District", nameZh: "南區", nameJa: "南区", nameKo: "남구" },
      { code: "west", nameEn: "West District", nameZh: "西區", nameJa: "西区", nameKo: "서구" },
      { code: "north", nameEn: "North District", nameZh: "北區", nameJa: "北区", nameKo: "북구" },
      { code: "beitun", nameEn: "Beitun District", nameZh: "北屯區", nameJa: "北屯区", nameKo: "북둔구" },
      { code: "xitun", nameEn: "Xitun District", nameZh: "西屯區", nameJa: "西屯区", nameKo: "서둔구" },
      { code: "nantun", nameEn: "Nantun District", nameZh: "南屯區", nameJa: "南屯区", nameKo: "남둔구" },
      { code: "taiping", nameEn: "Taiping District", nameZh: "太平區", nameJa: "太平区", nameKo: "태평구" },
      { code: "dali", nameEn: "Dali District", nameZh: "大里區", nameJa: "大里区", nameKo: "대리구" },
      { code: "wufeng", nameEn: "Wufeng District", nameZh: "霧峰區", nameJa: "霧峰区", nameKo: "무봉구" },
      { code: "wuri", nameEn: "Wuri District", nameZh: "烏日區", nameJa: "烏日区", nameKo: "오일구" },
      { code: "fengyuan", nameEn: "Fengyuan District", nameZh: "豐原區", nameJa: "豊原区", nameKo: "풍원구" },
      { code: "houli", nameEn: "Houli District", nameZh: "后里區", nameJa: "后里区", nameKo: "후리구" },
      { code: "shigang", nameEn: "Shigang District", nameZh: "石岡區", nameJa: "石岡区", nameKo: "석강구" },
      { code: "dongshi", nameEn: "Dongshi District", nameZh: "東勢區", nameJa: "東勢区", nameKo: "동세구" },
      { code: "heping", nameEn: "Heping District", nameZh: "和平區", nameJa: "和平区", nameKo: "화평구" },
      { code: "xinshe", nameEn: "Xinshe District", nameZh: "新社區", nameJa: "新社区", nameKo: "신사구" },
      { code: "tanzi", nameEn: "Tanzi District", nameZh: "潭子區", nameJa: "潭子区", nameKo: "담자구" },
      { code: "daya", nameEn: "Daya District", nameZh: "大雅區", nameJa: "大雅区", nameKo: "대아구" },
      { code: "shengang", nameEn: "Shengang District", nameZh: "神岡區", nameJa: "神岡区", nameKo: "신강구" },
      { code: "dadu", nameEn: "Dadu District", nameZh: "大肚區", nameJa: "大肚区", nameKo: "대두구" },
      { code: "shalu", nameEn: "Shalu District", nameZh: "沙鹿區", nameJa: "沙鹿区", nameKo: "사록구" },
      { code: "longjing", nameEn: "Longjing District", nameZh: "龍井區", nameJa: "龍井区", nameKo: "용정구" },
      { code: "wuqi", nameEn: "Wuqi District", nameZh: "梧棲區", nameJa: "梧棲区", nameKo: "오서구" },
      { code: "qingshui", nameEn: "Qingshui District", nameZh: "清水區", nameJa: "清水区", nameKo: "청수구" },
      { code: "dajia", nameEn: "Dajia District", nameZh: "大甲區", nameJa: "大甲区", nameKo: "대갑구" },
      { code: "waipu", nameEn: "Waipu District", nameZh: "外埔區", nameJa: "外埔区", nameKo: "외포구" },
      { code: "daan_tc", nameEn: "Da'an District", nameZh: "大安區", nameJa: "大安区", nameKo: "대안구" },
    ],
    tainan_city: [
      { code: "west_central", nameEn: "West Central District", nameZh: "中西區", nameJa: "中西区", nameKo: "중서구" },
      { code: "east_dist", nameEn: "East District", nameZh: "東區", nameJa: "東区", nameKo: "동구" },
      { code: "south_dist", nameEn: "South District", nameZh: "南區", nameJa: "南区", nameKo: "남구" },
      { code: "north_dist", nameEn: "North District", nameZh: "北區", nameJa: "北区", nameKo: "북구" },
      { code: "anping", nameEn: "Anping District", nameZh: "安平區", nameJa: "安平区", nameKo: "안평구" },
      { code: "annan", nameEn: "Annan District", nameZh: "安南區", nameJa: "安南区", nameKo: "안남구" },
      { code: "yongkang", nameEn: "Yongkang District", nameZh: "永康區", nameJa: "永康区", nameKo: "영강구" },
      { code: "guiren", nameEn: "Guiren District", nameZh: "歸仁區", nameJa: "帰仁区", nameKo: "귀인구" },
      { code: "xinhua", nameEn: "Xinhua District", nameZh: "新化區", nameJa: "新化区", nameKo: "신화구" },
      { code: "zuozhen", nameEn: "Zuozhen District", nameZh: "左鎮區", nameJa: "左鎮区", nameKo: "좌진구" },
      { code: "yujing", nameEn: "Yujing District", nameZh: "玉井區", nameJa: "玉井区", nameKo: "옥정구" },
      { code: "nanxi", nameEn: "Nanxi District", nameZh: "楠西區", nameJa: "楠西区", nameKo: "남서구" },
      { code: "nanhua", nameEn: "Nanhua District", nameZh: "南化區", nameJa: "南化区", nameKo: "남화구" },
      { code: "rende", nameEn: "Rende District", nameZh: "仁德區", nameJa: "仁德区", nameKo: "인덕구" },
      { code: "guanmiao", nameEn: "Guanmiao District", nameZh: "關廟區", nameJa: "関廟区", nameKo: "관묘구" },
      { code: "longqi", nameEn: "Longqi District", nameZh: "龍崎區", nameJa: "龍崎区", nameKo: "용기구" },
      { code: "guantian", nameEn: "Guantian District", nameZh: "官田區", nameJa: "官田区", nameKo: "관전구" },
      { code: "madou", nameEn: "Madou District", nameZh: "麻豆區", nameJa: "麻豆区", nameKo: "마두구" },
      { code: "jiali", nameEn: "Jiali District", nameZh: "佳里區", nameJa: "佳里区", nameKo: "가리구" },
      { code: "xigang", nameEn: "Xigang District", nameZh: "西港區", nameJa: "西港区", nameKo: "서항구" },
      { code: "qigu", nameEn: "Qigu District", nameZh: "七股區", nameJa: "七股区", nameKo: "칠고구" },
      { code: "jiangjun", nameEn: "Jiangjun District", nameZh: "將軍區", nameJa: "将軍区", nameKo: "장군구" },
      { code: "xuejia", nameEn: "Xuejia District", nameZh: "學甲區", nameJa: "学甲区", nameKo: "학갑구" },
      { code: "beimen", nameEn: "Beimen District", nameZh: "北門區", nameJa: "北門区", nameKo: "북문구" },
      { code: "xinying", nameEn: "Xinying District", nameZh: "新營區", nameJa: "新営区", nameKo: "신영구" },
      { code: "houbi", nameEn: "Houbi District", nameZh: "後壁區", nameJa: "後壁区", nameKo: "후벽구" },
      { code: "baihe", nameEn: "Baihe District", nameZh: "白河區", nameJa: "白河区", nameKo: "백하구" },
      { code: "dongshan", nameEn: "Dongshan District", nameZh: "東山區", nameJa: "東山区", nameKo: "동산구" },
      { code: "liujia", nameEn: "Liujia District", nameZh: "六甲區", nameJa: "六甲区", nameKo: "육갑구" },
      { code: "xiaying", nameEn: "Xiaying District", nameZh: "下營區", nameJa: "下営区", nameKo: "하영구" },
      { code: "liuying", nameEn: "Liuying District", nameZh: "柳營區", nameJa: "柳営区", nameKo: "유영구" },
      { code: "yanshui", nameEn: "Yanshui District", nameZh: "鹽水區", nameJa: "塩水区", nameKo: "염수구" },
      { code: "shanhua", nameEn: "Shanhua District", nameZh: "善化區", nameJa: "善化区", nameKo: "선화구" },
      { code: "danei", nameEn: "Danei District", nameZh: "大內區", nameJa: "大内区", nameKo: "대내구" },
      { code: "shanshang", nameEn: "Shanshang District", nameZh: "山上區", nameJa: "山上区", nameKo: "산상구" },
      { code: "xinshi", nameEn: "Xinshi District", nameZh: "新市區", nameJa: "新市区", nameKo: "신시구" },
      { code: "anding", nameEn: "Anding District", nameZh: "安定區", nameJa: "安定区", nameKo: "안정구" },
    ],
    kaohsiung_city: [
      { code: "yancheng", nameEn: "Yancheng District", nameZh: "鹽埕區", nameJa: "塩埕区", nameKo: "염정구" },
      { code: "gushan", nameEn: "Gushan District", nameZh: "鼓山區", nameJa: "鼓山区", nameKo: "고산구" },
      { code: "zuoying", nameEn: "Zuoying District", nameZh: "左營區", nameJa: "左營区", nameKo: "좌영구" },
      { code: "nanzi", nameEn: "Nanzi District", nameZh: "楠梓區", nameJa: "楠梓区", nameKo: "남자구" },
      { code: "sanmin", nameEn: "Sanmin District", nameZh: "三民區", nameJa: "三民区", nameKo: "삼민구" },
      { code: "xinxing", nameEn: "Xinxing District", nameZh: "新興區", nameJa: "新興区", nameKo: "신흥구" },
      { code: "qianjin", nameEn: "Qianjin District", nameZh: "前金區", nameJa: "前金区", nameKo: "전금구" },
      { code: "lingya", nameEn: "Lingya District", nameZh: "苓雅區", nameJa: "苓雅区", nameKo: "영아구" },
      { code: "qianzhen", nameEn: "Qianzhen District", nameZh: "前鎮區", nameJa: "前鎮区", nameKo: "전진구" },
      { code: "qijin", nameEn: "Qijin District", nameZh: "旗津區", nameJa: "旗津区", nameKo: "기진구" },
      { code: "xiaogang", nameEn: "Xiaogang District", nameZh: "小港區", nameJa: "小港区", nameKo: "소항구" },
      { code: "fengshan", nameEn: "Fengshan District", nameZh: "鳳山區", nameJa: "鳳山区", nameKo: "봉산구" },
      { code: "linyuan", nameEn: "Linyuan District", nameZh: "林園區", nameJa: "林園区", nameKo: "임원구" },
      { code: "daliao", nameEn: "Daliao District", nameZh: "大寮區", nameJa: "大寮区", nameKo: "대료구" },
      { code: "dashu", nameEn: "Dashu District", nameZh: "大樹區", nameJa: "大樹区", nameKo: "대수구" },
      { code: "dashe", nameEn: "Dashe District", nameZh: "大社區", nameJa: "大社区", nameKo: "대사구" },
      { code: "renwu", nameEn: "Renwu District", nameZh: "仁武區", nameJa: "仁武区", nameKo: "인무구" },
      { code: "niaosong", nameEn: "Niaosong District", nameZh: "鳥松區", nameJa: "鳥松区", nameKo: "조송구" },
      { code: "gangshan", nameEn: "Gangshan District", nameZh: "岡山區", nameJa: "岡山区", nameKo: "강산구" },
      { code: "qiaotou", nameEn: "Qiaotou District", nameZh: "橋頭區", nameJa: "橋頭区", nameKo: "교두구" },
      { code: "yanchao", nameEn: "Yanchao District", nameZh: "燕巢區", nameJa: "燕巣区", nameKo: "연소구" },
      { code: "tianliao", nameEn: "Tianliao District", nameZh: "田寮區", nameJa: "田寮区", nameKo: "전료구" },
      { code: "alian", nameEn: "Alian District", nameZh: "阿蓮區", nameJa: "阿蓮区", nameKo: "아련구" },
      { code: "luzhu_kh", nameEn: "Luzhu District", nameZh: "路竹區", nameJa: "路竹区", nameKo: "로죽구" },
      { code: "hunei", nameEn: "Hunei District", nameZh: "湖內區", nameJa: "湖内区", nameKo: "호내구" },
      { code: "qieding", nameEn: "Qieding District", nameZh: "茄萣區", nameJa: "茄萣区", nameKo: "가정구" },
      { code: "yongan", nameEn: "Yong'an District", nameZh: "永安區", nameJa: "永安区", nameKo: "영안구" },
      { code: "mituo", nameEn: "Mituo District", nameZh: "彌陀區", nameJa: "弥陀区", nameKo: "미타구" },
      { code: "ziguan", nameEn: "Ziguan District", nameZh: "梓官區", nameJa: "梓官区", nameKo: "자관구" },
      { code: "qishan", nameEn: "Qishan District", nameZh: "旗山區", nameJa: "旗山区", nameKo: "기산구" },
      { code: "meinong", nameEn: "Meinong District", nameZh: "美濃區", nameJa: "美濃区", nameKo: "미농구" },
      { code: "liugui", nameEn: "Liugui District", nameZh: "六龜區", nameJa: "六亀区", nameKo: "육귀구" },
      { code: "jiaxian", nameEn: "Jiaxian District", nameZh: "甲仙區", nameJa: "甲仙区", nameKo: "갑선구" },
      { code: "shanlin", nameEn: "Shanlin District", nameZh: "杉林區", nameJa: "杉林区", nameKo: "삼림구" },
      { code: "neimen", nameEn: "Neimen District", nameZh: "內門區", nameJa: "内門区", nameKo: "내문구" },
      { code: "maolin", nameEn: "Maolin District", nameZh: "茂林區", nameJa: "茂林区", nameKo: "무림구" },
      { code: "taoyuan_kh", nameEn: "Taoyuan District", nameZh: "桃源區", nameJa: "桃源区", nameKo: "도원구" },
      { code: "namaxia", nameEn: "Namaxia District", nameZh: "那瑪夏區", nameJa: "那瑪夏区", nameKo: "나마하구" },
    ],
    keelung_city: [
      { code: "ren_ai", nameEn: "Ren'ai District", nameZh: "仁愛區", nameJa: "仁愛区", nameKo: "인애구" },
      { code: "xinyi_kl", nameEn: "Xinyi District", nameZh: "信義區", nameJa: "信義区", nameKo: "신의구" },
      { code: "zhongzheng_kl", nameEn: "Zhongzheng District", nameZh: "中正區", nameJa: "中正区", nameKo: "중정구" },
      { code: "zhongshan_kl", nameEn: "Zhongshan District", nameZh: "中山區", nameJa: "中山区", nameKo: "중산구" },
      { code: "anle", nameEn: "Anle District", nameZh: "安樂區", nameJa: "安楽区", nameKo: "안락구" },
      { code: "nuannuan", nameEn: "Nuannuan District", nameZh: "暖暖區", nameJa: "暖暖区", nameKo: "난난구" },
      { code: "qidu", nameEn: "Qidu District", nameZh: "七堵區", nameJa: "七堵区", nameKo: "칠두구" },
    ],
    hsinchu_city: [
      { code: "east_hc", nameEn: "East District", nameZh: "東區", nameJa: "東区", nameKo: "동구" },
      { code: "north_hc", nameEn: "North District", nameZh: "北區", nameJa: "北区", nameKo: "북구" },
      { code: "xiangshan", nameEn: "Xiangshan District", nameZh: "香山區", nameJa: "香山区", nameKo: "향산구" },
    ],
    chiayi_city: [
      { code: "east_cy", nameEn: "East District", nameZh: "東區", nameJa: "東区", nameKo: "동구" },
      { code: "west_cy", nameEn: "West District", nameZh: "西區", nameJa: "西区", nameKo: "서구" },
    ],
    hsinchu_county: [
      { code: "zhubei", nameEn: "Zhubei City", nameZh: "竹北市", nameJa: "竹北市", nameKo: "죽북시" },
      { code: "zhudong", nameEn: "Zhudong Township", nameZh: "竹東鎮", nameJa: "竹東鎮", nameKo: "죽동진" },
      { code: "xinpu", nameEn: "Xinpu Township", nameZh: "新埔鎮", nameJa: "新埔鎮", nameKo: "신포진" },
      { code: "guanxi", nameEn: "Guanxi Township", nameZh: "關西鎮", nameJa: "関西鎮", nameKo: "관서진" },
      { code: "hukou", nameEn: "Hukou Township", nameZh: "湖口鄉", nameJa: "湖口郷", nameKo: "호구향" },
      { code: "xinfeng", nameEn: "Xinfeng Township", nameZh: "新豐鄉", nameJa: "新豊郷", nameKo: "신풍향" },
      { code: "qionglin", nameEn: "Qionglin Township", nameZh: "芎林鄉", nameJa: "芎林郷", nameKo: "궁림향" },
      { code: "hengshan", nameEn: "Hengshan Township", nameZh: "橫山鄉", nameJa: "横山郷", nameKo: "횡산향" },
      { code: "beipu", nameEn: "Beipu Township", nameZh: "北埔鄉", nameJa: "北埔郷", nameKo: "북포향" },
      { code: "baoshan", nameEn: "Baoshan Township", nameZh: "寶山鄉", nameJa: "宝山郷", nameKo: "보산향" },
      { code: "emei", nameEn: "Emei Township", nameZh: "峨眉鄉", nameJa: "峨眉郷", nameKo: "아미향" },
      { code: "jianshi", nameEn: "Jianshi Township", nameZh: "尖石鄉", nameJa: "尖石郷", nameKo: "첨석향" },
      { code: "wufeng_hc", nameEn: "Wufeng Township", nameZh: "五峰鄉", nameJa: "五峰郷", nameKo: "오봉향" },
    ],
    miaoli_county: [
      { code: "miaoli", nameEn: "Miaoli City", nameZh: "苗栗市", nameJa: "苗栗市", nameKo: "묘율시" },
      { code: "toufen", nameEn: "Toufen City", nameZh: "頭份市", nameJa: "頭份市", nameKo: "두분시" },
      { code: "yuanli", nameEn: "Yuanli Township", nameZh: "苑裡鎮", nameJa: "苑裡鎮", nameKo: "원리진" },
      { code: "tongxiao", nameEn: "Tongxiao Township", nameZh: "通霄鎮", nameJa: "通霄鎮", nameKo: "통소진" },
      { code: "zhunan", nameEn: "Zhunan Township", nameZh: "竹南鎮", nameJa: "竹南鎮", nameKo: "죽남진" },
      { code: "houlong", nameEn: "Houlong Township", nameZh: "後龍鎮", nameJa: "後龍鎮", nameKo: "후룡진" },
      { code: "zhuolan", nameEn: "Zhuolan Township", nameZh: "卓蘭鎮", nameJa: "卓蘭鎮", nameKo: "탁란진" },
      { code: "dahu", nameEn: "Dahu Township", nameZh: "大湖鄉", nameJa: "大湖郷", nameKo: "대호향" },
      { code: "gongguan", nameEn: "Gongguan Township", nameZh: "公館鄉", nameJa: "公館郷", nameKo: "공관향" },
      { code: "tongluo", nameEn: "Tongluo Township", nameZh: "銅鑼鄉", nameJa: "銅鑼郷", nameKo: "동라향" },
      { code: "nanzhuang", nameEn: "Nanzhuang Township", nameZh: "南庄鄉", nameJa: "南庄郷", nameKo: "남장향" },
      { code: "touwu", nameEn: "Touwu Township", nameZh: "頭屋鄉", nameJa: "頭屋郷", nameKo: "두옥향" },
      { code: "sanyi", nameEn: "Sanyi Township", nameZh: "三義鄉", nameJa: "三義郷", nameKo: "삼의향" },
      { code: "xihu", nameEn: "Xihu Township", nameZh: "西湖鄉", nameJa: "西湖郷", nameKo: "서호향" },
      { code: "zaoqiao", nameEn: "Zaoqiao Township", nameZh: "造橋鄉", nameJa: "造橋郷", nameKo: "조교향" },
      { code: "sanwan", nameEn: "Sanwan Township", nameZh: "三灣鄉", nameJa: "三湾郷", nameKo: "삼만향" },
      { code: "shitan", nameEn: "Shitan Township", nameZh: "獅潭鄉", nameJa: "獅潭郷", nameKo: "사담향" },
      { code: "taian", nameEn: "Tai'an Township", nameZh: "泰安鄉", nameJa: "泰安郷", nameKo: "태안향" },
    ],
    changhua_county: [
      { code: "changhua", nameEn: "Changhua City", nameZh: "彰化市", nameJa: "彰化市", nameKo: "창화시" },
      { code: "yuanlin", nameEn: "Yuanlin City", nameZh: "員林市", nameJa: "員林市", nameKo: "원림시" },
      { code: "lugang", nameEn: "Lugang Township", nameZh: "鹿港鎮", nameJa: "鹿港鎮", nameKo: "녹항진" },
      { code: "hemei", nameEn: "Hemei Township", nameZh: "和美鎮", nameJa: "和美鎮", nameKo: "화미진" },
      { code: "beidou", nameEn: "Beidou Township", nameZh: "北斗鎮", nameJa: "北斗鎮", nameKo: "북두진" },
      { code: "xihu_ch", nameEn: "Xihu Township", nameZh: "溪湖鎮", nameJa: "渓湖鎮", nameKo: "계호진" },
      { code: "tianzhong", nameEn: "Tianzhong Township", nameZh: "田中鎮", nameJa: "田中鎮", nameKo: "전중진" },
      { code: "erlin", nameEn: "Erlin Township", nameZh: "二林鎮", nameJa: "二林鎮", nameKo: "이림진" },
      { code: "xianxi", nameEn: "Xianxi Township", nameZh: "線西鄉", nameJa: "線西郷", nameKo: "선서향" },
      { code: "shengang_ch", nameEn: "Shengang Township", nameZh: "伸港鄉", nameJa: "伸港郷", nameKo: "신항향" },
      { code: "fuxing_ch", nameEn: "Fuxing Township", nameZh: "福興鄉", nameJa: "福興郷", nameKo: "복흥향" },
      { code: "xiushui", nameEn: "Xiushui Township", nameZh: "秀水鄉", nameJa: "秀水郷", nameKo: "수수향" },
      { code: "huatan", nameEn: "Huatan Township", nameZh: "花壇鄉", nameJa: "花壇郷", nameKo: "화단향" },
      { code: "fenyuan", nameEn: "Fenyuan Township", nameZh: "芬園鄉", nameJa: "芬園郷", nameKo: "분원향" },
      { code: "dacun", nameEn: "Dacun Township", nameZh: "大村鄉", nameJa: "大村郷", nameKo: "대촌향" },
      { code: "puyan", nameEn: "Puyan Township", nameZh: "埔鹽鄉", nameJa: "埔塩郷", nameKo: "포염향" },
      { code: "puxin", nameEn: "Puxin Township", nameZh: "埔心鄉", nameJa: "埔心郷", nameKo: "포심향" },
      { code: "yongjing", nameEn: "Yongjing Township", nameZh: "永靖鄉", nameJa: "永靖郷", nameKo: "영정향" },
      { code: "shetou", nameEn: "Shetou Township", nameZh: "社頭鄉", nameJa: "社頭郷", nameKo: "사두향" },
      { code: "ershui", nameEn: "Ershui Township", nameZh: "二水鄉", nameJa: "二水郷", nameKo: "이수향" },
      { code: "tianwei", nameEn: "Tianwei Township", nameZh: "田尾鄉", nameJa: "田尾郷", nameKo: "전미향" },
      { code: "pitou", nameEn: "Pitou Township", nameZh: "埤頭鄉", nameJa: "埤頭郷", nameKo: "비두향" },
      { code: "fangyuan", nameEn: "Fangyuan Township", nameZh: "芳苑鄉", nameJa: "芳苑郷", nameKo: "방원향" },
      { code: "dacheng", nameEn: "Dacheng Township", nameZh: "大城鄉", nameJa: "大城郷", nameKo: "대성향" },
      { code: "zhutang", nameEn: "Zhutang Township", nameZh: "竹塘鄉", nameJa: "竹塘郷", nameKo: "죽당향" },
      { code: "xizhou", nameEn: "Xizhou Township", nameZh: "溪州鄉", nameJa: "渓州郷", nameKo: "계주향" },
    ],
    nantou_county: [
      { code: "nantou", nameEn: "Nantou City", nameZh: "南投市", nameJa: "南投市", nameKo: "남투시" },
      { code: "puli", nameEn: "Puli Township", nameZh: "埔里鎮", nameJa: "埔里鎮", nameKo: "포리진" },
      { code: "caotun", nameEn: "Caotun Township", nameZh: "草屯鎮", nameJa: "草屯鎮", nameKo: "초둔진" },
      { code: "zhushan", nameEn: "Zhushan Township", nameZh: "竹山鎮", nameJa: "竹山鎮", nameKo: "죽산진" },
      { code: "jiji", nameEn: "Jiji Township", nameZh: "集集鎮", nameJa: "集集鎮", nameKo: "집집진" },
      { code: "mingjian", nameEn: "Mingjian Township", nameZh: "名間鄉", nameJa: "名間郷", nameKo: "명간향" },
      { code: "lugu", nameEn: "Lugu Township", nameZh: "鹿谷鄉", nameJa: "鹿谷郷", nameKo: "록곡향" },
      { code: "zhongliao", nameEn: "Zhongliao Township", nameZh: "中寮鄉", nameJa: "中寮郷", nameKo: "중료향" },
      { code: "yuchi", nameEn: "Yuchi Township", nameZh: "魚池鄉", nameJa: "魚池郷", nameKo: "어지향" },
      { code: "guoxing", nameEn: "Guoxing Township", nameZh: "國姓鄉", nameJa: "国姓郷", nameKo: "국성향" },
      { code: "shuili", nameEn: "Shuili Township", nameZh: "水里鄉", nameJa: "水里郷", nameKo: "수리향" },
      { code: "xinyi_nt", nameEn: "Xinyi Township", nameZh: "信義鄉", nameJa: "信義郷", nameKo: "신의향" },
      { code: "renai", nameEn: "Ren'ai Township", nameZh: "仁愛鄉", nameJa: "仁愛郷", nameKo: "인애향" },
    ],
    yunlin_county: [
      { code: "douliu", nameEn: "Douliu City", nameZh: "斗六市", nameJa: "斗六市", nameKo: "두육시" },
      { code: "dounan", nameEn: "Dounan Township", nameZh: "斗南鎮", nameJa: "斗南鎮", nameKo: "두남진" },
      { code: "huwei", nameEn: "Huwei Township", nameZh: "虎尾鎮", nameJa: "虎尾鎮", nameKo: "호미진" },
      { code: "xiluo", nameEn: "Xiluo Township", nameZh: "西螺鎮", nameJa: "西螺鎮", nameKo: "서라진" },
      { code: "tuku", nameEn: "Tuku Township", nameZh: "土庫鎮", nameJa: "土庫鎮", nameKo: "토고진" },
      { code: "beigang", nameEn: "Beigang Township", nameZh: "北港鎮", nameJa: "北港鎮", nameKo: "북항진" },
      { code: "gukeng", nameEn: "Gukeng Township", nameZh: "古坑鄉", nameJa: "古坑郷", nameKo: "고갱향" },
      { code: "dapi", nameEn: "Dapi Township", nameZh: "大埤鄉", nameJa: "大埤郷", nameKo: "대비향" },
      { code: "citong", nameEn: "Citong Township", nameZh: "莿桐鄉", nameJa: "莿桐郷", nameKo: "자동향" },
      { code: "linnei", nameEn: "Linnei Township", nameZh: "林內鄉", nameJa: "林内郷", nameKo: "임내향" },
      { code: "erlun", nameEn: "Erlun Township", nameZh: "二崙鄉", nameJa: "二崙郷", nameKo: "이륜향" },
      { code: "lunbei", nameEn: "Lunbei Township", nameZh: "崙背鄉", nameJa: "崙背郷", nameKo: "륜배향" },
      { code: "mailiao", nameEn: "Mailiao Township", nameZh: "麥寮鄉", nameJa: "麦寮郷", nameKo: "맥료향" },
      { code: "dongshi_yl", nameEn: "Dongshi Township", nameZh: "東勢鄉", nameJa: "東勢郷", nameKo: "동세향" },
      { code: "baozhong", nameEn: "Baozhong Township", nameZh: "褒忠鄉", nameJa: "褒忠郷", nameKo: "포충향" },
      { code: "taixi", nameEn: "Taixi Township", nameZh: "臺西鄉", nameJa: "台西郷", nameKo: "태서향" },
      { code: "yuanchang", nameEn: "Yuanchang Township", nameZh: "元長鄉", nameJa: "元長郷", nameKo: "원장향" },
      { code: "sihu", nameEn: "Sihu Township", nameZh: "四湖鄉", nameJa: "四湖郷", nameKo: "사호향" },
      { code: "kouhu", nameEn: "Kouhu Township", nameZh: "口湖鄉", nameJa: "口湖郷", nameKo: "구호향" },
      { code: "shuilin", nameEn: "Shuilin Township", nameZh: "水林鄉", nameJa: "水林郷", nameKo: "수림향" },
    ],
    chiayi_county: [
      { code: "taibao", nameEn: "Taibao City", nameZh: "太保市", nameJa: "太保市", nameKo: "태보시" },
      { code: "puzi", nameEn: "Puzi City", nameZh: "朴子市", nameJa: "朴子市", nameKo: "박자시" },
      { code: "budai", nameEn: "Budai Township", nameZh: "布袋鎮", nameJa: "布袋鎮", nameKo: "포대진" },
      { code: "dalin", nameEn: "Dalin Township", nameZh: "大林鎮", nameJa: "大林鎮", nameKo: "대림진" },
      { code: "minxiong", nameEn: "Minxiong Township", nameZh: "民雄鄉", nameJa: "民雄郷", nameKo: "민웅향" },
      { code: "xikou", nameEn: "Xikou Township", nameZh: "溪口鄉", nameJa: "渓口郷", nameKo: "계구향" },
      { code: "xingang", nameEn: "Xingang Township", nameZh: "新港鄉", nameJa: "新港郷", nameKo: "신항향" },
      { code: "liujiao", nameEn: "Liujiao Township", nameZh: "六腳鄉", nameJa: "六脚郷", nameKo: "육각향" },
      { code: "dongshi_cy", nameEn: "Dongshi Township", nameZh: "東石鄉", nameJa: "東石郷", nameKo: "동석향" },
      { code: "yizhu", nameEn: "Yizhu Township", nameZh: "義竹鄉", nameJa: "義竹郷", nameKo: "의죽향" },
      { code: "lucao", nameEn: "Lucao Township", nameZh: "鹿草鄉", nameJa: "鹿草郷", nameKo: "녹초향" },
      { code: "shuishang", nameEn: "Shuishang Township", nameZh: "水上鄉", nameJa: "水上郷", nameKo: "수상향" },
      { code: "zhongpu", nameEn: "Zhongpu Township", nameZh: "中埔鄉", nameJa: "中埔郷", nameKo: "중포향" },
      { code: "zhuqi", nameEn: "Zhuqi Township", nameZh: "竹崎鄉", nameJa: "竹崎郷", nameKo: "죽기향" },
      { code: "meishan", nameEn: "Meishan Township", nameZh: "梅山鄉", nameJa: "梅山郷", nameKo: "매산향" },
      { code: "fanlu", nameEn: "Fanlu Township", nameZh: "番路鄉", nameJa: "番路郷", nameKo: "번로향" },
      { code: "dapu", nameEn: "Dapu Township", nameZh: "大埔鄉", nameJa: "大埔郷", nameKo: "대포향" },
      { code: "alishan", nameEn: "Alishan Township", nameZh: "阿里山鄉", nameJa: "阿里山郷", nameKo: "아리산향" },
    ],
    pingtung_county: [
      { code: "pingtung", nameEn: "Pingtung City", nameZh: "屏東市", nameJa: "屏東市", nameKo: "핑둥시" },
      { code: "chaozhou", nameEn: "Chaozhou Township", nameZh: "潮州鎮", nameJa: "潮州鎮", nameKo: "조주진" },
      { code: "donggang", nameEn: "Donggang Township", nameZh: "東港鎮", nameJa: "東港鎮", nameKo: "동항진" },
      { code: "hengchun", nameEn: "Hengchun Township", nameZh: "恆春鎮", nameJa: "恆春鎮", nameKo: "항춘진" },
      { code: "wandan", nameEn: "Wandan Township", nameZh: "萬丹鄉", nameJa: "萬丹郷", nameKo: "만단향" },
      { code: "changzhi", nameEn: "Changzhi Township", nameZh: "長治鄉", nameJa: "長治郷", nameKo: "장치향" },
      { code: "linluo", nameEn: "Linluo Township", nameZh: "麟洛鄉", nameJa: "麟洛郷", nameKo: "인락향" },
      { code: "jiuru", nameEn: "Jiuru Township", nameZh: "九如鄉", nameJa: "九如郷", nameKo: "구여향" },
      { code: "ligang", nameEn: "Ligang Township", nameZh: "里港鄉", nameJa: "里港郷", nameKo: "이항향" },
      { code: "yanpu", nameEn: "Yanpu Township", nameZh: "鹽埔鄉", nameJa: "塩埔郷", nameKo: "염포향" },
      { code: "gaoshu", nameEn: "Gaoshu Township", nameZh: "高樹鄉", nameJa: "高樹郷", nameKo: "고수향" },
      { code: "wanluan", nameEn: "Wanluan Township", nameZh: "萬巒鄉", nameJa: "萬巒郷", nameKo: "만만향" },
      { code: "neipu", nameEn: "Neipu Township", nameZh: "內埔鄉", nameJa: "内埔郷", nameKo: "내포향" },
      { code: "zhutian", nameEn: "Zhutian Township", nameZh: "竹田鄉", nameJa: "竹田郷", nameKo: "죽전향" },
      { code: "xinpi", nameEn: "Xinpi Township", nameZh: "新埤鄉", nameJa: "新埤郷", nameKo: "신비향" },
      { code: "fangliao", nameEn: "Fangliao Township", nameZh: "枋寮鄉", nameJa: "枋寮郷", nameKo: "방료향" },
      { code: "xinyuan", nameEn: "Xinyuan Township", nameZh: "新園鄉", nameJa: "新園郷", nameKo: "신원향" },
      { code: "kanding", nameEn: "Kanding Township", nameZh: "崁頂鄉", nameJa: "崁頂郷", nameKo: "감정향" },
      { code: "linbian", nameEn: "Linbian Township", nameZh: "林邊鄉", nameJa: "林辺郷", nameKo: "임변향" },
      { code: "nanzhou", nameEn: "Nanzhou Township", nameZh: "南州鄉", nameJa: "南州郷", nameKo: "남주향" },
      { code: "jiadong", nameEn: "Jiadong Township", nameZh: "佳冬鄉", nameJa: "佳冬郷", nameKo: "가동향" },
      { code: "liuqiu", nameEn: "Liuqiu Township", nameZh: "琉球鄉", nameJa: "琉球郷", nameKo: "유구향" },
      { code: "checheng", nameEn: "Checheng Township", nameZh: "車城鄉", nameJa: "車城郷", nameKo: "차성향" },
      { code: "manzhou", nameEn: "Manzhou Township", nameZh: "滿州鄉", nameJa: "満州郷", nameKo: "만주향" },
      { code: "fangshan", nameEn: "Fangshan Township", nameZh: "枋山鄉", nameJa: "枋山郷", nameKo: "방산향" },
      { code: "sandimen", nameEn: "Sandimen Township", nameZh: "三地門鄉", nameJa: "三地門郷", nameKo: "삼지문향" },
      { code: "wutai", nameEn: "Wutai Township", nameZh: "霧臺鄉", nameJa: "霧台郷", nameKo: "무대향" },
      { code: "majia", nameEn: "Majia Township", nameZh: "瑪家鄉", nameJa: "瑪家郷", nameKo: "마가향" },
      { code: "taiwu", nameEn: "Taiwu Township", nameZh: "泰武鄉", nameJa: "泰武郷", nameKo: "태무향" },
      { code: "laiyi", nameEn: "Laiyi Township", nameZh: "來義鄉", nameJa: "來義郷", nameKo: "래의향" },
      { code: "chunri", nameEn: "Chunri Township", nameZh: "春日鄉", nameJa: "春日郷", nameKo: "춘일향" },
      { code: "shizi", nameEn: "Shizi Township", nameZh: "獅子鄉", nameJa: "獅子郷", nameKo: "사자향" },
      { code: "mudan", nameEn: "Mudan Township", nameZh: "牡丹鄉", nameJa: "牡丹郷", nameKo: "모란향" },
    ],
    yilan_county: [
      { code: "yilan", nameEn: "Yilan City", nameZh: "宜蘭市", nameJa: "宜蘭市", nameKo: "의란시" },
      { code: "luodong", nameEn: "Luodong Township", nameZh: "羅東鎮", nameJa: "羅東鎮", nameKo: "라동진" },
      { code: "suao", nameEn: "Su'ao Township", nameZh: "蘇澳鎮", nameJa: "蘇澳鎮", nameKo: "소오진" },
      { code: "toucheng", nameEn: "Toucheng Township", nameZh: "頭城鎮", nameJa: "頭城鎮", nameKo: "두성진" },
      { code: "jiaoxi", nameEn: "Jiaoxi Township", nameZh: "礁溪鄉", nameJa: "礁溪郷", nameKo: "초계향" },
      { code: "zhuangwei", nameEn: "Zhuangwei Township", nameZh: "壯圍鄉", nameJa: "壮囲郷", nameKo: "장위향" },
      { code: "yuanshan", nameEn: "Yuanshan Township", nameZh: "員山鄉", nameJa: "員山郷", nameKo: "원산향" },
      { code: "dongshan_yl", nameEn: "Dongshan Township", nameZh: "冬山鄉", nameJa: "冬山郷", nameKo: "동산향" },
      { code: "wujie", nameEn: "Wujie Township", nameZh: "五結鄉", nameJa: "五結郷", nameKo: "오결향" },
      { code: "sanxing", nameEn: "Sanxing Township", nameZh: "三星鄉", nameJa: "三星郷", nameKo: "삼성향" },
      { code: "datong_yl", nameEn: "Datong Township", nameZh: "大同鄉", nameJa: "大同郷", nameKo: "대동향" },
      { code: "nanao", nameEn: "Nan'ao Township", nameZh: "南澳鄉", nameJa: "南澳郷", nameKo: "남오향" },
    ],
    hualien_county: [
      { code: "hualien", nameEn: "Hualien City", nameZh: "花蓮市", nameJa: "花蓮市", nameKo: "화련시" },
      { code: "fenglin", nameEn: "Fenglin Township", nameZh: "鳳林鎮", nameJa: "鳳林鎮", nameKo: "봉림진" },
      { code: "yuli", nameEn: "Yuli Township", nameZh: "玉里鎮", nameJa: "玉里鎮", nameKo: "옥리진" },
      { code: "xincheng", nameEn: "Xincheng Township", nameZh: "新城鄉", nameJa: "新城郷", nameKo: "신성향" },
      { code: "ji_an", nameEn: "Ji'an Township", nameZh: "吉安鄉", nameJa: "吉安郷", nameKo: "길안향" },
      { code: "shoufeng", nameEn: "Shoufeng Township", nameZh: "壽豐鄉", nameJa: "壽豊郷", nameKo: "수풍향" },
      { code: "guangfu", nameEn: "Guangfu Township", nameZh: "光復鄉", nameJa: "光復郷", nameKo: "광복향" },
      { code: "fengbin", nameEn: "Fengbin Township", nameZh: "豐濱鄉", nameJa: "豊浜郷", nameKo: "풍빈향" },
      { code: "ruisui", nameEn: "Ruisui Township", nameZh: "瑞穗鄉", nameJa: "瑞穂郷", nameKo: "서수향" },
      { code: "fuli", nameEn: "Fuli Township", nameZh: "富里鄉", nameJa: "富里郷", nameKo: "부리향" },
      { code: "xiulin", nameEn: "Xiulin Township", nameZh: "秀林鄉", nameJa: "秀林郷", nameKo: "수림향" },
      { code: "wanrong", nameEn: "Wanrong Township", nameZh: "萬榮鄉", nameJa: "萬榮郷", nameKo: "만영향" },
      { code: "zhuoxi", nameEn: "Zhuoxi Township", nameZh: "卓溪鄉", nameJa: "卓渓郷", nameKo: "탁계향" },
    ],
    taitung_county: [
      { code: "taitung", nameEn: "Taitung City", nameZh: "臺東市", nameJa: "台東市", nameKo: "태동시" },
      { code: "chenggong", nameEn: "Chenggong Township", nameZh: "成功鎮", nameJa: "成功鎮", nameKo: "성공진" },
      { code: "guanshan", nameEn: "Guanshan Township", nameZh: "關山鎮", nameJa: "関山鎮", nameKo: "관산진" },
      { code: "beinan", nameEn: "Beinan Township", nameZh: "卑南鄉", nameJa: "卑南郷", nameKo: "비남향" },
      { code: "dawu", nameEn: "Dawu Township", nameZh: "大武鄉", nameJa: "大武郷", nameKo: "대무향" },
      { code: "taimali", nameEn: "Taimali Township", nameZh: "太麻里鄉", nameJa: "太麻里郷", nameKo: "태마리향" },
      { code: "donghe", nameEn: "Donghe Township", nameZh: "東河鄉", nameJa: "東河郷", nameKo: "동하향" },
      { code: "changbin", nameEn: "Changbin Township", nameZh: "長濱鄉", nameJa: "長浜郷", nameKo: "장빈향" },
      { code: "luye", nameEn: "Luye Township", nameZh: "鹿野鄉", nameJa: "鹿野郷", nameKo: "녹야향" },
      { code: "chishang", nameEn: "Chishang Township", nameZh: "池上鄉", nameJa: "池上郷", nameKo: "지상향" },
      { code: "green_island", nameEn: "Green Island", nameZh: "綠島鄉", nameJa: "緑島郷", nameKo: "녹도향" },
      { code: "yanping", nameEn: "Yanping Township", nameZh: "延平鄉", nameJa: "延平郷", nameKo: "연평향" },
      { code: "haiduan", nameEn: "Haiduan Township", nameZh: "海端鄉", nameJa: "海端郷", nameKo: "해단향" },
      { code: "daren", nameEn: "Daren Township", nameZh: "達仁鄉", nameJa: "達仁郷", nameKo: "달인향" },
      { code: "jinfeng", nameEn: "Jinfeng Township", nameZh: "金峰鄉", nameJa: "金峰郷", nameKo: "금봉향" },
      { code: "orchid_island", nameEn: "Orchid Island", nameZh: "蘭嶼鄉", nameJa: "蘭嶼郷", nameKo: "난서향" },
    ],
    penghu_county: [
      { code: "magong", nameEn: "Magong City", nameZh: "馬公市", nameJa: "馬公市", nameKo: "마공시" },
      { code: "huxi", nameEn: "Huxi Township", nameZh: "湖西鄉", nameJa: "湖西郷", nameKo: "호서향" },
      { code: "baisha", nameEn: "Baisha Township", nameZh: "白沙鄉", nameJa: "白沙郷", nameKo: "백사향" },
      { code: "xiyu", nameEn: "Xiyu Township", nameZh: "西嶼鄉", nameJa: "西嶼郷", nameKo: "서서향" },
      { code: "wangan", nameEn: "Wang'an Township", nameZh: "望安鄉", nameJa: "望安郷", nameKo: "망안향" },
      { code: "qimei", nameEn: "Qimei Township", nameZh: "七美鄉", nameJa: "七美郷", nameKo: "칠미향" },
    ],
    kinmen_county: [
      { code: "jincheng", nameEn: "Jincheng Township", nameZh: "金城鎮", nameJa: "金城鎮", nameKo: "금성진" },
      { code: "jinhu", nameEn: "Jinhu Township", nameZh: "金湖鎮", nameJa: "金湖鎮", nameKo: "금호진" },
      { code: "jinsha", nameEn: "Jinsha Township", nameZh: "金沙鎮", nameJa: "金沙鎮", nameKo: "금사진" },
      { code: "jinning", nameEn: "Jinning Township", nameZh: "金寧鄉", nameJa: "金寧郷", nameKo: "금녕향" },
      { code: "lieyu", nameEn: "Lieyu Township", nameZh: "烈嶼鄉", nameJa: "烈嶼郷", nameKo: "열서향" },
      { code: "wuqiu", nameEn: "Wuqiu Township", nameZh: "烏坵鄉", nameJa: "烏坵郷", nameKo: "오구향" },
    ],
    lienchiang_county: [
      { code: "nangan", nameEn: "Nangan Township", nameZh: "南竿鄉", nameJa: "南竿郷", nameKo: "남간향" },
      { code: "beigan", nameEn: "Beigan Township", nameZh: "北竿鄉", nameJa: "北竿郷", nameKo: "북간향" },
      { code: "juguang", nameEn: "Juguang Township", nameZh: "莒光鄉", nameJa: "莒光郷", nameKo: "거광향" },
      { code: "dongyin", nameEn: "Dongyin Township", nameZh: "東引鄉", nameJa: "東引郷", nameKo: "동인향" },
    ],
  };

  for (const [regionCode, districtList] of Object.entries(districtData)) {
    const regionId = regionMap[regionCode];
    if (!regionId) continue;
    
    for (const district of districtList) {
      await db.insert(districts).values({
        regionId,
        ...district,
        isActive: true,
      }).onConflictDoNothing();
    }
  }

  console.log("Districts seeded");

  // ============ CATEGORIES ============
  const categoryData = [
    { code: "food", nameEn: "Food", nameZh: "食", nameJa: "食事", nameKo: "음식", colorHex: "#ef4444", sortOrder: 1 },
    { code: "stay", nameEn: "Accommodation", nameZh: "宿", nameJa: "宿泊", nameKo: "숙박", colorHex: "#8b5cf6", sortOrder: 2 },
    { code: "education", nameEn: "Culture & Education", nameZh: "生態文化教育", nameJa: "文化教育", nameKo: "문화교육", colorHex: "#10b981", sortOrder: 3 },
    { code: "experience", nameEn: "Tours & Experiences", nameZh: "遊程體驗", nameJa: "体験ツアー", nameKo: "체험투어", colorHex: "#f59e0b", sortOrder: 4 },
    { code: "entertainment", nameEn: "Entertainment", nameZh: "娛樂設施", nameJa: "エンタメ", nameKo: "오락", colorHex: "#ec4899", sortOrder: 5 },
    { code: "activity", nameEn: "Activities", nameZh: "活動", nameJa: "アクティビティ", nameKo: "활동", colorHex: "#06b6d4", sortOrder: 6 },
    { code: "scenery", nameEn: "Scenery", nameZh: "景點", nameJa: "景色", nameKo: "경치", colorHex: "#84cc16", sortOrder: 7 },
    { code: "shopping", nameEn: "Shopping", nameZh: "購物", nameJa: "ショッピング", nameKo: "쇼핑", colorHex: "#6366f1", sortOrder: 8 },
  ];

  const categoryMap: Record<string, number> = {};
  for (const cat of categoryData) {
    const [inserted] = await db.insert(categories).values({
      ...cat,
      isActive: true,
    }).onConflictDoNothing().returning();
    if (inserted) categoryMap[cat.code] = inserted.id;
  }

  const allCategories = await db.select().from(categories);
  allCategories.forEach(c => { categoryMap[c.code] = c.id; });

  console.log("Categories seeded:", Object.keys(categoryMap).length);

  // ============ SUBCATEGORIES ============
  const subcategoryData: Record<string, Array<{ code: string; nameEn: string; nameZh: string; nameJa: string; nameKo: string; searchKeywords?: string }>> = {
    food: [
      { code: "hotpot", nameEn: "Hot Pot", nameZh: "火鍋", nameJa: "火鍋", nameKo: "훠궈", searchKeywords: "火鍋 hot pot 鍋物" },
      { code: "teppanyaki", nameEn: "Teppanyaki", nameZh: "鐵板燒", nameJa: "鉄板焼き", nameKo: "철판요리", searchKeywords: "鐵板燒 teppanyaki" },
      { code: "steak", nameEn: "Steak", nameZh: "排餐", nameJa: "ステーキ", nameKo: "스테이크", searchKeywords: "排餐 牛排 steak" },
      { code: "ramen", nameEn: "Ramen", nameZh: "拉麵", nameJa: "ラーメン", nameKo: "라멘", searchKeywords: "拉麵 ramen 麵" },
      { code: "sushi", nameEn: "Sushi", nameZh: "壽司", nameJa: "寿司", nameKo: "스시", searchKeywords: "壽司 sushi 日本料理" },
      { code: "italian", nameEn: "Italian", nameZh: "義式料理", nameJa: "イタリアン", nameKo: "이탈리안", searchKeywords: "義式 義大利 italian pasta pizza" },
      { code: "breakfast", nameEn: "Breakfast", nameZh: "早午餐", nameJa: "朝食", nameKo: "브런치", searchKeywords: "早午餐 brunch 早餐" },
      { code: "cafe", nameEn: "Cafe", nameZh: "咖啡廳", nameJa: "カフェ", nameKo: "카페", searchKeywords: "咖啡 cafe coffee" },
      { code: "dessert", nameEn: "Dessert", nameZh: "甜點", nameJa: "デザート", nameKo: "디저트", searchKeywords: "甜點 dessert 蛋糕" },
      { code: "nightmarket", nameEn: "Night Market", nameZh: "夜市", nameJa: "夜市", nameKo: "야시장", searchKeywords: "夜市 night market 小吃" },
      { code: "taiwanese", nameEn: "Taiwanese", nameZh: "台菜", nameJa: "台湾料理", nameKo: "대만요리", searchKeywords: "台菜 台灣料理 traditional taiwanese" },
      { code: "japanese", nameEn: "Japanese", nameZh: "日式料理", nameJa: "和食", nameKo: "일식", searchKeywords: "日式 日本料理 japanese" },
      { code: "korean", nameEn: "Korean", nameZh: "韓式料理", nameJa: "韓国料理", nameKo: "한식", searchKeywords: "韓式 韓國料理 korean bbq" },
      { code: "chinese", nameEn: "Chinese", nameZh: "中式料理", nameJa: "中華料理", nameKo: "중식", searchKeywords: "中式 中華料理 chinese" },
      { code: "seafood", nameEn: "Seafood", nameZh: "海鮮", nameJa: "シーフード", nameKo: "해산물", searchKeywords: "海鮮 seafood 海產" },
      { code: "vegetarian", nameEn: "Vegetarian", nameZh: "素食", nameJa: "ベジタリアン", nameKo: "채식", searchKeywords: "素食 vegetarian vegan" },
      { code: "bbq", nameEn: "BBQ", nameZh: "燒烤", nameJa: "焼肉", nameKo: "바베큐", searchKeywords: "燒烤 bbq 烤肉" },
      { code: "teahouse", nameEn: "Tea House", nameZh: "茶館", nameJa: "茶館", nameKo: "찻집", searchKeywords: "茶館 tea house 喝茶" },
    ],
    stay: [
      { code: "luxury_hotel", nameEn: "Luxury Hotel", nameZh: "五星酒店", nameJa: "高級ホテル", nameKo: "럭셔리호텔", searchKeywords: "五星 luxury hotel 酒店" },
      { code: "boutique_hotel", nameEn: "Boutique Hotel", nameZh: "精品旅館", nameJa: "ブティックホテル", nameKo: "부티크호텔", searchKeywords: "精品 boutique hotel" },
      { code: "hostel", nameEn: "Hostel", nameZh: "青年旅舍", nameJa: "ホステル", nameKo: "호스텔", searchKeywords: "青年旅舍 hostel 背包客" },
      { code: "bnb", nameEn: "B&B", nameZh: "民宿", nameJa: "民宿", nameKo: "민박", searchKeywords: "民宿 bnb bed breakfast" },
      { code: "hot_spring", nameEn: "Hot Spring Hotel", nameZh: "溫泉旅館", nameJa: "温泉旅館", nameKo: "온천호텔", searchKeywords: "溫泉 hot spring 泡湯" },
      { code: "resort", nameEn: "Resort", nameZh: "度假村", nameJa: "リゾート", nameKo: "리조트", searchKeywords: "度假村 resort" },
    ],
    education: [
      { code: "museum", nameEn: "Museum", nameZh: "博物館", nameJa: "博物館", nameKo: "박물관", searchKeywords: "博物館 museum" },
      { code: "art_gallery", nameEn: "Art Gallery", nameZh: "美術館", nameJa: "美術館", nameKo: "미술관", searchKeywords: "美術館 art gallery" },
      { code: "temple", nameEn: "Temple", nameZh: "寺廟", nameJa: "寺院", nameKo: "사찰", searchKeywords: "寺廟 temple 宮廟" },
      { code: "historic_site", nameEn: "Historic Site", nameZh: "古蹟", nameJa: "史跡", nameKo: "유적지", searchKeywords: "古蹟 historic site 歷史" },
      { code: "eco_farm", nameEn: "Eco Farm", nameZh: "生態農場", nameJa: "エコファーム", nameKo: "생태농장", searchKeywords: "生態農場 eco farm 有機" },
      { code: "cultural_center", nameEn: "Cultural Center", nameZh: "文化中心", nameJa: "文化センター", nameKo: "문화센터", searchKeywords: "文化中心 cultural center" },
      { code: "library", nameEn: "Library", nameZh: "圖書館", nameJa: "図書館", nameKo: "도서관", searchKeywords: "圖書館 library" },
    ],
    experience: [
      { code: "cooking_class", nameEn: "Cooking Class", nameZh: "料理課程", nameJa: "料理教室", nameKo: "요리교실", searchKeywords: "料理課程 cooking class DIY" },
      { code: "tea_ceremony", nameEn: "Tea Ceremony", nameZh: "茶道體驗", nameJa: "茶道", nameKo: "다도체험", searchKeywords: "茶道 tea ceremony 泡茶" },
      { code: "pottery", nameEn: "Pottery", nameZh: "陶藝體驗", nameJa: "陶芸", nameKo: "도예체험", searchKeywords: "陶藝 pottery 手作" },
      { code: "guided_tour", nameEn: "Guided Tour", nameZh: "導覽行程", nameJa: "ガイドツアー", nameKo: "가이드투어", searchKeywords: "導覽 guided tour 遊程" },
      { code: "workshop", nameEn: "Workshop", nameZh: "手作工坊", nameJa: "ワークショップ", nameKo: "워크샵", searchKeywords: "手作 workshop DIY" },
      { code: "farm_experience", nameEn: "Farm Experience", nameZh: "農場體驗", nameJa: "農場体験", nameKo: "농장체험", searchKeywords: "農場體驗 farm experience 採果" },
    ],
    entertainment: [
      { code: "ktv", nameEn: "KTV", nameZh: "KTV", nameJa: "カラオケ", nameKo: "노래방", searchKeywords: "KTV karaoke 唱歌" },
      { code: "cinema", nameEn: "Cinema", nameZh: "電影院", nameJa: "映画館", nameKo: "영화관", searchKeywords: "電影院 cinema 電影" },
      { code: "arcade", nameEn: "Arcade", nameZh: "遊樂場", nameJa: "ゲームセンター", nameKo: "오락실", searchKeywords: "遊樂場 arcade 電玩" },
      { code: "theme_park", nameEn: "Theme Park", nameZh: "主題樂園", nameJa: "テーマパーク", nameKo: "테마파크", searchKeywords: "主題樂園 theme park 遊樂園" },
      { code: "escape_room", nameEn: "Escape Room", nameZh: "密室逃脫", nameJa: "脱出ゲーム", nameKo: "방탈출", searchKeywords: "密室逃脫 escape room" },
      { code: "bowling", nameEn: "Bowling", nameZh: "保齡球", nameJa: "ボウリング", nameKo: "볼링", searchKeywords: "保齡球 bowling" },
      { code: "nightclub", nameEn: "Night Club", nameZh: "夜店", nameJa: "ナイトクラブ", nameKo: "나이트클럽", searchKeywords: "夜店 night club bar" },
    ],
    activity: [
      { code: "hiking", nameEn: "Hiking", nameZh: "登山健行", nameJa: "ハイキング", nameKo: "하이킹", searchKeywords: "登山 hiking 步道" },
      { code: "cycling", nameEn: "Cycling", nameZh: "自行車", nameJa: "サイクリング", nameKo: "자전거", searchKeywords: "自行車 cycling 腳踏車" },
      { code: "water_sports", nameEn: "Water Sports", nameZh: "水上活動", nameJa: "ウォータースポーツ", nameKo: "수상스포츠", searchKeywords: "水上活動 water sports 衝浪" },
      { code: "diving", nameEn: "Diving", nameZh: "潛水", nameJa: "ダイビング", nameKo: "다이빙", searchKeywords: "潛水 diving 浮潛" },
      { code: "spa", nameEn: "Spa", nameZh: "SPA按摩", nameJa: "スパ", nameKo: "스파", searchKeywords: "SPA 按摩 massage" },
      { code: "yoga", nameEn: "Yoga", nameZh: "瑜珈", nameJa: "ヨガ", nameKo: "요가", searchKeywords: "瑜珈 yoga" },
      { code: "paragliding", nameEn: "Paragliding", nameZh: "滑翔傘", nameJa: "パラグライダー", nameKo: "패러글라이딩", searchKeywords: "滑翔傘 paragliding 飛行傘" },
    ],
    scenery: [
      { code: "mountain", nameEn: "Mountain", nameZh: "山景", nameJa: "山景", nameKo: "산경치", searchKeywords: "山景 mountain 高山" },
      { code: "ocean", nameEn: "Ocean View", nameZh: "海景", nameJa: "海景", nameKo: "바다경치", searchKeywords: "海景 ocean 海邊" },
      { code: "sunset", nameEn: "Sunset Spot", nameZh: "夕陽景點", nameJa: "夕日スポット", nameKo: "일몰명소", searchKeywords: "夕陽 sunset 日落" },
      { code: "night_view", nameEn: "Night View", nameZh: "夜景", nameJa: "夜景", nameKo: "야경", searchKeywords: "夜景 night view 城市燈火" },
      { code: "park", nameEn: "Park", nameZh: "公園", nameJa: "公園", nameKo: "공원", searchKeywords: "公園 park" },
      { code: "waterfall", nameEn: "Waterfall", nameZh: "瀑布", nameJa: "滝", nameKo: "폭포", searchKeywords: "瀑布 waterfall" },
      { code: "lake", nameEn: "Lake", nameZh: "湖泊", nameJa: "湖", nameKo: "호수", searchKeywords: "湖泊 lake 湖" },
      { code: "botanical_garden", nameEn: "Botanical Garden", nameZh: "植物園", nameJa: "植物園", nameKo: "식물원", searchKeywords: "植物園 botanical garden 花園" },
    ],
    shopping: [
      { code: "department_store", nameEn: "Department Store", nameZh: "百貨公司", nameJa: "デパート", nameKo: "백화점", searchKeywords: "百貨公司 department store" },
      { code: "shopping_mall", nameEn: "Shopping Mall", nameZh: "購物中心", nameJa: "ショッピングモール", nameKo: "쇼핑몰", searchKeywords: "購物中心 shopping mall" },
      { code: "market", nameEn: "Market", nameZh: "市場", nameJa: "市場", nameKo: "시장", searchKeywords: "市場 market 傳統市場" },
      { code: "outlet", nameEn: "Outlet", nameZh: "暢貨中心", nameJa: "アウトレット", nameKo: "아울렛", searchKeywords: "暢貨中心 outlet" },
      { code: "souvenir", nameEn: "Souvenir Shop", nameZh: "伴手禮店", nameJa: "お土産店", nameKo: "기념품점", searchKeywords: "伴手禮 souvenir 特產" },
      { code: "bookstore", nameEn: "Bookstore", nameZh: "書店", nameJa: "書店", nameKo: "서점", searchKeywords: "書店 bookstore" },
      { code: "fashion", nameEn: "Fashion Street", nameZh: "服飾街", nameJa: "ファッション街", nameKo: "패션거리", searchKeywords: "服飾 fashion 潮流" },
    ],
  };

  for (const [catCode, subList] of Object.entries(subcategoryData)) {
    const categoryId = categoryMap[catCode];
    if (!categoryId) continue;
    
    for (const sub of subList) {
      await db.insert(subcategories).values({
        categoryId,
        ...sub,
        isActive: true,
      }).onConflictDoNothing();
    }
  }

  console.log("Subcategories seeded");
  console.log("Database seed completed!");
}

seed().catch(console.error).finally(() => process.exit(0));


=== File: server/socketHandler.ts ===

import { Server as HttpServer } from 'http';
import { Server, Socket } from 'socket.io';
import { storage } from './storage';
import { verifyJwtToken } from './replitAuth';

interface LocationUpdate {
  lat: number;
  lng: number;
  timestamp?: number;
}

interface AuthenticatedSocket extends Socket {
  userId?: string;
  userRole?: string;
}

const userSocketMap = new Map<string, Set<string>>();
const specialistSocketMap = new Map<string, Set<string>>();

export function setupSocketIO(httpServer: HttpServer): Server {
  const io = new Server(httpServer, {
    cors: {
      origin: (origin, callback) => {
        if (!origin) return callback(null, true);
        if (origin.endsWith('.replit.dev') || origin.endsWith('.replit.app') || origin.includes('localhost') || origin.includes('exp.host')) {
          return callback(null, true);
        }
        callback(null, true);
      },
      credentials: true,
    },
    transports: ['websocket', 'polling'],
  });

  io.use(async (socket: AuthenticatedSocket, next) => {
    try {
      const token = socket.handshake.auth.token || socket.handshake.headers.authorization?.replace('Bearer ', '');
      
      if (!token) {
        return next(new Error('Authentication required'));
      }

      const decoded = verifyJwtToken(token);
      if (!decoded || !decoded.sub) {
        return next(new Error('Invalid token'));
      }

      socket.userId = decoded.sub;
      
      const user = await storage.getUser(decoded.sub);
      socket.userRole = user?.role || 'consumer';

      next();
    } catch (error) {
      next(new Error('Authentication failed'));
    }
  });

  io.on('connection', (socket: AuthenticatedSocket) => {
    const userId = socket.userId;
    const userRole = socket.userRole;

    if (!userId) {
      socket.disconnect();
      return;
    }

    console.log(`🔌 Socket connected: ${userId} (${userRole})`);

    if (!userSocketMap.has(userId)) {
      userSocketMap.set(userId, new Set());
    }
    userSocketMap.get(userId)!.add(socket.id);

    if (userRole === 'specialist') {
      if (!specialistSocketMap.has(userId)) {
        specialistSocketMap.set(userId, new Set());
      }
      specialistSocketMap.get(userId)!.add(socket.id);
    }

    socket.on('location_update', async (data: LocationUpdate) => {
      try {
        if (typeof data.lat !== 'number' || typeof data.lng !== 'number' || 
            Number.isNaN(data.lat) || Number.isNaN(data.lng)) {
          socket.emit('location_error', { error: 'Invalid coordinates' });
          return;
        }

        if (data.lat < -90 || data.lat > 90 || data.lng < -180 || data.lng > 180) {
          socket.emit('location_error', { error: 'Coordinates out of range' });
          return;
        }

        await storage.upsertUserLocation(userId, data.lat, data.lng, true);

        const activeService = await storage.getActiveServiceRelationByTraveler(userId);
        
        if (activeService) {
          const specialist = await storage.getSpecialistById(activeService.specialistId);
          
          if (specialist) {
            const specialistUserId = specialist.userId;
            const specialistSockets = specialistSocketMap.get(specialistUserId);
            
            if (specialistSockets && specialistSockets.size > 0) {
              const locationPayload = {
                travelerId: userId,
                serviceId: activeService.id,
                lat: data.lat,
                lng: data.lng,
                timestamp: data.timestamp || Date.now(),
              };

              specialistSockets.forEach(socketId => {
                io.to(socketId).emit('traveler_location', locationPayload);
              });

              console.log(`📍 Location forwarded: ${userId} → Specialist ${specialistUserId}`);
            }
          }
        }

        socket.emit('location_ack', { 
          success: true, 
          timestamp: Date.now(),
          serviceActive: !!activeService 
        });

      } catch (error) {
        console.error('Location update error:', error);
        socket.emit('location_error', { error: 'Failed to process location' });
      }
    });

    socket.on('specialist_subscribe', async (data: { serviceId?: number }) => {
      if (userRole !== 'specialist') {
        socket.emit('subscribe_error', { error: 'Only specialists can subscribe' });
        return;
      }

      try {
        const specialist = await storage.getSpecialistByUserId(userId);
        if (!specialist) {
          socket.emit('subscribe_error', { error: 'Specialist profile not found' });
          return;
        }

        const activeRelations = await storage.getActiveServiceRelationsBySpecialist(specialist.id);
        
        socket.emit('active_travelers', {
          count: activeRelations.length,
          travelers: activeRelations.map(r => ({
            serviceId: r.id,
            travelerId: r.travelerId,
            region: r.region,
            createdAt: r.createdAt,
          }))
        });

        console.log(`👀 Specialist ${userId} subscribed to ${activeRelations.length} travelers`);

      } catch (error) {
        console.error('Specialist subscribe error:', error);
        socket.emit('subscribe_error', { error: 'Failed to subscribe' });
      }
    });

    socket.on('disconnect', () => {
      console.log(`🔌 Socket disconnected: ${userId}`);
      
      const userSockets = userSocketMap.get(userId);
      if (userSockets) {
        userSockets.delete(socket.id);
        if (userSockets.size === 0) {
          userSocketMap.delete(userId);
        }
      }

      if (userRole === 'specialist') {
        const specialistSockets = specialistSocketMap.get(userId);
        if (specialistSockets) {
          specialistSockets.delete(socket.id);
          if (specialistSockets.size === 0) {
            specialistSocketMap.delete(userId);
          }
        }
      }
    });
  });

  console.log('🚀 Socket.IO initialized for real-time location tracking');
  
  return io;
}

export function getConnectedUsers(): string[] {
  return Array.from(userSocketMap.keys());
}

export function isUserOnline(userId: string): boolean {
  return userSocketMap.has(userId) && userSocketMap.get(userId)!.size > 0;
}


=== File: server/static.ts ===

import express, { type Express } from "express";
import fs from "fs";
import path from "path";

export function serveStatic(app: Express) {
  const distPath = path.resolve(__dirname, "public");
  if (!fs.existsSync(distPath)) {
    throw new Error(
      `Could not find the build directory: ${distPath}, make sure to build the client first`,
    );
  }

  app.use(express.static(distPath));

  // fall through to index.html if the file doesn't exist
  app.use("*", (_req, res) => {
    res.sendFile(path.resolve(distPath, "index.html"));
  });
}


=== File: server/storage.ts ===

import { 
  users, collections, merchants, coupons, placeCache, placeFeedback, merchantPlaceLinks,
  countries, regions, districts, categories, subcategories, chatInvites,
  placeProducts, cartItems, commerceOrders, klookProducts, messageHighlights,
  placeDrafts, placeApplications, userLocations, planners, serviceOrders, places,
  specialists, transactions, serviceRelations, announcements,
  adPlacements, userNotifications, couponRedemptions, userInventory, merchantCoupons,
  couponRarityConfigs, sosAlerts, merchantAnalytics, userDailyGachaStats, 
  tripPlans, tripDays, tripActivities, travelCompanions, sosEvents, 
  userProfiles, collectionReadStatus, tripServicePurchases, INVENTORY_MAX_SLOTS,
  type User, type UpsertUser,
  type Collection, type InsertCollection,
  type Merchant, type InsertMerchant,
  type Coupon, type InsertCoupon,
  type PlaceCache, type InsertPlaceCache,
  type PlaceFeedback, type InsertPlaceFeedback,
  type MerchantPlaceLink, type InsertMerchantPlaceLink,
  type Country, type Region, type District,
  type Category, type Subcategory,
  type ChatInvite,
  type PlaceProduct, type InsertPlaceProduct,
  type CartItem, type InsertCartItem,
  type CommerceOrder, type InsertCommerceOrder,
  type KlookProduct, type InsertKlookProduct,
  type MessageHighlight, type InsertMessageHighlight,
  type PlaceDraft, type InsertPlaceDraft,
  type PlaceApplication, type InsertPlaceApplication,
  type UserLocation, type InsertUserLocation,
  type Place,
  type Specialist, type InsertSpecialist,
  type Transaction, type InsertTransaction,
  type ServiceRelation, type InsertServiceRelation,
  type Announcement, type InsertAnnouncement, type AnnouncementType,
  type AdPlacementRecord, type InsertAdPlacement,
  type UserNotification, type CouponRedemption, type InsertCouponRedemption,
  type UserInventoryItem, type InsertUserInventoryItem,
  type MerchantCoupon, type InsertMerchantCoupon,
  type CouponRarityConfig, type InsertCouponRarityConfig,
  type SosAlert, type InsertSosAlert, type SosAlertStatus,
  type MerchantAnalytics, type InsertMerchantAnalytics
} from "@shared/schema";
import { db } from "./db";
import { eq, and, desc, sql, ilike, or, isNull, isNotNull, lt, gt, gte, lte, inArray } from "drizzle-orm";

export interface IStorage {
  // Users (mandatory for Replit Auth)
  getUser(id: string): Promise<User | undefined>;
  getUserByEmail(email: string): Promise<User | undefined>;
  createUser(user: UpsertUser): Promise<User>;
  upsertUser(user: UpsertUser): Promise<User>;
  updateUser(id: string, data: Partial<User>): Promise<User | undefined>;
  getPendingApprovalUsers(): Promise<User[]>;
  getAllUsers(): Promise<User[]>;
  approveUser(userId: string): Promise<User | undefined>;

  // Collections
  getUserCollections(userId: string): Promise<Collection[]>;
  addToCollection(collection: InsertCollection): Promise<Collection>;

  // Merchants
  getMerchantByUserId(userId: string): Promise<Merchant | undefined>;
  createMerchant(merchant: InsertMerchant): Promise<Merchant>;
  updateMerchantPlan(merchantId: number, plan: string): Promise<Merchant>;

  // Coupons
  getMerchantCoupons(merchantId: number): Promise<Coupon[]>;
  getActiveCoupons(merchantId: number): Promise<Coupon[]>;
  createCoupon(coupon: InsertCoupon): Promise<Coupon>;
  updateCoupon(couponId: number, data: Partial<Coupon>): Promise<Coupon>;
  getRegionPrizePoolCoupons(regionId: number): Promise<any[]>;

  // Place Cache
  getCachedPlace(subCategory: string, district: string, city: string, country: string): Promise<PlaceCache | undefined>;
  getCachedPlaces(district: string, city: string, country: string): Promise<PlaceCache[]>;
  savePlaceToCache(place: InsertPlaceCache): Promise<PlaceCache>;
  savePlacesToCache(places: InsertPlaceCache[]): Promise<PlaceCache[]>;
  getUnreviewedPlaceCache(limit: number): Promise<PlaceCache[]>;
  markPlaceCacheReviewed(id: number, reviewed: boolean): Promise<void>;
  deletePlaceCache(id: number): Promise<void>;
  getPlaceCacheReviewStats(): Promise<{ total: number; reviewed: number; unreviewed: number }>;

  // Location hierarchy
  getCountries(): Promise<Country[]>;
  getRegionById(regionId: number): Promise<Region | null>;
  getRegionsByCountry(countryId: number): Promise<Region[]>;
  getPlaceCacheByCity(city: string): Promise<PlaceCache[]>;
  getDistrictsByRegion(regionId: number): Promise<District[]>;
  getDistrictsByCountry(countryId: number): Promise<District[]>;
  getRandomDistrictByCountry(countryId: number): Promise<District | undefined>;
  getRandomDistrictByRegion(regionId: number): Promise<District | undefined>;
  getDistrictWithParents(districtId: number): Promise<{ district: District; region: Region; country: Country } | undefined>;
  getDistrictByNames(districtName: string, regionName: string, countryName: string): Promise<{ district: District; region: Region; country: Country } | undefined>;

  // Categories
  getCategories(): Promise<Category[]>;
  getSubcategoriesByCategory(categoryId: number): Promise<Subcategory[]>;
  getAllSubcategoriesWithCategory(): Promise<Array<Subcategory & { category: Category }>>;
  getRandomCategory(): Promise<Category | undefined>;
  getRandomSubcategoryByCategory(categoryId: number): Promise<Subcategory | undefined>;

  // Place Feedback (exclusion tracking)
  getPlacePenalty(userId: string, placeName: string, district: string, city: string): Promise<number>;
  incrementPlacePenalty(userId: string, placeName: string, district: string, city: string, placeCacheId?: number): Promise<PlaceFeedback>;
  getExcludedPlaceNames(userId: string, district: string, city: string, threshold?: number): Promise<string[]>;
  
  // Global Exclusions (全域排除)
  addGlobalExclusion(data: { placeName: string; district: string; city: string }): Promise<PlaceFeedback>;
  getGlobalExclusions(district?: string, city?: string): Promise<PlaceFeedback[]>;
  removeGlobalExclusion(id: number): Promise<boolean>;

  // Merchant Place Links (ownership/claim)
  getMerchantPlaceLinks(merchantId: number): Promise<MerchantPlaceLink[]>;
  getPlaceLinkByPlace(placeName: string, district: string, city: string): Promise<MerchantPlaceLink | undefined>;
  getPlaceLinkByGooglePlaceId(googlePlaceId: string): Promise<MerchantPlaceLink | undefined>;
  createMerchantPlaceLink(link: InsertMerchantPlaceLink): Promise<MerchantPlaceLink>;
  updateMerchantPlaceLink(linkId: number, data: Partial<MerchantPlaceLink>): Promise<MerchantPlaceLink>;
  searchPlacesForClaim(query: string, district?: string, city?: string): Promise<PlaceCache[]>;

  // Chat Invites
  createChatInvite(invite: { conversationSid: string; inviterUserId: string; status: string; expiresAt: Date }, inviteCode: string): Promise<ChatInvite>;
  getChatInviteByCode(inviteCode: string): Promise<ChatInvite | undefined>;
  updateChatInvite(inviteId: number, data: { status?: string; usedByUserId?: string }): Promise<ChatInvite>;

  // Commerce - Products
  getPlaceNamesWithProducts(): Promise<string[]>;
  getProductsByPlaceId(placeCacheId: number): Promise<PlaceProduct[]>;
  getProductsByPlaceName(placeName: string): Promise<PlaceProduct[]>;
  getProductById(productId: number): Promise<PlaceProduct | undefined>;
  createProduct(product: InsertPlaceProduct): Promise<PlaceProduct>;
  updateProduct(productId: number, data: Partial<PlaceProduct>): Promise<PlaceProduct>;
  deleteProduct(productId: number): Promise<void>;
  searchPlacesByName(query: string): Promise<PlaceCache[]>;
  getMerchantProducts(merchantId: number): Promise<PlaceProduct[]>;

  // Commerce - Cart
  getCartItems(userId: string): Promise<Array<CartItem & { product: PlaceProduct }>>;
  addToCart(item: InsertCartItem): Promise<CartItem>;
  updateCartItemQuantity(cartItemId: number, quantity: number): Promise<CartItem>;
  removeFromCart(cartItemId: number): Promise<void>;
  clearCart(userId: string): Promise<void>;

  // Commerce - Orders
  createOrder(order: InsertCommerceOrder): Promise<CommerceOrder>;
  getOrderById(orderId: number): Promise<CommerceOrder | undefined>;
  getOrderBySessionId(sessionId: string): Promise<CommerceOrder | undefined>;
  updateOrderStatus(orderId: number, status: string, sessionId?: string): Promise<CommerceOrder>;
  getUserOrders(userId: string): Promise<CommerceOrder[]>;

  // Klook Products
  searchKlookProducts(query: string): Promise<KlookProduct[]>;
  getKlookProductByName(normalizedName: string): Promise<KlookProduct | undefined>;
  createKlookProduct(product: InsertKlookProduct): Promise<KlookProduct>;

  // Message Highlights
  getMessageHighlights(conversationSid: string, messageSid: string): Promise<MessageHighlight[]>;
  createMessageHighlight(highlight: InsertMessageHighlight): Promise<MessageHighlight>;
  getConversationHighlights(conversationSid: string): Promise<MessageHighlight[]>;

  // Place Drafts (商家草稿地點)
  createPlaceDraft(draft: InsertPlaceDraft): Promise<PlaceDraft>;
  getPlaceDraftById(id: number): Promise<PlaceDraft | undefined>;
  getPlaceDraftsByMerchant(merchantId: number): Promise<PlaceDraft[]>;
  getAllPlaceDrafts(): Promise<PlaceDraft[]>;
  getFilteredPlaceDrafts(filters: { minRating?: number; minReviewCount?: number; status?: string }): Promise<PlaceDraft[]>;
  updatePlaceDraft(id: number, data: Partial<PlaceDraft>): Promise<PlaceDraft>;
  deletePlaceDraft(id: number): Promise<void>;
  batchDeletePlaceDrafts(ids: number[]): Promise<number>;

  // Place Applications (地點申請紀錄)
  createPlaceApplication(application: InsertPlaceApplication): Promise<PlaceApplication>;
  getPlaceApplicationById(id: number): Promise<PlaceApplication | undefined>;
  getPlaceApplicationsByMerchant(merchantId: number): Promise<PlaceApplication[]>;
  getPendingApplications(): Promise<PlaceApplication[]>;
  getPendingApplicationsWithDetails(): Promise<Array<PlaceApplication & { placeDraft?: PlaceDraft; merchant?: Merchant }>>;
  updatePlaceApplication(id: number, data: Partial<PlaceApplication>): Promise<PlaceApplication>;

  // User Locations (位置共享)
  upsertUserLocation(userId: string, lat: number, lon: number, isSharingEnabled: boolean, sosMode?: boolean): Promise<UserLocation>;
  getUserLocation(userId: string): Promise<UserLocation | undefined>;
  getSharedLocationsForPlanner(plannerId: number): Promise<Array<{ userId: string; lat: number; lon: number; updatedAt: Date; firstName: string | null; lastName: string | null; profileImageUrl: string | null; sosMode: boolean }>>;
  
  // SOS 緊急救援
  setSosMode(userId: string, enabled: boolean): Promise<UserLocation | undefined>;
  getUserBySosKey(sosKey: string): Promise<User | undefined>;
  generateSosKey(userId: string): Promise<string>;

  // Places (Gacha Pool)
  getPlacesByDistrict(city: string, district: string): Promise<Place[]>;
  getJackpotPlaces(city: string, district: string): Promise<Place[]>;
  getCouponsByPlaceId(placeId: number): Promise<Coupon[]>;

  // Gacha 2.0 - Official Pool
  getOfficialPlacesByDistrict(city: string, district: string, limit?: number): Promise<Place[]>;
  getOfficialPlacesByCity(city: string, limit?: number): Promise<Place[]>;
  getPlaceByGoogleId(googlePlaceId: string): Promise<Place | undefined>;
  getClaimByOfficialPlaceId(officialPlaceId: number): Promise<{ claim: MerchantPlaceLink; coupons: Coupon[] } | undefined>;
  saveToCollectionWithCoupon(userId: string, place: Place, wonCoupon?: Coupon): Promise<Collection>;

  // Specialists (旅遊專員)
  getSpecialistByUserId(userId: string): Promise<Specialist | undefined>;
  getSpecialistById(id: number): Promise<Specialist | undefined>;
  createSpecialist(specialist: InsertSpecialist): Promise<Specialist>;
  updateSpecialist(id: number, data: Partial<Specialist>): Promise<Specialist | undefined>;
  getActiveSpecialistsByRegion(regionCode: string): Promise<Specialist[]>;
  findAvailableSpecialist(regionCode: string): Promise<Specialist | undefined>;

  // Transactions (交易紀錄)
  createTransaction(transaction: InsertTransaction): Promise<Transaction>;
  getTransactionById(id: number): Promise<Transaction | undefined>;
  getTransactionsByMerchantId(merchantId: number): Promise<Transaction[]>;
  updateTransactionStatus(id: number, status: string): Promise<Transaction | undefined>;

  // Service Relations (服務關係)
  createServiceRelation(relation: InsertServiceRelation): Promise<ServiceRelation>;
  getServiceRelationById(id: number): Promise<ServiceRelation | undefined>;
  getActiveServiceRelationByTraveler(travelerId: string): Promise<ServiceRelation | undefined>;
  getActiveServiceRelationsBySpecialist(specialistId: number): Promise<ServiceRelation[]>;
  updateServiceRelation(id: number, data: Partial<ServiceRelation>): Promise<ServiceRelation | undefined>;
  endServiceRelation(id: number, rating?: number): Promise<ServiceRelation | undefined>;

  // Merchant Credits (商家點數)
  getMerchantById(id: number): Promise<Merchant | undefined>;
  updateMerchantDailySeedCode(merchantId: number, seedCode: string): Promise<Merchant | undefined>;
  updateMerchantCreditBalance(merchantId: number, amount: number): Promise<Merchant | undefined>;
  getMerchantDailySeedCode(merchantId: number): Promise<{ seedCode: string; updatedAt: Date } | undefined>;

  // Announcements & Events (公告與活動系統)
  createAnnouncement(announcement: InsertAnnouncement): Promise<Announcement>;
  getAnnouncementById(id: number): Promise<Announcement | undefined>;
  getAllAnnouncements(): Promise<Announcement[]>;
  getActiveAnnouncements(type?: AnnouncementType): Promise<Announcement[]>;
  updateAnnouncement(id: number, data: Partial<Announcement>): Promise<Announcement | undefined>;
  deleteAnnouncement(id: number): Promise<void>;
  deleteExpiredEvents(): Promise<number>;

  // Merchant Analytics (商家數據分析)
  recordMerchantAnalytics(data: InsertMerchantAnalytics): Promise<MerchantAnalytics>;
  getMerchantAnalytics(merchantId: number, startDate?: string, endDate?: string): Promise<MerchantAnalytics[]>;
  getMerchantAnalyticsSummary(merchantId: number): Promise<{
    totalCollectors: number;
    totalClicks: number;
    totalCouponUsage: number;
    totalCouponIssued: number;
    totalPrizePoolViews: number;
    todayCollected: number;
  }>;
  incrementAnalyticsCounter(merchantId: number, placeId: number | null, field: 'collectedCount' | 'clickCount' | 'couponUsageCount' | 'couponIssuedCount' | 'prizePoolViews'): Promise<void>;

  // Database Sync (資料庫同步)
  syncRecord(tableName: string, record: any): Promise<'inserted' | 'skipped' | 'error'>;
}

export class DatabaseStorage implements IStorage {
  // Users (mandatory for Replit Auth)
  async getUser(id: string): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(eq(users.id, id));
    return user || undefined;
  }

  async getUserByEmail(email: string): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(eq(users.email, email));
    return user || undefined;
  }

  async createUser(userData: UpsertUser): Promise<User> {
    const [user] = await db.insert(users).values(userData).returning();
    return user;
  }

  async upsertUser(userData: UpsertUser): Promise<User> {
    // 先檢查是否有相同 email 但不同 ID 的舊用戶（帳號合併邏輯）
    if (userData.email && userData.id) {
      const existingUserByEmail = await this.getUserByEmail(userData.email);
      
      if (existingUserByEmail && existingUserByEmail.id !== userData.id) {
        console.log(`[upsertUser] 發現帳號合併需求: 舊ID=${existingUserByEmail.id}, 新ID=${userData.id}`);
        
        // 使用 transaction 確保原子性：先創建新用戶，遷移資料，刪除舊用戶
        const [newUser] = await db.transaction(async (tx) => {
          // 1. 先創建新用戶（確保 FK 目標存在）
          const [createdUser] = await tx
            .insert(users)
            .values(userData)
            .onConflictDoUpdate({
              target: users.id,
              set: {
                ...userData,
                updatedAt: new Date(),
              },
            })
            .returning();
          
          console.log(`[upsertUser] 新用戶已創建/更新: ${createdUser.id}`);
          
          // 2. 遷移舊用戶的資料到新用戶
          await this.migrateUserDataInTransaction(tx, existingUserByEmail.id, userData.id!);
          
          // 3. 刪除舊用戶記錄
          await tx.delete(users).where(eq(users.id, existingUserByEmail.id));
          console.log(`[upsertUser] 已刪除舊用戶記錄: ${existingUserByEmail.id}`);
          
          return [createdUser];
        });
        
        return newUser;
      }
    }
    
    // 沒有帳號合併需求，正常 upsert
    const [user] = await db
      .insert(users)
      .values(userData)
      .onConflictDoUpdate({
        target: users.id,
        set: {
          ...userData,
          updatedAt: new Date(),
        },
      })
      .returning();
    return user;
  }
  
  // 遷移用戶資料（在 transaction 內使用）
  private async migrateUserDataInTransaction(tx: any, oldUserId: string, newUserId: string): Promise<void> {
    console.log(`[migrateUserData] 開始遷移: ${oldUserId} -> ${newUserId}`);
    
    // ===== 1. 基礎用戶資料 =====
    const updatedCollections = await tx.update(collections)
      .set({ userId: newUserId })
      .where(eq(collections.userId, oldUserId))
      .returning();
    console.log(`[migrateUserData] 遷移 collections: ${updatedCollections.length} 筆`);
    
    await tx.update(userDailyGachaStats)
      .set({ userId: newUserId })
      .where(eq(userDailyGachaStats.userId, oldUserId));
    
    await tx.update(userInventory)
      .set({ userId: newUserId })
      .where(eq(userInventory.userId, oldUserId));
    
    await tx.update(couponRedemptions)
      .set({ userId: newUserId })
      .where(eq(couponRedemptions.userId, oldUserId));
    
    await tx.update(userNotifications)
      .set({ userId: newUserId })
      .where(eq(userNotifications.userId, oldUserId));
    
    await tx.update(userLocations)
      .set({ userId: newUserId })
      .where(eq(userLocations.userId, oldUserId));
    
    await tx.update(placeFeedback)
      .set({ userId: newUserId })
      .where(eq(placeFeedback.userId, oldUserId));
    
    await tx.update(collectionReadStatus)
      .set({ userId: newUserId })
      .where(eq(collectionReadStatus.userId, oldUserId));
    
    await tx.update(userProfiles)
      .set({ userId: newUserId })
      .where(eq(userProfiles.userId, oldUserId));
    
    // ===== 2. 訂單和購買記錄 =====
    await tx.update(cartItems)
      .set({ userId: newUserId })
      .where(eq(cartItems.userId, oldUserId));
    
    await tx.update(serviceOrders)
      .set({ userId: newUserId })
      .where(eq(serviceOrders.userId, oldUserId));
    
    await tx.update(commerceOrders)
      .set({ userId: newUserId })
      .where(eq(commerceOrders.userId, oldUserId));
    
    // tripServicePurchases - 作為購買者
    await tx.update(tripServicePurchases)
      .set({ userId: newUserId })
      .where(eq(tripServicePurchases.userId, oldUserId));
    
    // tripServicePurchases - 作為受益者（可為 null）
    await tx.update(tripServicePurchases)
      .set({ purchasedForUserId: newUserId })
      .where(eq(tripServicePurchases.purchasedForUserId, oldUserId));
    
    // ===== 3. 旅程規劃 =====
    await tx.update(planners)
      .set({ userId: newUserId })
      .where(eq(planners.userId, oldUserId));
    
    await tx.update(tripPlans)
      .set({ userId: newUserId })
      .where(eq(tripPlans.userId, oldUserId));
    
    // ===== 4. 專員和服務關係 =====
    await tx.update(specialists)
      .set({ userId: newUserId })
      .where(eq(specialists.userId, oldUserId));
    
    await tx.update(serviceRelations)
      .set({ travelerId: newUserId })
      .where(eq(serviceRelations.travelerId, oldUserId));
    
    // ===== 5. SOS 和旅行同伴 =====
    await tx.update(sosAlerts)
      .set({ userId: newUserId })
      .where(eq(sosAlerts.userId, oldUserId));
    
    await tx.update(sosEvents)
      .set({ userId: newUserId })
      .where(eq(sosEvents.userId, oldUserId));
    
    await tx.update(travelCompanions)
      .set({ userId: newUserId })
      .where(eq(travelCompanions.userId, oldUserId));
    
    // ===== 6. 聊天和邀請 =====
    await tx.update(chatInvites)
      .set({ inviterUserId: newUserId })
      .where(eq(chatInvites.inviterUserId, oldUserId));
    
    await tx.update(chatInvites)
      .set({ usedByUserId: newUserId })
      .where(eq(chatInvites.usedByUserId, oldUserId));
    
    // ===== 7. 商家（如果舊帳號有商家身份，需要遷移） =====
    await tx.update(merchants)
      .set({ userId: newUserId })
      .where(eq(merchants.userId, oldUserId));
    
    console.log(`[migrateUserData] 遷移完成`);
  }

  async updateUser(id: string, data: Partial<User>): Promise<User | undefined> {
    const [user] = await db
      .update(users)
      .set({ ...data, updatedAt: new Date() })
      .where(eq(users.id, id))
      .returning();
    return user;
  }

  async getPendingApprovalUsers(): Promise<User[]> {
    return await db.select().from(users).where(eq(users.isApproved, false));
  }

  async getAllUsers(): Promise<User[]> {
    return await db.select().from(users).orderBy(desc(users.createdAt));
  }

  async approveUser(userId: string): Promise<User | undefined> {
    const [user] = await db
      .update(users)
      .set({ isApproved: true, updatedAt: new Date() })
      .where(eq(users.id, userId))
      .returning();
    return user;
  }

  // Collections
  async getUserCollections(userId: string): Promise<Collection[]> {
    return await db
      .select()
      .from(collections)
      .where(eq(collections.userId, userId))
      .orderBy(desc(collections.collectedAt));
  }

  async addToCollection(collection: InsertCollection): Promise<Collection> {
    // 標準化區域名稱（修正常見錯字）
    const normalizeDistrict = (d: string | undefined | null): string | undefined => {
      if (!d) return undefined;
      return d.replace(/郷/g, '鄉').replace(/県/g, '縣').replace(/市$/g, '市').trim();
    };
    
    const normalizedDistrict = normalizeDistrict(collection.district);
    
    // 先用標準化後的區域名稱檢查是否已存在
    const existing = await db
      .select()
      .from(collections)
      .where(
        and(
          eq(collections.userId, collection.userId),
          eq(collections.placeName, collection.placeName),
          normalizedDistrict ? eq(collections.district, normalizedDistrict) : sql`TRUE`
        )
      )
      .limit(1);
    
    if (existing.length > 0) {
      return existing[0];
    }
    
    // 也檢查是否有未標準化的舊資料
    if (collection.district && collection.district !== normalizedDistrict) {
      const existingOld = await db
        .select()
        .from(collections)
        .where(
          and(
            eq(collections.userId, collection.userId),
            eq(collections.placeName, collection.placeName),
            eq(collections.district, collection.district)
          )
        )
        .limit(1);
      
      if (existingOld.length > 0) {
        return existingOld[0];
      }
    }
    
    const [newCollection] = await db
      .insert(collections)
      .values({
        ...collection,
        district: normalizedDistrict || collection.district
      })
      .returning();
    return newCollection;
  }

  // Merchants
  async getMerchantByUserId(userId: string): Promise<Merchant | undefined> {
    const [merchant] = await db
      .select()
      .from(merchants)
      .where(eq(merchants.userId, userId));
    return merchant || undefined;
  }

  async createMerchant(merchant: InsertMerchant): Promise<Merchant> {
    const [newMerchant] = await db
      .insert(merchants)
      .values(merchant)
      .returning();
    return newMerchant;
  }

  async updateMerchantPlan(merchantId: number, plan: string): Promise<Merchant> {
    const [updated] = await db
      .update(merchants)
      .set({ subscriptionPlan: plan })
      .where(eq(merchants.id, merchantId))
      .returning();
    return updated;
  }

  async updateMerchant(merchantId: number, data: Partial<Merchant>): Promise<Merchant | undefined> {
    const [updated] = await db
      .update(merchants)
      .set({ ...data, updatedAt: new Date() })
      .where(eq(merchants.id, merchantId))
      .returning();
    return updated;
  }

  // Merchant Coupons CRUD
  async createMerchantCoupon(data: InsertMerchantCoupon): Promise<MerchantCoupon> {
    const [coupon] = await db.insert(merchantCoupons).values(data).returning();
    return coupon;
  }

  async updateMerchantCoupon(couponId: number, merchantId: number, data: Partial<MerchantCoupon>): Promise<MerchantCoupon | null> {
    const [coupon] = await db.select().from(merchantCoupons)
      .where(and(eq(merchantCoupons.id, couponId), eq(merchantCoupons.merchantId, merchantId)));
    if (!coupon) return null;
    
    const [updated] = await db.update(merchantCoupons)
      .set({ ...data, updatedAt: new Date() })
      .where(eq(merchantCoupons.id, couponId))
      .returning();
    return updated;
  }

  async deleteMerchantCoupon(couponId: number, merchantId: number): Promise<boolean> {
    const [coupon] = await db.select().from(merchantCoupons)
      .where(and(eq(merchantCoupons.id, couponId), eq(merchantCoupons.merchantId, merchantId)));
    if (!coupon) return false;
    
    await db.delete(merchantCoupons).where(eq(merchantCoupons.id, couponId));
    return true;
  }

  // Coupons
  async getMerchantCoupons(merchantId: number): Promise<Coupon[]> {
    return await db
      .select()
      .from(coupons)
      .where(eq(coupons.merchantId, merchantId))
      .orderBy(desc(coupons.createdAt));
  }

  async getActiveCoupons(merchantId: number): Promise<Coupon[]> {
    return await db
      .select()
      .from(coupons)
      .where(
        and(
          eq(coupons.merchantId, merchantId),
          eq(coupons.isActive, true),
          eq(coupons.archived, false)
        )
      );
  }

  async createCoupon(coupon: InsertCoupon): Promise<Coupon> {
    const [newCoupon] = await db
      .insert(coupons)
      .values(coupon)
      .returning();
    return newCoupon;
  }

  async updateCoupon(couponId: number, data: Partial<Coupon>): Promise<Coupon> {
    const [updated] = await db
      .update(coupons)
      .set(data)
      .where(eq(coupons.id, couponId))
      .returning();
    return updated;
  }

  async getRegionPrizePoolCoupons(regionId: number): Promise<any[]> {
    // Get all districts in this region
    const regionDistricts = await db
      .select()
      .from(districts)
      .where(eq(districts.regionId, regionId));
    
    if (regionDistricts.length === 0) {
      return [];
    }

    // Get region info for city name
    const [region] = await db
      .select()
      .from(regions)
      .where(eq(regions.id, regionId));
    
    if (!region) {
      return [];
    }

    // Get district names in both zh and en for matching
    const districtNames = regionDistricts.flatMap(d => [d.nameZh, d.nameEn].filter(Boolean));
    const cityNames = [region.nameZh, region.nameEn].filter(Boolean);

    // Find coupons with SP or SSR rarity that are active
    // We join with merchantPlaceLinks to get location data for filtering
    const prizePoolCoupons = await db
      .select({
        id: coupons.id,
        title: coupons.title,
        description: coupons.terms,
        rarity: coupons.rarity,
        merchantName: merchants.name,
        discount: coupons.code,
        merchantId: coupons.merchantId,
        placeDistrict: merchantPlaceLinks.district,
        placeCity: merchantPlaceLinks.city,
      })
      .from(coupons)
      .innerJoin(merchants, eq(coupons.merchantId, merchants.id))
      .leftJoin(merchantPlaceLinks, eq(coupons.merchantPlaceLinkId, merchantPlaceLinks.id))
      .where(
        and(
          eq(coupons.isActive, true),
          eq(coupons.archived, false),
          or(
            eq(coupons.rarity, 'SP'),
            eq(coupons.rarity, 'SSR')
          )
        )
      );

    // Filter by region - match district name or city name
    const filteredCoupons = prizePoolCoupons.filter(coupon => {
      // If coupon has no place link, check if merchant is in this region (include as general prize for now)
      if (!coupon.placeDistrict && !coupon.placeCity) {
        return true; // Include global coupons
      }
      
      // Check if district matches any district in the region
      if (coupon.placeDistrict && districtNames.some(d => 
        d.toLowerCase() === coupon.placeDistrict?.toLowerCase()
      )) {
        return true;
      }
      
      // Check if city matches the region name
      if (coupon.placeCity && cityNames.some(c => 
        c.toLowerCase() === coupon.placeCity?.toLowerCase()
      )) {
        return true;
      }
      
      return false;
    });

    // Remove internal fields before returning
    return filteredCoupons.map(({ placeDistrict, placeCity, ...coupon }) => coupon);
  }

  // Place Cache
  async getCachedPlace(subCategory: string, district: string, city: string, country: string): Promise<PlaceCache | undefined> {
    const [place] = await db
      .select()
      .from(placeCache)
      .where(
        and(
          eq(placeCache.subCategory, subCategory),
          eq(placeCache.district, district),
          eq(placeCache.city, city),
          eq(placeCache.country, country)
        )
      )
      .limit(1);
    return place || undefined;
  }

  async getCachedPlaces(district: string, city: string, country: string): Promise<PlaceCache[]> {
    return await db
      .select()
      .from(placeCache)
      .where(
        and(
          eq(placeCache.district, district),
          eq(placeCache.city, city),
          eq(placeCache.country, country)
        )
      );
  }

  async savePlaceToCache(place: InsertPlaceCache): Promise<PlaceCache> {
    const [newPlace] = await db
      .insert(placeCache)
      .values(place)
      .returning();
    return newPlace;
  }

  async savePlacesToCache(places: InsertPlaceCache[]): Promise<PlaceCache[]> {
    if (places.length === 0) return [];
    return await db
      .insert(placeCache)
      .values(places)
      .returning();
  }

  async getUnreviewedPlaceCache(limit: number): Promise<PlaceCache[]> {
    return await db
      .select()
      .from(placeCache)
      .where(or(eq(placeCache.aiReviewed, false), isNull(placeCache.aiReviewed)))
      .limit(limit);
  }

  async markPlaceCacheReviewed(id: number, reviewed: boolean): Promise<void> {
    await db
      .update(placeCache)
      .set({ 
        aiReviewed: reviewed, 
        aiReviewedAt: new Date() 
      })
      .where(eq(placeCache.id, id));
  }

  async deletePlaceCache(id: number): Promise<void> {
    await db.delete(placeCache).where(eq(placeCache.id, id));
  }

  async getPlaceCacheReviewStats(): Promise<{ total: number; reviewed: number; unreviewed: number }> {
    const [stats] = await db
      .select({
        total: sql<number>`count(*)::int`,
        reviewed: sql<number>`count(*) filter (where ${placeCache.aiReviewed} = true)::int`,
        unreviewed: sql<number>`count(*) filter (where ${placeCache.aiReviewed} = false or ${placeCache.aiReviewed} is null)::int`
      })
      .from(placeCache);
    return {
      total: stats?.total ?? 0,
      reviewed: stats?.reviewed ?? 0,
      unreviewed: stats?.unreviewed ?? 0
    };
  }

  // Location hierarchy
  async getCountries(): Promise<Country[]> {
    return await db
      .select()
      .from(countries)
      .where(eq(countries.isActive, true));
  }

  async getRegionById(regionId: number): Promise<Region | null> {
    const [region] = await db
      .select()
      .from(regions)
      .where(eq(regions.id, regionId));
    return region || null;
  }

  async getRegionsByCountry(countryId: number): Promise<Region[]> {
    return await db
      .select()
      .from(regions)
      .where(and(eq(regions.countryId, countryId), eq(regions.isActive, true)));
  }

  async getPlaceCacheByCity(city: string): Promise<PlaceCache[]> {
    return await db
      .select()
      .from(placeCache)
      .where(eq(placeCache.city, city));
  }

  async getDistrictsByRegion(regionId: number): Promise<District[]> {
    return await db
      .select()
      .from(districts)
      .where(and(eq(districts.regionId, regionId), eq(districts.isActive, true)));
  }

  async getDistrictsByCountry(countryId: number): Promise<District[]> {
    const result = await db
      .select({ district: districts })
      .from(districts)
      .innerJoin(regions, eq(districts.regionId, regions.id))
      .where(and(eq(regions.countryId, countryId), eq(districts.isActive, true)));
    return result.map(r => r.district);
  }

  async getRandomDistrictByCountry(countryId: number): Promise<District | undefined> {
    const result = await db
      .select({ district: districts })
      .from(districts)
      .innerJoin(regions, eq(districts.regionId, regions.id))
      .where(and(eq(regions.countryId, countryId), eq(districts.isActive, true)))
      .orderBy(sql`RANDOM()`)
      .limit(1);
    return result[0]?.district;
  }

  async getRandomDistrictByRegion(regionId: number): Promise<District | undefined> {
    const [district] = await db
      .select()
      .from(districts)
      .where(and(eq(districts.regionId, regionId), eq(districts.isActive, true)))
      .orderBy(sql`RANDOM()`)
      .limit(1);
    return district;
  }

  async getDistrictWithParents(districtId: number): Promise<{ district: District; region: Region; country: Country } | undefined> {
    const result = await db
      .select({
        district: districts,
        region: regions,
        country: countries
      })
      .from(districts)
      .innerJoin(regions, eq(districts.regionId, regions.id))
      .innerJoin(countries, eq(regions.countryId, countries.id))
      .where(eq(districts.id, districtId))
      .limit(1);
    return result[0];
  }

  async getDistrictByNames(districtName: string, regionName: string, countryName: string): Promise<{ district: District; region: Region; country: Country } | undefined> {
    const result = await db
      .select({
        district: districts,
        region: regions,
        country: countries
      })
      .from(districts)
      .innerJoin(regions, eq(districts.regionId, regions.id))
      .innerJoin(countries, eq(regions.countryId, countries.id))
      .where(and(
        eq(districts.nameZh, districtName),
        eq(regions.nameZh, regionName),
        eq(countries.nameZh, countryName)
      ))
      .limit(1);
    return result[0];
  }

  // Categories
  async getCategories(): Promise<Category[]> {
    return await db
      .select()
      .from(categories)
      .where(eq(categories.isActive, true))
      .orderBy(categories.sortOrder);
  }

  async getSubcategoriesByCategory(categoryId: number): Promise<Subcategory[]> {
    return await db
      .select()
      .from(subcategories)
      .where(and(eq(subcategories.categoryId, categoryId), eq(subcategories.isActive, true)));
  }

  async getRandomCategory(): Promise<Category | undefined> {
    const [category] = await db
      .select()
      .from(categories)
      .where(eq(categories.isActive, true))
      .orderBy(sql`RANDOM()`)
      .limit(1);
    return category;
  }

  async getRandomSubcategoryByCategory(categoryId: number): Promise<Subcategory | undefined> {
    const [subcategory] = await db
      .select()
      .from(subcategories)
      .where(and(eq(subcategories.categoryId, categoryId), eq(subcategories.isActive, true)))
      .orderBy(sql`RANDOM()`)
      .limit(1);
    return subcategory;
  }

  async getAllSubcategoriesWithCategory(): Promise<Array<Subcategory & { category: Category }>> {
    const results = await db
      .select({
        subcategory: subcategories,
        category: categories
      })
      .from(subcategories)
      .innerJoin(categories, eq(subcategories.categoryId, categories.id))
      .where(and(eq(subcategories.isActive, true), eq(categories.isActive, true)));
    
    return results.map(r => ({
      ...r.subcategory,
      category: r.category
    }));
  }

  // Place Feedback methods
  async getPlacePenalty(userId: string, placeName: string, district: string, city: string): Promise<number> {
    const [feedback] = await db
      .select()
      .from(placeFeedback)
      .where(and(
        eq(placeFeedback.userId, userId),
        eq(placeFeedback.placeName, placeName),
        eq(placeFeedback.district, district),
        eq(placeFeedback.city, city)
      ));
    return feedback?.penaltyScore || 0;
  }

  async incrementPlacePenalty(userId: string, placeName: string, district: string, city: string, placeCacheId?: number): Promise<PlaceFeedback> {
    const existing = await db
      .select()
      .from(placeFeedback)
      .where(and(
        eq(placeFeedback.userId, userId),
        eq(placeFeedback.placeName, placeName),
        eq(placeFeedback.district, district),
        eq(placeFeedback.city, city)
      ));

    if (existing.length > 0) {
      const [updated] = await db
        .update(placeFeedback)
        .set({
          penaltyScore: existing[0].penaltyScore + 1,
          lastInteractedAt: new Date()
        })
        .where(eq(placeFeedback.id, existing[0].id))
        .returning();
      return updated;
    } else {
      const [created] = await db
        .insert(placeFeedback)
        .values({
          userId,
          placeName,
          district,
          city,
          placeCacheId: placeCacheId || null,
          penaltyScore: 1,
          lastInteractedAt: new Date()
        })
        .returning();
      return created;
    }
  }

  async getExcludedPlaceNames(userId: string, district: string, city: string, threshold: number = 3): Promise<string[]> {
    // 查詢個人排除（penaltyScore >= threshold）和全域排除（userId = null）
    const results = await db
      .select({ placeName: placeFeedback.placeName })
      .from(placeFeedback)
      .where(and(
        eq(placeFeedback.district, district),
        eq(placeFeedback.city, city),
        or(
          // 全域排除：userId 為 null 的地點永遠排除
          isNull(placeFeedback.userId),
          // 個人排除：該用戶的 penaltyScore 達到門檻
          and(
            eq(placeFeedback.userId, userId),
            sql`${placeFeedback.penaltyScore} >= ${threshold}`
          )
        )
      ));
    return results.map(r => r.placeName);
  }

  async createPlaceFeedback(data: { userId: string; placeName: string; district: string; city: string; penaltyScore: number }): Promise<PlaceFeedback> {
    const [created] = await db
      .insert(placeFeedback)
      .values({
        userId: data.userId,
        placeName: data.placeName,
        district: data.district,
        city: data.city,
        penaltyScore: data.penaltyScore,
        lastInteractedAt: new Date()
      })
      .returning();
    return created;
  }

  // 創建全域排除地點（userId = null，任何使用者都不會抽到）
  async addGlobalExclusion(data: { placeName: string; district: string; city: string }): Promise<PlaceFeedback> {
    // 先檢查是否已存在
    const existing = await db
      .select()
      .from(placeFeedback)
      .where(and(
        isNull(placeFeedback.userId),
        eq(placeFeedback.placeName, data.placeName),
        eq(placeFeedback.district, data.district),
        eq(placeFeedback.city, data.city)
      ));

    if (existing.length > 0) {
      return existing[0];
    }

    const [created] = await db
      .insert(placeFeedback)
      .values({
        userId: null,
        placeName: data.placeName,
        district: data.district,
        city: data.city,
        penaltyScore: 999, // 高分代表永久排除
        lastInteractedAt: new Date()
      })
      .returning();
    return created;
  }

  // 取得全域排除清單
  async getGlobalExclusions(district?: string, city?: string): Promise<PlaceFeedback[]> {
    if (district && city) {
      return db
        .select()
        .from(placeFeedback)
        .where(and(
          isNull(placeFeedback.userId),
          eq(placeFeedback.district, district),
          eq(placeFeedback.city, city)
        ))
        .orderBy(desc(placeFeedback.createdAt));
    }
    return db
      .select()
      .from(placeFeedback)
      .where(isNull(placeFeedback.userId))
      .orderBy(desc(placeFeedback.createdAt));
  }

  // 移除全域排除地點
  async removeGlobalExclusion(id: number): Promise<boolean> {
    const result = await db
      .delete(placeFeedback)
      .where(and(
        eq(placeFeedback.id, id),
        isNull(placeFeedback.userId)
      ))
      .returning();
    return result.length > 0;
  }

  // Merchant Place Links methods
  async getMerchantPlaceLinks(merchantId: number): Promise<MerchantPlaceLink[]> {
    return db
      .select()
      .from(merchantPlaceLinks)
      .where(eq(merchantPlaceLinks.merchantId, merchantId))
      .orderBy(desc(merchantPlaceLinks.createdAt));
  }

  async getPlaceLinkByPlace(placeName: string, district: string, city: string): Promise<MerchantPlaceLink | undefined> {
    const [link] = await db
      .select()
      .from(merchantPlaceLinks)
      .where(and(
        eq(merchantPlaceLinks.placeName, placeName),
        eq(merchantPlaceLinks.district, district),
        eq(merchantPlaceLinks.city, city),
        eq(merchantPlaceLinks.status, 'approved')
      ));
    return link;
  }

  async getPlaceLinkByGooglePlaceId(googlePlaceId: string): Promise<MerchantPlaceLink | undefined> {
    const [link] = await db
      .select()
      .from(merchantPlaceLinks)
      .where(and(
        eq(merchantPlaceLinks.googlePlaceId, googlePlaceId),
        eq(merchantPlaceLinks.status, 'approved')
      ));
    return link;
  }

  async createMerchantPlaceLink(link: InsertMerchantPlaceLink): Promise<MerchantPlaceLink> {
    const [created] = await db
      .insert(merchantPlaceLinks)
      .values(link)
      .returning();
    return created;
  }

  async updateMerchantPlaceLink(linkId: number, data: Partial<MerchantPlaceLink>): Promise<MerchantPlaceLink> {
    const [updated] = await db
      .update(merchantPlaceLinks)
      .set({ ...data, updatedAt: new Date() })
      .where(eq(merchantPlaceLinks.id, linkId))
      .returning();
    return updated;
  }

  async searchPlacesForClaim(query: string, district?: string, city?: string): Promise<PlaceCache[]> {
    const conditions = [ilike(placeCache.placeName, `%${query}%`)];
    
    if (district) {
      conditions.push(eq(placeCache.district, district));
    }
    if (city) {
      conditions.push(eq(placeCache.city, city));
    }

    return db
      .select()
      .from(placeCache)
      .where(and(...conditions))
      .limit(20);
  }

  // Chat Invites
  async createChatInvite(invite: { conversationSid: string; inviterUserId: string; status: string; expiresAt: Date }, inviteCode: string): Promise<ChatInvite> {
    const [created] = await db
      .insert(chatInvites)
      .values({
        ...invite,
        inviteCode,
      })
      .returning();
    return created;
  }

  async getChatInviteByCode(inviteCode: string): Promise<ChatInvite | undefined> {
    const [invite] = await db
      .select()
      .from(chatInvites)
      .where(eq(chatInvites.inviteCode, inviteCode));
    return invite;
  }

  async updateChatInvite(inviteId: number, data: { status?: string; usedByUserId?: string }): Promise<ChatInvite> {
    const [updated] = await db
      .update(chatInvites)
      .set(data)
      .where(eq(chatInvites.id, inviteId))
      .returning();
    return updated;
  }

  // Commerce - Products
  async getPlaceNamesWithProducts(): Promise<string[]> {
    const products = await db.select({ placeCacheId: placeProducts.placeCacheId })
      .from(placeProducts)
      .where(eq(placeProducts.isActive, true))
      .groupBy(placeProducts.placeCacheId);
    
    if (products.length === 0) return [];
    
    const placeIds = products.map(p => p.placeCacheId).filter((id): id is number => id !== null);
    if (placeIds.length === 0) return [];
    
    const places = await db.select({ placeName: placeCache.placeName })
      .from(placeCache)
      .where(sql`${placeCache.id} = ANY(${placeIds})`);
    
    return places.map(p => p.placeName);
  }

  async getProductsByPlaceId(placeCacheId: number): Promise<PlaceProduct[]> {
    return db.select().from(placeProducts).where(
      and(eq(placeProducts.placeCacheId, placeCacheId), eq(placeProducts.isActive, true))
    );
  }

  async getProductsByPlaceName(placeName: string): Promise<PlaceProduct[]> {
    const places = await db.select().from(placeCache).where(ilike(placeCache.placeName, `%${placeName}%`)).limit(5);
    if (places.length === 0) return [];
    const placeIds = places.map(p => p.id);
    return db.select().from(placeProducts).where(
      and(sql`${placeProducts.placeCacheId} = ANY(${placeIds})`, eq(placeProducts.isActive, true))
    );
  }

  async getProductById(productId: number): Promise<PlaceProduct | undefined> {
    const [product] = await db.select().from(placeProducts).where(eq(placeProducts.id, productId));
    return product;
  }

  async createProduct(product: InsertPlaceProduct): Promise<PlaceProduct> {
    const [created] = await db.insert(placeProducts).values(product).returning();
    return created;
  }

  async updateProduct(productId: number, data: Partial<PlaceProduct>): Promise<PlaceProduct> {
    const [updated] = await db.update(placeProducts).set({ ...data, updatedAt: new Date() }).where(eq(placeProducts.id, productId)).returning();
    return updated;
  }

  async deleteProduct(productId: number): Promise<void> {
    await db.delete(placeProducts).where(eq(placeProducts.id, productId));
  }

  async searchPlacesByName(query: string): Promise<PlaceCache[]> {
    return db.select().from(placeCache).where(ilike(placeCache.placeName, `%${query}%`)).limit(10);
  }

  async getMerchantProducts(merchantId: number): Promise<PlaceProduct[]> {
    return db.select().from(placeProducts).where(eq(placeProducts.merchantId, merchantId)).orderBy(desc(placeProducts.createdAt));
  }

  // Commerce - Cart
  async getCartItems(userId: string): Promise<Array<CartItem & { product: PlaceProduct }>> {
    const items = await db.select().from(cartItems).where(eq(cartItems.userId, userId));
    const result: Array<CartItem & { product: PlaceProduct }> = [];
    for (const item of items) {
      const [product] = await db.select().from(placeProducts).where(eq(placeProducts.id, item.productId));
      if (product) {
        result.push({ ...item, product });
      }
    }
    return result;
  }

  async addToCart(item: InsertCartItem): Promise<CartItem> {
    const existing = await db.select().from(cartItems).where(
      and(eq(cartItems.userId, item.userId), eq(cartItems.productId, item.productId))
    );
    if (existing.length > 0) {
      const [updated] = await db.update(cartItems)
        .set({ quantity: existing[0].quantity + (item.quantity || 1) })
        .where(eq(cartItems.id, existing[0].id))
        .returning();
      return updated;
    }
    const [created] = await db.insert(cartItems).values(item).returning();
    return created;
  }

  async updateCartItemQuantity(cartItemId: number, quantity: number): Promise<CartItem> {
    const [updated] = await db.update(cartItems).set({ quantity }).where(eq(cartItems.id, cartItemId)).returning();
    return updated;
  }

  async removeFromCart(cartItemId: number): Promise<void> {
    await db.delete(cartItems).where(eq(cartItems.id, cartItemId));
  }

  async clearCart(userId: string): Promise<void> {
    await db.delete(cartItems).where(eq(cartItems.userId, userId));
  }

  // Commerce - Orders
  async createOrder(order: InsertCommerceOrder): Promise<CommerceOrder> {
    const [created] = await db.insert(commerceOrders).values(order).returning();
    return created;
  }

  async getOrderById(orderId: number): Promise<CommerceOrder | undefined> {
    const [order] = await db.select().from(commerceOrders).where(eq(commerceOrders.id, orderId));
    return order;
  }

  async getOrderBySessionId(sessionId: string): Promise<CommerceOrder | undefined> {
    const [order] = await db.select().from(commerceOrders).where(eq(commerceOrders.stripeSessionId, sessionId));
    return order;
  }

  async updateOrderStatus(orderId: number, status: string, sessionId?: string): Promise<CommerceOrder> {
    const updateData: Partial<CommerceOrder> = { status, updatedAt: new Date() };
    if (sessionId) updateData.stripeSessionId = sessionId;
    const [updated] = await db.update(commerceOrders).set(updateData).where(eq(commerceOrders.id, orderId)).returning();
    return updated;
  }

  async getUserOrders(userId: string): Promise<CommerceOrder[]> {
    return db.select().from(commerceOrders).where(eq(commerceOrders.userId, userId)).orderBy(desc(commerceOrders.createdAt));
  }

  // Klook Products
  async searchKlookProducts(query: string): Promise<KlookProduct[]> {
    const normalized = query.toLowerCase().replace(/\s+/g, '');
    return db.select().from(klookProducts)
      .where(and(
        ilike(klookProducts.nameNormalized, `%${normalized}%`),
        eq(klookProducts.isActive, true)
      ))
      .limit(10);
  }

  async getKlookProductByName(normalizedName: string): Promise<KlookProduct | undefined> {
    const [product] = await db.select().from(klookProducts)
      .where(eq(klookProducts.nameNormalized, normalizedName));
    return product;
  }

  async createKlookProduct(product: InsertKlookProduct): Promise<KlookProduct> {
    const [created] = await db.insert(klookProducts).values(product).returning();
    return created;
  }

  // Message Highlights
  async getMessageHighlights(conversationSid: string, messageSid: string): Promise<MessageHighlight[]> {
    return db.select().from(messageHighlights)
      .where(and(
        eq(messageHighlights.conversationSid, conversationSid),
        eq(messageHighlights.messageSid, messageSid)
      ));
  }

  async createMessageHighlight(highlight: InsertMessageHighlight): Promise<MessageHighlight> {
    const [created] = await db.insert(messageHighlights).values(highlight).returning();
    return created;
  }

  async getConversationHighlights(conversationSid: string): Promise<MessageHighlight[]> {
    return db.select().from(messageHighlights)
      .where(eq(messageHighlights.conversationSid, conversationSid));
  }

  // Place Drafts (商家草稿地點)
  async createPlaceDraft(draft: InsertPlaceDraft): Promise<PlaceDraft> {
    const [created] = await db.insert(placeDrafts).values(draft).returning();
    return created;
  }

  async getPlaceDraftById(id: number): Promise<PlaceDraft | undefined> {
    const [draft] = await db.select().from(placeDrafts).where(eq(placeDrafts.id, id));
    return draft;
  }

  async getPlaceDraftsByMerchant(merchantId: number): Promise<PlaceDraft[]> {
    return db.select().from(placeDrafts)
      .where(eq(placeDrafts.merchantId, merchantId))
      .orderBy(desc(placeDrafts.createdAt));
  }

  async getAllPlaceDrafts(): Promise<PlaceDraft[]> {
    return db.select().from(placeDrafts)
      .orderBy(desc(placeDrafts.createdAt));
  }

  async getFilteredPlaceDrafts(filters: { minRating?: number; minReviewCount?: number; status?: string }): Promise<PlaceDraft[]> {
    const conditions = [];
    
    if (filters.status) {
      conditions.push(eq(placeDrafts.status, filters.status));
    }
    if (filters.minRating !== undefined) {
      // 只選擇有 Google 評分且 >= 門檻的草稿（排除 NULL）
      conditions.push(
        and(
          isNotNull(placeDrafts.googleRating),
          gte(placeDrafts.googleRating, filters.minRating)
        )
      );
    }
    if (filters.minReviewCount !== undefined) {
      // 只選擇有 Google 評論數且 >= 門檻的草稿（排除 NULL）
      conditions.push(
        and(
          isNotNull(placeDrafts.googleReviewCount),
          gte(placeDrafts.googleReviewCount, filters.minReviewCount)
        )
      );
    }
    
    if (conditions.length === 0) {
      return db.select().from(placeDrafts).orderBy(desc(placeDrafts.googleRating));
    }
    
    return db.select().from(placeDrafts)
      .where(and(...conditions))
      .orderBy(desc(placeDrafts.googleRating));
  }

  async updatePlaceDraft(id: number, data: Partial<PlaceDraft>): Promise<PlaceDraft> {
    const [updated] = await db.update(placeDrafts)
      .set({ ...data, updatedAt: new Date() })
      .where(eq(placeDrafts.id, id))
      .returning();
    return updated;
  }

  async deletePlaceDraft(id: number): Promise<void> {
    await db.delete(placeDrafts).where(eq(placeDrafts.id, id));
  }

  async batchDeletePlaceDrafts(ids: number[]): Promise<number> {
    if (ids.length === 0) return 0;
    const result = await db.delete(placeDrafts).where(inArray(placeDrafts.id, ids));
    return ids.length;
  }

  // Place Applications (地點申請紀錄)
  async createPlaceApplication(application: InsertPlaceApplication): Promise<PlaceApplication> {
    const [created] = await db.insert(placeApplications).values(application).returning();
    return created;
  }

  async getPlaceApplicationById(id: number): Promise<PlaceApplication | undefined> {
    const [application] = await db.select().from(placeApplications).where(eq(placeApplications.id, id));
    return application;
  }

  async getPlaceApplicationsByMerchant(merchantId: number): Promise<PlaceApplication[]> {
    return db.select().from(placeApplications)
      .where(eq(placeApplications.merchantId, merchantId))
      .orderBy(desc(placeApplications.createdAt));
  }

  async getPendingApplications(): Promise<PlaceApplication[]> {
    return db.select().from(placeApplications)
      .where(eq(placeApplications.status, 'pending'))
      .orderBy(placeApplications.createdAt);
  }

  async getPendingApplicationsWithDetails(): Promise<Array<PlaceApplication & { placeDraft?: PlaceDraft; merchant?: Merchant }>> {
    const applications = await db.select().from(placeApplications)
      .where(eq(placeApplications.status, 'pending'))
      .orderBy(placeApplications.createdAt);
    
    const results = await Promise.all(applications.map(async (app) => {
      const [draft] = await db.select().from(placeDrafts).where(eq(placeDrafts.id, app.placeDraftId));
      const [merchant] = await db.select().from(merchants).where(eq(merchants.id, app.merchantId));
      return { ...app, placeDraft: draft, merchant };
    }));
    
    return results;
  }

  async updatePlaceApplication(id: number, data: Partial<PlaceApplication>): Promise<PlaceApplication> {
    const [updated] = await db.update(placeApplications)
      .set(data)
      .where(eq(placeApplications.id, id))
      .returning();
    return updated;
  }

  // User Locations (位置共享)
  async upsertUserLocation(userId: string, lat: number, lon: number, isSharingEnabled: boolean, sosMode?: boolean): Promise<UserLocation> {
    const setData: Record<string, any> = { 
      lat, 
      lon, 
      isSharingEnabled, 
      updatedAt: new Date() 
    };
    
    if (sosMode !== undefined) {
      setData.sosMode = sosMode;
    }
    
    const [location] = await db
      .insert(userLocations)
      .values({ userId, lat, lon, isSharingEnabled, sosMode: sosMode ?? false })
      .onConflictDoUpdate({
        target: userLocations.userId,
        set: setData,
      })
      .returning();
    return location;
  }

  async getUserLocation(userId: string): Promise<UserLocation | undefined> {
    const [location] = await db.select().from(userLocations).where(eq(userLocations.userId, userId));
    return location;
  }

  async getSharedLocationsForPlanner(plannerId: number): Promise<Array<{ userId: string; lat: number; lon: number; updatedAt: Date; firstName: string | null; lastName: string | null; profileImageUrl: string | null; sosMode: boolean }>> {
    const results = await db
      .select({
        userId: userLocations.userId,
        lat: userLocations.lat,
        lon: userLocations.lon,
        updatedAt: userLocations.updatedAt,
        firstName: users.firstName,
        lastName: users.lastName,
        profileImageUrl: users.profileImageUrl,
        sosMode: userLocations.sosMode,
      })
      .from(userLocations)
      .innerJoin(users, eq(userLocations.userId, users.id))
      .innerJoin(serviceOrders, eq(serviceOrders.userId, userLocations.userId))
      .where(
        and(
          eq(serviceOrders.plannerId, plannerId),
          sql`(${userLocations.isSharingEnabled} = true OR ${userLocations.sosMode} = true)`
        )
      );
    return results;
  }

  // SOS 緊急救援
  async setSosMode(userId: string, enabled: boolean): Promise<UserLocation | undefined> {
    const [location] = await db
      .update(userLocations)
      .set({ sosMode: enabled, updatedAt: new Date() })
      .where(eq(userLocations.userId, userId))
      .returning();
    return location;
  }

  async getUserBySosKey(sosKey: string): Promise<User | undefined> {
    const [user] = await db
      .select()
      .from(users)
      .where(eq(users.sosSecretKey, sosKey));
    return user;
  }

  async generateSosKey(userId: string): Promise<string> {
    const key = crypto.randomUUID().replace(/-/g, '') + crypto.randomUUID().replace(/-/g, '').slice(0, 32);
    await db
      .update(users)
      .set({ sosSecretKey: key, updatedAt: new Date() })
      .where(eq(users.id, userId));
    return key;
  }

  // Places (Gacha Pool)
  async getPlacesByDistrict(city: string, district: string): Promise<Place[]> {
    return await db
      .select()
      .from(places)
      .where(and(eq(places.city, city), eq(places.district, district)));
  }

  async getJackpotPlaces(city: string, district: string): Promise<Place[]> {
    return await db
      .select()
      .from(places)
      .where(
        sql`${places.city} = ${city} AND ${places.district} = ${district} AND (${places.rating} >= 4.5 OR ${places.merchantId} IS NOT NULL)`
      );
  }

  async getCouponsByPlaceId(placeId: number): Promise<Coupon[]> {
    return await db
      .select()
      .from(coupons)
      .where(eq(coupons.placeId, placeId));
  }

  // Gacha 2.0 - Official Pool
  async getOfficialPlacesByDistrict(city: string, district: string, limit?: number): Promise<Place[]> {
    const query = db
      .select()
      .from(places)
      .where(and(eq(places.city, city), eq(places.district, district)))
      .orderBy(sql`RANDOM()`);
    
    if (limit) {
      return await query.limit(limit);
    }
    return await query;
  }

  async getOfficialPlacesByCity(city: string, limit?: number): Promise<Place[]> {
    const query = db
      .select()
      .from(places)
      .where(eq(places.city, city))
      .orderBy(sql`RANDOM()`);
    
    if (limit) {
      return await query.limit(limit);
    }
    return await query;
  }

  async getPlaceByGoogleId(googlePlaceId: string): Promise<Place | undefined> {
    const [place] = await db
      .select()
      .from(places)
      .where(eq(places.googlePlaceId, googlePlaceId))
      .limit(1);
    return place;
  }

  async getClaimByOfficialPlaceId(officialPlaceId: number): Promise<{ claim: MerchantPlaceLink; coupons: Coupon[] } | undefined> {
    const [claim] = await db
      .select()
      .from(merchantPlaceLinks)
      .where(
        and(
          eq(merchantPlaceLinks.officialPlaceId, officialPlaceId),
          eq(merchantPlaceLinks.status, 'approved')
        )
      );
    
    if (!claim) {
      return undefined;
    }

    const placeCoupons = await db
      .select()
      .from(coupons)
      .where(
        and(
          eq(coupons.placeId, officialPlaceId),
          eq(coupons.isActive, true),
          eq(coupons.archived, false),
          sql`${coupons.remainingQuantity} > 0`
        )
      );

    return { claim, coupons: placeCoupons };
  }

  async saveToCollectionWithCoupon(userId: string, place: Place, wonCoupon?: Coupon): Promise<Collection> {
    const collectionData: InsertCollection = {
      userId,
      officialPlaceId: place.id,
      placeName: place.placeName,
      country: place.country,
      city: place.city,
      district: place.district,
      category: place.category,
      subcategory: place.subcategory || undefined,
      description: place.description || undefined,
      address: place.address || undefined,
      placeId: place.googlePlaceId || undefined,
      rating: place.rating?.toString(),
      locationLat: place.locationLat?.toString(),
      locationLng: place.locationLng?.toString(),
      isCoupon: !!wonCoupon,
      couponData: wonCoupon ? { 
        title: wonCoupon.title, 
        code: wonCoupon.code, 
        terms: wonCoupon.terms 
      } : undefined,
      wonCouponId: wonCoupon?.id,
    };

    const [newCollection] = await db
      .insert(collections)
      .values(collectionData)
      .returning();
    
    if (wonCoupon) {
      await db
        .update(coupons)
        .set({ 
          remainingQuantity: sql`${coupons.remainingQuantity} - 1`,
          impressionCount: sql`${coupons.impressionCount} + 1`
        })
        .where(eq(coupons.id, wonCoupon.id));
    }

    return newCollection;
  }

  // AI 生成地點存入草稿（根據文字名稱查詢 ID）
  async saveAIPlacesToDrafts(places: Array<{
    placeName: string;
    description: string;
    category: string;
    subCategory: string;
    district: string;
    city: string;
    country: string;
    googlePlaceId?: string | null;
    googleRating?: number | null;
    locationLat?: string | null;
    locationLng?: string | null;
    address?: string | null;
  }>): Promise<PlaceDraft[]> {
    if (places.length === 0) return [];

    const results: PlaceDraft[] = [];

    for (const place of places) {
      try {
        // 1. 查詢 country ID（用 nameZh 或 nameEn）
        const [countryRow] = await db
          .select()
          .from(countries)
          .where(
            sql`${countries.nameZh} = ${place.country} OR ${countries.nameEn} = ${place.country}`
          )
          .limit(1);
        if (!countryRow) {
          console.log(`[AI Draft] Country not found: ${place.country}`);
          continue;
        }

        // 2. 查詢 region ID（用 nameZh 或 nameEn，city 對應 region）
        const [regionRow] = await db
          .select()
          .from(regions)
          .where(
            and(
              eq(regions.countryId, countryRow.id),
              sql`${regions.nameZh} = ${place.city} OR ${regions.nameEn} = ${place.city}`
            )
          )
          .limit(1);
        if (!regionRow) {
          console.log(`[AI Draft] Region/City not found: ${place.city}`);
          continue;
        }

        // 3. 查詢 district ID
        const [districtRow] = await db
          .select()
          .from(districts)
          .where(
            and(
              eq(districts.regionId, regionRow.id),
              sql`${districts.nameZh} = ${place.district} OR ${districts.nameEn} = ${place.district}`
            )
          )
          .limit(1);
        if (!districtRow) {
          console.log(`[AI Draft] District not found: ${place.district}`);
          continue;
        }

        // 4. 查詢 category ID（用 nameZh 或 nameEn）
        const [categoryRow] = await db
          .select()
          .from(categories)
          .where(
            sql`${categories.nameZh} = ${place.category} OR ${categories.nameEn} = ${place.category}`
          )
          .limit(1);
        if (!categoryRow) {
          console.log(`[AI Draft] Category not found: ${place.category}`);
          continue;
        }

        // 5. 查詢 subcategory ID
        const [subcategoryRow] = await db
          .select()
          .from(subcategories)
          .where(
            and(
              eq(subcategories.categoryId, categoryRow.id),
              sql`${subcategories.nameZh} = ${place.subCategory} OR ${subcategories.nameEn} = ${place.subCategory}`
            )
          )
          .limit(1);
        if (!subcategoryRow) {
          console.log(`[AI Draft] Subcategory not found: ${place.subCategory}`);
          continue;
        }

        // 6. 檢查是否已存在相同的草稿（避免重複）
        const [existingDraft] = await db
          .select()
          .from(placeDrafts)
          .where(
            and(
              eq(placeDrafts.placeName, place.placeName),
              eq(placeDrafts.districtId, districtRow.id)
            )
          )
          .limit(1);
        
        if (existingDraft) {
          console.log(`[AI Draft] Already exists: ${place.placeName}`);
          continue;
        }

        // 7. 存入 place_drafts
        const [draft] = await db
          .insert(placeDrafts)
          .values({
            merchantId: null, // AI 生成的沒有商家
            source: 'ai',
            placeName: place.placeName,
            categoryId: categoryRow.id,
            subcategoryId: subcategoryRow.id,
            description: place.description,
            districtId: districtRow.id,
            regionId: regionRow.id,
            countryId: countryRow.id,
            address: place.address || null,
            googlePlaceId: place.googlePlaceId || null,
            googleRating: place.googleRating || null,
            locationLat: place.locationLat || null,
            locationLng: place.locationLng || null,
          })
          .returning();

        results.push(draft);
        console.log(`[AI Draft] Saved: ${place.placeName}`);
      } catch (error) {
        console.error(`[AI Draft] Error saving ${place.placeName}:`, error);
      }
    }

    return results;
  }

  // Specialists (旅遊專員)
  async getSpecialistByUserId(userId: string): Promise<Specialist | undefined> {
    const [specialist] = await db.select().from(specialists).where(eq(specialists.userId, userId));
    return specialist || undefined;
  }

  async getSpecialistById(id: number): Promise<Specialist | undefined> {
    const [specialist] = await db.select().from(specialists).where(eq(specialists.id, id));
    return specialist || undefined;
  }

  async createSpecialist(specialist: InsertSpecialist): Promise<Specialist> {
    const [created] = await db.insert(specialists).values(specialist).returning();
    return created;
  }

  async updateSpecialist(id: number, data: Partial<Specialist>): Promise<Specialist | undefined> {
    const [updated] = await db.update(specialists).set(data).where(eq(specialists.id, id)).returning();
    return updated || undefined;
  }

  async getActiveSpecialistsByRegion(serviceRegion: string): Promise<Specialist[]> {
    return await db.select().from(specialists).where(
      and(
        eq(specialists.isAvailable, true),
        eq(specialists.serviceRegion, serviceRegion)
      )
    );
  }

  async findAvailableSpecialist(serviceRegion: string): Promise<Specialist | undefined> {
    const [specialist] = await db
      .select()
      .from(specialists)
      .where(
        and(
          eq(specialists.isAvailable, true),
          eq(specialists.serviceRegion, serviceRegion),
          sql`${specialists.currentTravelers} < ${specialists.maxTravelers}`
        )
      )
      .orderBy(sql`RANDOM()`)
      .limit(1);
    return specialist || undefined;
  }

  // Transactions (交易紀錄)
  async createTransaction(transaction: InsertTransaction): Promise<Transaction> {
    const [created] = await db.insert(transactions).values(transaction).returning();
    return created;
  }

  async getTransactionById(id: number): Promise<Transaction | undefined> {
    const [transaction] = await db.select().from(transactions).where(eq(transactions.id, id));
    return transaction || undefined;
  }

  async getTransactionsByMerchantId(merchantId: number): Promise<Transaction[]> {
    return await db.select().from(transactions).where(eq(transactions.merchantId, merchantId)).orderBy(desc(transactions.createdAt));
  }

  async updateTransactionStatus(id: number, status: string): Promise<Transaction | undefined> {
    const [updated] = await db.update(transactions).set({ paymentStatus: status, paidAt: status === 'paid' ? new Date() : undefined }).where(eq(transactions.id, id)).returning();
    return updated || undefined;
  }

  // Service Relations (服務關係)
  async createServiceRelation(relation: InsertServiceRelation): Promise<ServiceRelation> {
    const [created] = await db.insert(serviceRelations).values(relation).returning();
    return created;
  }

  async getServiceRelationById(id: number): Promise<ServiceRelation | undefined> {
    const [relation] = await db.select().from(serviceRelations).where(eq(serviceRelations.id, id));
    return relation || undefined;
  }

  async getActiveServiceRelationByTraveler(travelerId: string): Promise<ServiceRelation | undefined> {
    const [relation] = await db
      .select()
      .from(serviceRelations)
      .where(
        and(
          eq(serviceRelations.travelerId, travelerId),
          eq(serviceRelations.status, 'active')
        )
      );
    return relation || undefined;
  }

  async getActiveServiceRelationsBySpecialist(specialistId: number): Promise<ServiceRelation[]> {
    return await db
      .select()
      .from(serviceRelations)
      .where(
        and(
          eq(serviceRelations.specialistId, specialistId),
          eq(serviceRelations.status, 'active')
        )
      );
  }

  async updateServiceRelation(id: number, data: Partial<ServiceRelation>): Promise<ServiceRelation | undefined> {
    const [updated] = await db.update(serviceRelations).set(data).where(eq(serviceRelations.id, id)).returning();
    return updated || undefined;
  }

  async endServiceRelation(id: number, rating?: number): Promise<ServiceRelation | undefined> {
    const updateData: Partial<ServiceRelation> = {
      status: 'completed',
      endedAt: new Date(),
    };
    // Note: rating is stored but not used since schema doesn't have rating field
    const [updated] = await db.update(serviceRelations).set(updateData).where(eq(serviceRelations.id, id)).returning();
    return updated || undefined;
  }

  // Merchant Credits (商家點數)
  async getMerchantById(id: number): Promise<Merchant | undefined> {
    const [merchant] = await db.select().from(merchants).where(eq(merchants.id, id));
    return merchant || undefined;
  }

  async updateMerchantDailySeedCode(merchantId: number, seedCode: string): Promise<Merchant | undefined> {
    const [updated] = await db
      .update(merchants)
      .set({ 
        dailySeedCode: seedCode, 
        codeUpdatedAt: new Date() 
      })
      .where(eq(merchants.id, merchantId))
      .returning();
    return updated || undefined;
  }

  async updateMerchantCreditBalance(merchantId: number, amount: number): Promise<Merchant | undefined> {
    const [updated] = await db
      .update(merchants)
      .set({ 
        creditBalance: sql`${merchants.creditBalance} + ${amount}` 
      })
      .where(eq(merchants.id, merchantId))
      .returning();
    return updated || undefined;
  }

  async getMerchantDailySeedCode(merchantId: number): Promise<{ seedCode: string; updatedAt: Date } | undefined> {
    const [merchant] = await db
      .select({ 
        dailySeedCode: merchants.dailySeedCode, 
        codeUpdatedAt: merchants.codeUpdatedAt 
      })
      .from(merchants)
      .where(eq(merchants.id, merchantId));
    
    if (merchant?.dailySeedCode && merchant?.codeUpdatedAt) {
      return { seedCode: merchant.dailySeedCode, updatedAt: merchant.codeUpdatedAt };
    }
    return undefined;
  }

  // Announcements & Events (公告與活動系統)
  async createAnnouncement(announcement: InsertAnnouncement): Promise<Announcement> {
    const [created] = await db.insert(announcements).values(announcement).returning();
    return created;
  }

  async getAnnouncementById(id: number): Promise<Announcement | undefined> {
    const [announcement] = await db.select().from(announcements).where(eq(announcements.id, id));
    return announcement || undefined;
  }

  async getAllAnnouncements(): Promise<Announcement[]> {
    return db.select().from(announcements).orderBy(desc(announcements.priority), desc(announcements.createdAt));
  }

  async getActiveAnnouncements(type?: AnnouncementType): Promise<Announcement[]> {
    const now = new Date();
    const conditions = [
      eq(announcements.isActive, true),
      lte(announcements.startDate, now),
      or(
        isNull(announcements.endDate),
        gte(announcements.endDate, now)
      )
    ];
    
    if (type) {
      conditions.push(eq(announcements.type, type));
    }
    
    return db.select()
      .from(announcements)
      .where(and(...conditions))
      .orderBy(desc(announcements.priority), desc(announcements.createdAt));
  }

  async updateAnnouncement(id: number, data: Partial<Announcement>): Promise<Announcement | undefined> {
    const [updated] = await db
      .update(announcements)
      .set({ ...data, updatedAt: new Date() })
      .where(eq(announcements.id, id))
      .returning();
    return updated || undefined;
  }

  async deleteAnnouncement(id: number): Promise<void> {
    await db.delete(announcements).where(eq(announcements.id, id));
  }

  async deleteExpiredEvents(): Promise<number> {
    const now = new Date();
    const result = await db
      .delete(announcements)
      .where(
        and(
          or(
            eq(announcements.type, 'flash_event'),
            eq(announcements.type, 'holiday_event')
          ),
          lt(announcements.endDate, now)
        )
      )
      .returning();
    return result.length;
  }

  // Ad Placements (廣告設定)
  async getAllAdPlacements(): Promise<AdPlacementRecord[]> {
    return db.select().from(adPlacements).orderBy(adPlacements.placementKey);
  }

  async getAdPlacement(placementKey: string, platform?: string): Promise<AdPlacementRecord | undefined> {
    const conditions = [eq(adPlacements.placementKey, placementKey), eq(adPlacements.isActive, true)];
    if (platform && platform !== 'all') {
      conditions.push(or(eq(adPlacements.platform, platform), eq(adPlacements.platform, 'all'))!);
    }
    const [placement] = await db.select().from(adPlacements).where(and(...conditions));
    return placement || undefined;
  }

  async createAdPlacement(placement: InsertAdPlacement): Promise<AdPlacementRecord> {
    const [created] = await db.insert(adPlacements).values(placement).returning();
    return created;
  }

  async updateAdPlacement(id: number, data: Partial<AdPlacementRecord>): Promise<AdPlacementRecord | undefined> {
    const [updated] = await db.update(adPlacements).set({ ...data, updatedAt: new Date() }).where(eq(adPlacements.id, id)).returning();
    return updated || undefined;
  }

  async deleteAdPlacement(id: number): Promise<void> {
    await db.delete(adPlacements).where(eq(adPlacements.id, id));
  }

  // User Notifications (未讀通知)
  async getUserNotifications(userId: string): Promise<UserNotification[]> {
    return db.select().from(userNotifications).where(eq(userNotifications.userId, userId));
  }

  async incrementUnreadCount(userId: string, notificationType: string): Promise<void> {
    const [existing] = await db.select().from(userNotifications)
      .where(and(eq(userNotifications.userId, userId), eq(userNotifications.notificationType, notificationType)));
    
    if (existing) {
      await db.update(userNotifications)
        .set({ unreadCount: sql`${userNotifications.unreadCount} + 1`, lastUpdatedAt: new Date() })
        .where(eq(userNotifications.id, existing.id));
    } else {
      await db.insert(userNotifications).values({ userId, notificationType, unreadCount: 1 });
    }
  }

  async markNotificationsSeen(userId: string, notificationType: string): Promise<void> {
    await db.update(userNotifications)
      .set({ unreadCount: 0, lastSeenAt: new Date() })
      .where(and(eq(userNotifications.userId, userId), eq(userNotifications.notificationType, notificationType)));
  }

  // Coupon Redemption (優惠券核銷)
  async createCouponRedemption(redemption: InsertCouponRedemption): Promise<CouponRedemption> {
    const [created] = await db.insert(couponRedemptions).values(redemption).returning();
    return created;
  }

  async createAndVerifyCouponRedemption(redemption: InsertCouponRedemption): Promise<CouponRedemption> {
    const [created] = await db.insert(couponRedemptions).values({
      ...redemption,
      status: 'verified',
      verifiedAt: new Date()
    }).returning();
    return created;
  }

  async verifyCouponRedemption(redemptionId: number): Promise<CouponRedemption | undefined> {
    const expiresAt = new Date(Date.now() + 3 * 60 * 1000); // 3 minutes from now
    const [updated] = await db.update(couponRedemptions)
      .set({ status: 'verified', verifiedAt: new Date(), expiresAt })
      .where(eq(couponRedemptions.id, redemptionId))
      .returning();
    return updated || undefined;
  }

  async expireRedemptionsAndDeleteCoupons(): Promise<number> {
    const now = new Date();
    const expiredRedemptions = await db.select()
      .from(couponRedemptions)
      .where(and(eq(couponRedemptions.status, 'verified'), lt(couponRedemptions.expiresAt, now)));
    
    for (const redemption of expiredRedemptions) {
      await db.update(userInventory)
        .set({ isRedeemed: true, redeemedAt: new Date() })
        .where(eq(userInventory.id, redemption.userInventoryId));
      
      await db.update(couponRedemptions)
        .set({ status: 'expired' })
        .where(eq(couponRedemptions.id, redemption.id));
    }
    return expiredRedemptions.length;
  }

  // User Inventory (道具箱) - Grid system with 30 slots
  async getUserInventory(userId: string): Promise<UserInventoryItem[]> {
    return db.select().from(userInventory)
      .where(and(
        eq(userInventory.userId, userId), 
        eq(userInventory.isDeleted, false)
      ))
      .orderBy(userInventory.slotIndex);
  }

  async getInventorySlotCount(userId: string): Promise<number> {
    const result = await db.select({ count: sql<number>`count(*)` })
      .from(userInventory)
      .where(and(eq(userInventory.userId, userId), eq(userInventory.isDeleted, false)));
    return Number(result[0]?.count || 0);
  }

  async isInventoryFull(userId: string): Promise<boolean> {
    const count = await this.getInventorySlotCount(userId);
    return count >= INVENTORY_MAX_SLOTS;
  }

  async getNextAvailableSlot(userId: string): Promise<number | null> {
    const items = await db.select({ slotIndex: userInventory.slotIndex })
      .from(userInventory)
      .where(and(eq(userInventory.userId, userId), eq(userInventory.isDeleted, false)));
    
    const usedSlots = new Set(items.map(i => i.slotIndex));
    for (let i = 0; i < INVENTORY_MAX_SLOTS; i++) {
      if (!usedSlots.has(i)) return i;
    }
    return null;
  }

  async addToUserInventory(item: InsertUserInventoryItem): Promise<UserInventoryItem | null> {
    const nextSlot = await this.getNextAvailableSlot(item.userId);
    if (nextSlot === null) return null; // Inventory full
    
    const [created] = await db.insert(userInventory).values({
      ...item,
      slotIndex: nextSlot
    }).returning();
    await this.incrementUnreadCount(item.userId, 'itembox');
    return created;
  }

  async markInventoryItemRead(itemId: number): Promise<void> {
    await db.update(userInventory).set({ isRead: true }).where(eq(userInventory.id, itemId));
  }

  async softDeleteInventoryItem(itemId: number, userId: string): Promise<boolean> {
    const [item] = await db.select().from(userInventory)
      .where(and(eq(userInventory.id, itemId), eq(userInventory.userId, userId)));
    if (!item) return false;
    
    await db.update(userInventory)
      .set({ isDeleted: true, deletedAt: new Date(), status: 'deleted' })
      .where(eq(userInventory.id, itemId));
    return true;
  }

  async getInventoryItemById(itemId: number, userId: string): Promise<UserInventoryItem | undefined> {
    const [item] = await db.select().from(userInventory)
      .where(and(eq(userInventory.id, itemId), eq(userInventory.userId, userId), eq(userInventory.isDeleted, false)));
    return item || undefined;
  }

  async getUnreadInventoryCount(userId: string): Promise<number> {
    const result = await db.select({ count: sql<number>`count(*)` })
      .from(userInventory)
      .where(and(eq(userInventory.userId, userId), eq(userInventory.isRead, false), eq(userInventory.isDeleted, false)));
    return Number(result[0]?.count || 0);
  }

  // Coupon Rarity Config (優惠券機率設定)
  async getGlobalRarityConfig(): Promise<CouponRarityConfig | undefined> {
    const [config] = await db.select().from(couponRarityConfigs)
      .where(and(eq(couponRarityConfigs.configKey, 'global'), eq(couponRarityConfigs.isActive, true)));
    return config || undefined;
  }

  async getAllRarityConfigs(): Promise<CouponRarityConfig[]> {
    return db.select().from(couponRarityConfigs).orderBy(couponRarityConfigs.configKey);
  }

  async upsertRarityConfig(config: InsertCouponRarityConfig): Promise<CouponRarityConfig> {
    const [existing] = await db.select().from(couponRarityConfigs)
      .where(eq(couponRarityConfigs.configKey, config.configKey || 'global'));
    
    if (existing) {
      const [updated] = await db.update(couponRarityConfigs)
        .set({ ...config, updatedAt: new Date() })
        .where(eq(couponRarityConfigs.id, existing.id))
        .returning();
      return updated;
    } else {
      const [created] = await db.insert(couponRarityConfigs).values(config).returning();
      return created;
    }
  }

  async deleteRarityConfig(id: number): Promise<void> {
    await db.delete(couponRarityConfigs).where(eq(couponRarityConfigs.id, id));
  }

  // Generate coupon tier based on probability
  async rollCouponTier(): Promise<string | null> {
    const config = await this.getGlobalRarityConfig();
    const rates = config ? {
      SP: config.spRate,
      SSR: config.ssrRate,
      SR: config.srRate,
      S: config.sRate,
      R: config.rRate
    } : { SP: 2, SSR: 8, SR: 15, S: 23, R: 32 };

    const roll = Math.random() * 100;
    let cumulative = 0;
    
    for (const [tier, rate] of Object.entries(rates)) {
      cumulative += rate;
      if (roll < cumulative) return tier;
    }
    return null; // No coupon (remaining probability)
  }

  // Merchant Coupons (商家優惠券模板)
  async getMerchantCouponsByPlaceLink(merchantPlaceLinkId: number): Promise<MerchantCoupon[]> {
    return db.select().from(merchantCoupons)
      .where(and(eq(merchantCoupons.merchantPlaceLinkId, merchantPlaceLinkId), eq(merchantCoupons.isActive, true)));
  }

  async getMerchantPlaceLinkByPlaceName(placeName: string, district: string, city: string): Promise<MerchantPlaceLink | undefined> {
    const [link] = await db.select().from(merchantPlaceLinks)
      .where(and(
        eq(merchantPlaceLinks.placeName, placeName),
        eq(merchantPlaceLinks.district, district),
        eq(merchantPlaceLinks.city, city),
        eq(merchantPlaceLinks.status, 'approved')
      ));
    return link || undefined;
  }

  // Collection with promo check (圖鑑新增)
  async checkCollectionExists(userId: string, placeName: string, district: string): Promise<boolean> {
    const [existing] = await db.select({ id: collections.id })
      .from(collections)
      .where(and(
        eq(collections.userId, userId),
        eq(collections.placeName, placeName),
        eq(collections.district, district || '')
      ));
    return !!existing;
  }

  async getCollectionWithPromoStatus(userId: string): Promise<any[]> {
    const userCollections = await db.select().from(collections).where(eq(collections.userId, userId));
    
    const enrichedCollections = await Promise.all(userCollections.map(async (col) => {
      const merchantLink = await this.getMerchantPlaceLinkByPlaceName(
        col.placeName, col.district || '', col.city
      );
      return {
        ...col,
        hasPromo: merchantLink?.isPromoActive || false,
        promoTitle: merchantLink?.promoTitle,
        promoDescription: merchantLink?.promoDescription
      };
    }));
    
    return enrichedCollections;
  }

  // ============ SOS Alerts (安全中心求救) ============
  
  async createSosAlert(data: InsertSosAlert): Promise<SosAlert> {
    const [alert] = await db.insert(sosAlerts).values(data).returning();
    return alert;
  }

  async getSosAlertById(alertId: number): Promise<SosAlert | undefined> {
    const [alert] = await db.select().from(sosAlerts).where(eq(sosAlerts.id, alertId));
    return alert || undefined;
  }

  async getUserSosAlerts(userId: string): Promise<SosAlert[]> {
    return db.select().from(sosAlerts)
      .where(eq(sosAlerts.userId, userId))
      .orderBy(desc(sosAlerts.createdAt));
  }

  async getPlannerSosAlerts(plannerId: number): Promise<SosAlert[]> {
    return db.select().from(sosAlerts)
      .where(eq(sosAlerts.plannerId, plannerId))
      .orderBy(desc(sosAlerts.createdAt));
  }

  async getPendingSosAlerts(): Promise<SosAlert[]> {
    return db.select().from(sosAlerts)
      .where(eq(sosAlerts.status, 'pending'))
      .orderBy(desc(sosAlerts.createdAt));
  }

  async updateSosAlertStatus(alertId: number, status: SosAlertStatus, acknowledgedBy?: string): Promise<SosAlert | undefined> {
    const updateData: Partial<SosAlert> = { status };
    
    if (status === 'acknowledged' && acknowledgedBy) {
      updateData.acknowledgedBy = acknowledgedBy;
      updateData.acknowledgedAt = new Date();
    } else if (status === 'resolved') {
      updateData.resolvedAt = new Date();
    }
    
    const [alert] = await db.update(sosAlerts)
      .set(updateData)
      .where(eq(sosAlerts.id, alertId))
      .returning();
    return alert || undefined;
  }

  async hasUserPurchasedTripService(userId: string): Promise<boolean> {
    const [order] = await db.select({ id: serviceOrders.id })
      .from(serviceOrders)
      .where(and(
        eq(serviceOrders.userId, userId),
        eq(serviceOrders.status, 'completed')
      ));
    return !!order;
  }

  // ============ Merchant Analytics (商家數據分析) ============

  async recordMerchantAnalytics(data: InsertMerchantAnalytics): Promise<MerchantAnalytics> {
    const [record] = await db.insert(merchantAnalytics).values(data).returning();
    return record;
  }

  async getMerchantAnalytics(merchantId: number, startDate?: string, endDate?: string): Promise<MerchantAnalytics[]> {
    const conditions = [eq(merchantAnalytics.merchantId, merchantId)];
    
    if (startDate) {
      conditions.push(gte(merchantAnalytics.date, startDate));
    }
    if (endDate) {
      conditions.push(lte(merchantAnalytics.date, endDate));
    }
    
    return db.select().from(merchantAnalytics)
      .where(and(...conditions))
      .orderBy(desc(merchantAnalytics.date));
  }

  async getMerchantAnalyticsSummary(merchantId: number): Promise<{
    totalCollectors: number;
    totalClicks: number;
    totalCouponUsage: number;
    totalCouponIssued: number;
    totalPrizePoolViews: number;
    todayCollected: number;
  }> {
    const today = new Date().toISOString().split('T')[0];
    
    const result = await db.select({
      totalCollectors: sql<number>`COALESCE(SUM(${merchantAnalytics.totalCollectors}), 0)`,
      totalClicks: sql<number>`COALESCE(SUM(${merchantAnalytics.clickCount}), 0)`,
      totalCouponUsage: sql<number>`COALESCE(SUM(${merchantAnalytics.couponUsageCount}), 0)`,
      totalCouponIssued: sql<number>`COALESCE(SUM(${merchantAnalytics.couponIssuedCount}), 0)`,
      totalPrizePoolViews: sql<number>`COALESCE(SUM(${merchantAnalytics.prizePoolViews}), 0)`,
    }).from(merchantAnalytics)
      .where(eq(merchantAnalytics.merchantId, merchantId));

    const todayResult = await db.select({
      todayCollected: sql<number>`COALESCE(SUM(${merchantAnalytics.collectedCount}), 0)`,
    }).from(merchantAnalytics)
      .where(and(
        eq(merchantAnalytics.merchantId, merchantId),
        eq(merchantAnalytics.date, today)
      ));

    return {
      totalCollectors: Number(result[0]?.totalCollectors) || 0,
      totalClicks: Number(result[0]?.totalClicks) || 0,
      totalCouponUsage: Number(result[0]?.totalCouponUsage) || 0,
      totalCouponIssued: Number(result[0]?.totalCouponIssued) || 0,
      totalPrizePoolViews: Number(result[0]?.totalPrizePoolViews) || 0,
      todayCollected: Number(todayResult[0]?.todayCollected) || 0,
    };
  }

  async incrementAnalyticsCounter(
    merchantId: number, 
    placeId: number | null, 
    field: 'collectedCount' | 'clickCount' | 'couponUsageCount' | 'couponIssuedCount' | 'prizePoolViews'
  ): Promise<void> {
    const today = new Date().toISOString().split('T')[0];
    
    const existing = await db.select().from(merchantAnalytics)
      .where(and(
        eq(merchantAnalytics.merchantId, merchantId),
        placeId ? eq(merchantAnalytics.placeId, placeId) : isNull(merchantAnalytics.placeId),
        eq(merchantAnalytics.date, today)
      ));

    if (existing.length > 0) {
      const updateData: Record<string, any> = { updatedAt: new Date() };
      updateData[field] = sql`${merchantAnalytics[field]} + 1`;
      
      if (field === 'collectedCount') {
        updateData.totalCollectors = sql`${merchantAnalytics.totalCollectors} + 1`;
      }

      await db.update(merchantAnalytics)
        .set(updateData)
        .where(eq(merchantAnalytics.id, existing[0].id));
    } else {
      const insertData: InsertMerchantAnalytics = {
        merchantId,
        placeId,
        date: today,
        collectedCount: field === 'collectedCount' ? 1 : 0,
        totalCollectors: field === 'collectedCount' ? 1 : 0,
        clickCount: field === 'clickCount' ? 1 : 0,
        couponUsageCount: field === 'couponUsageCount' ? 1 : 0,
        couponIssuedCount: field === 'couponIssuedCount' ? 1 : 0,
        prizePoolViews: field === 'prizePoolViews' ? 1 : 0,
      };
      await db.insert(merchantAnalytics).values(insertData);
    }
  }

  async syncRecord(tableName: string, record: any): Promise<'inserted' | 'skipped' | 'error'> {
    try {
      switch (tableName) {
        case 'countries': {
          const [existing] = await db.select().from(countries).where(eq(countries.id, record.id));
          if (existing) return 'skipped';
          await db.execute(sql`
            INSERT INTO countries (id, code, name_en, name_zh, name_ja, name_ko, is_active)
            VALUES (${record.id}, ${record.code}, ${record.name_en}, ${record.name_zh}, ${record.name_ja}, ${record.name_ko}, ${record.is_active ?? true})
          `);
          return 'inserted';
        }
        case 'regions': {
          const [existing] = await db.select().from(regions).where(eq(regions.id, record.id));
          if (existing) return 'skipped';
          await db.execute(sql`
            INSERT INTO regions (id, country_id, code, name_en, name_zh, name_ja, name_ko, is_active)
            VALUES (${record.id}, ${record.country_id}, ${record.code}, ${record.name_en}, ${record.name_zh}, ${record.name_ja}, ${record.name_ko}, ${record.is_active ?? true})
          `);
          return 'inserted';
        }
        case 'districts': {
          const [existing] = await db.select().from(districts).where(eq(districts.id, record.id));
          if (existing) return 'skipped';
          await db.execute(sql`
            INSERT INTO districts (id, region_id, code, name_en, name_zh, name_ja, name_ko, is_active)
            VALUES (${record.id}, ${record.region_id}, ${record.code}, ${record.name_en}, ${record.name_zh}, ${record.name_ja}, ${record.name_ko}, ${record.is_active ?? true})
          `);
          return 'inserted';
        }
        case 'categories': {
          const [existing] = await db.select().from(categories).where(eq(categories.id, record.id));
          if (existing) return 'skipped';
          await db.execute(sql`
            INSERT INTO categories (id, code, name_en, name_zh, name_ja, name_ko, color_hex, sort_order, is_active)
            VALUES (${record.id}, ${record.code}, ${record.name_en}, ${record.name_zh}, ${record.name_ja}, ${record.name_ko}, ${record.color_hex}, ${record.sort_order}, ${record.is_active ?? true})
          `);
          return 'inserted';
        }
        case 'subcategories': {
          const [existing] = await db.select().from(subcategories).where(eq(subcategories.id, record.id));
          if (existing) return 'skipped';
          await db.execute(sql`
            INSERT INTO subcategories (id, category_id, code, name_en, name_zh, name_ja, name_ko, search_keywords, is_active, preferred_time_slot)
            VALUES (${record.id}, ${record.category_id}, ${record.code}, ${record.name_en}, ${record.name_zh}, ${record.name_ja}, ${record.name_ko}, ${record.search_keywords}, ${record.is_active ?? true}, ${record.preferred_time_slot})
          `);
          return 'inserted';
        }
        case 'service_plans': {
          const result = await db.execute(sql`SELECT 1 FROM service_plans WHERE id = ${record.id}`);
          if (result.rows && result.rows.length > 0) return 'skipped';
          await db.execute(sql`
            INSERT INTO service_plans (id, name, description, price_per_hour, features, is_active)
            VALUES (${record.id}, ${record.name}, ${record.description}, ${record.price_per_hour}, ${record.features}, ${record.is_active ?? true})
          `);
          return 'inserted';
        }
        case 'places': {
          if (record.google_place_id) {
            const existing = await this.getPlaceByGoogleId(record.google_place_id);
            if (existing) return 'skipped';
          }
          await db.insert(places).values({
            placeName: record.place_name,
            category: record.category,
            subcategory: record.subcategory,
            city: record.city,
            district: record.district,
            country: record.country,
            description: record.description,
            address: record.address,
            rating: record.rating?.toString(),
            locationLat: record.location_lat?.toString(),
            locationLng: record.location_lng?.toString(),
            googlePlaceId: record.google_place_id,
          });
          return 'inserted';
        }
        case 'place_cache': {
          if (record.place_id) {
            const result = await db.execute(sql`SELECT 1 FROM place_cache WHERE place_id = ${record.place_id}`);
            if (result.rows && result.rows.length > 0) return 'skipped';
          }
          await db.execute(sql`
            INSERT INTO place_cache (
              sub_category, district, city, country, place_name, description, category,
              suggested_time, duration, search_query, rarity, color_hex, place_id,
              verified_name, verified_address, google_rating, location_lat, location_lng,
              is_location_verified, business_status, google_types, primary_type, ai_reviewed
            ) VALUES (
              ${record.sub_category}, ${record.district}, ${record.city}, ${record.country},
              ${record.place_name}, ${record.description}, ${record.category},
              ${record.suggested_time}, ${record.duration}, ${record.search_query},
              ${record.rarity}, ${record.color_hex}, ${record.place_id},
              ${record.verified_name}, ${record.verified_address}, ${record.google_rating},
              ${record.location_lat}, ${record.location_lng}, ${record.is_location_verified ?? false},
              ${record.business_status}, ${record.google_types}, ${record.primary_type},
              ${record.ai_reviewed ?? false}
            )
          `);
          return 'inserted';
        }
        default:
          console.warn(`Unknown table for sync: ${tableName}`);
          return 'error';
      }
    } catch (err) {
      console.error(`Sync error for ${tableName}:`, err);
      return 'error';
    }
  }

  // ============ User Daily Gacha Stats (每日抽卡統計) ============
  
  async getUserDailyGachaCount(userId: string): Promise<number> {
    const today = new Date().toISOString().split('T')[0]; // YYYY-MM-DD
    const [stat] = await db.select()
      .from(userDailyGachaStats)
      .where(and(
        eq(userDailyGachaStats.userId, userId),
        eq(userDailyGachaStats.date, today)
      ));
    return stat?.pullCount || 0;
  }

  async incrementUserDailyGachaCount(userId: string, count: number): Promise<number> {
    const today = new Date().toISOString().split('T')[0];
    const [existing] = await db.select()
      .from(userDailyGachaStats)
      .where(and(
        eq(userDailyGachaStats.userId, userId),
        eq(userDailyGachaStats.date, today)
      ));
    
    if (existing) {
      const newCount = existing.pullCount + count;
      await db.update(userDailyGachaStats)
        .set({ pullCount: newCount, updatedAt: new Date() })
        .where(eq(userDailyGachaStats.id, existing.id));
      return newCount;
    } else {
      await db.insert(userDailyGachaStats).values({
        userId,
        date: today,
        pullCount: count
      });
      return count;
    }
  }

  // ============ Delete User Account (刪除帳號) ============
  
  async deleteUserAccount(userId: string): Promise<{ success: boolean; error?: string; code?: string }> {
    try {
      // 0. 檢查是否有商家身份（商家帳號需要先取消商家身份才能刪除）
      const [merchant] = await db.select().from(merchants).where(eq(merchants.userId, userId));
      if (merchant) {
        console.log(`[Account Deletion] User ${userId} has merchant account, deletion blocked`);
        return { 
          success: false, 
          error: "您有商家身份，請先取消商家資格後再刪除帳號",
          code: "MERCHANT_ACCOUNT_EXISTS"
        };
      }
      
      // 依序刪除用戶相關資料（注意外鍵順序）
      // 1. 通知和統計
      await db.delete(userNotifications).where(eq(userNotifications.userId, userId));
      await db.delete(userDailyGachaStats).where(eq(userDailyGachaStats.userId, userId));
      
      // 2. 背包和優惠券兌換
      await db.delete(userInventory).where(eq(userInventory.userId, userId));
      await db.delete(couponRedemptions).where(eq(couponRedemptions.userId, userId));
      
      // 3. 收藏和位置
      await db.delete(collections).where(eq(collections.userId, userId));
      await db.delete(userLocations).where(eq(userLocations.userId, userId));
      await db.delete(placeFeedback).where(eq(placeFeedback.userId, userId));
      
      // 4. 聊天邀請
      await db.delete(chatInvites).where(eq(chatInvites.inviterUserId, userId));
      await db.delete(chatInvites).where(eq(chatInvites.usedByUserId, userId));
      
      // 5. SOS 相關
      await db.delete(sosAlerts).where(eq(sosAlerts.userId, userId));
      await db.delete(sosEvents).where(eq(sosEvents.userId, userId));
      
      // 5b. 旅行同伴
      await db.delete(travelCompanions).where(eq(travelCompanions.userId, userId));
      
      // 6. 服務關係 (作為旅客)
      await db.delete(serviceRelations).where(eq(serviceRelations.travelerId, userId));
      
      // 7. 購物車、服務訂單和商業訂單
      await db.delete(cartItems).where(eq(cartItems.userId, userId));
      await db.delete(serviceOrders).where(eq(serviceOrders.userId, userId));
      await db.delete(commerceOrders).where(eq(commerceOrders.userId, userId));
      
      // 8. 規劃師
      await db.delete(planners).where(eq(planners.userId, userId));
      
      // 9. 專員（需要先處理專員的服務關係）
      const userSpecialists = await db.select().from(specialists).where(eq(specialists.userId, userId));
      for (const specialist of userSpecialists) {
        // 刪除專員的服務關係
        await db.delete(serviceRelations).where(eq(serviceRelations.specialistId, specialist.id));
        // 將該專員相關的購買記錄的 specialistId 設為 null（保留購買歷史）
        await db.update(tripServicePurchases)
          .set({ specialistId: null })
          .where(eq(tripServicePurchases.specialistId, specialist.id));
      }
      await db.delete(specialists).where(eq(specialists.userId, userId));
      
      // 10. 旅程規劃（需要先刪除子表）
      const userTripPlans = await db.select().from(tripPlans).where(eq(tripPlans.userId, userId));
      for (const plan of userTripPlans) {
        // 刪除 tripActivities (依賴 tripDays)
        const planDays = await db.select().from(tripDays).where(eq(tripDays.tripPlanId, plan.id));
        for (const day of planDays) {
          await db.delete(tripActivities).where(eq(tripActivities.tripDayId, day.id));
        }
        // 刪除 tripDays
        await db.delete(tripDays).where(eq(tripDays.tripPlanId, plan.id));
      }
      // 刪除 tripPlans
      await db.delete(tripPlans).where(eq(tripPlans.userId, userId));
      
      // 11. 其他用戶相關資料
      await db.delete(userProfiles).where(eq(userProfiles.userId, userId));
      await db.delete(collectionReadStatus).where(eq(collectionReadStatus.userId, userId));
      
      // 將購買記錄的 purchasedForUserId 設為 null（當用戶是受益者時）
      await db.update(tripServicePurchases)
        .set({ purchasedForUserId: null })
        .where(eq(tripServicePurchases.purchasedForUserId, userId));
      // 刪除用戶自己購買的記錄
      await db.delete(tripServicePurchases).where(eq(tripServicePurchases.userId, userId));
      
      // 最後刪除用戶本身
      await db.delete(users).where(eq(users.id, userId));
      
      return { success: true };
    } catch (error) {
      console.error('Delete user account error:', error);
      return { 
        success: false, 
        error: "刪除帳號時發生錯誤",
        code: "DELETE_FAILED" 
      };
    }
  }
}

export const storage = new DatabaseStorage();


=== File: server/stripeClient.ts ===

import Stripe from 'stripe';

let connectionSettings: any;

async function getCredentials() {
  const hostname = process.env.REPLIT_CONNECTORS_HOSTNAME;
  const xReplitToken = process.env.REPL_IDENTITY
    ? 'repl ' + process.env.REPL_IDENTITY
    : process.env.WEB_REPL_RENEWAL
      ? 'depl ' + process.env.WEB_REPL_RENEWAL
      : null;

  if (!xReplitToken) {
    throw new Error('X_REPLIT_TOKEN not found for repl/depl');
  }

  const connectorName = 'stripe';
  const isProduction = process.env.REPLIT_DEPLOYMENT === '1';
  const targetEnvironment = isProduction ? 'production' : 'development';

  const url = new URL(`https://${hostname}/api/v2/connection`);
  url.searchParams.set('include_secrets', 'true');
  url.searchParams.set('connector_names', connectorName);
  url.searchParams.set('environment', targetEnvironment);

  const response = await fetch(url.toString(), {
    headers: {
      'Accept': 'application/json',
      'X_REPLIT_TOKEN': xReplitToken
    }
  });

  const data = await response.json();
  
  connectionSettings = data.items?.[0];

  if (!connectionSettings || (!connectionSettings.settings.publishable || !connectionSettings.settings.secret)) {
    throw new Error(`Stripe ${targetEnvironment} connection not found`);
  }

  return {
    publishableKey: connectionSettings.settings.publishable,
    secretKey: connectionSettings.settings.secret,
  };
}

export async function getUncachableStripeClient() {
  const { secretKey } = await getCredentials();

  return new Stripe(secretKey, {
    apiVersion: '2025-11-17.clover',
  });
}

export async function getStripePublishableKey() {
  const { publishableKey } = await getCredentials();
  return publishableKey;
}

export async function getStripeSecretKey() {
  const { secretKey } = await getCredentials();
  return secretKey;
}

let stripeSync: any = null;

export async function getStripeSync() {
  if (!stripeSync) {
    const { StripeSync } = await import('stripe-replit-sync');
    const secretKey = await getStripeSecretKey();

    stripeSync = new StripeSync({
      poolConfig: {
        connectionString: process.env.DATABASE_URL!,
        max: 2,
        ssl: {
          rejectUnauthorized: false,
        },
      },
      stripeSecretKey: secretKey,
    });
  }
  return stripeSync;
}


=== File: server/stripeRoutes.ts ===

import type { Express, Request, Response } from 'express';
import { stripeService } from './stripeService';
import { stripeStorage } from './stripeStorage';
import { getUncachableStripeClient, getStripePublishableKey } from './stripeClient';
import { storage } from './storage';

export function registerStripeRoutes(app: Express) {
  app.get('/api/stripe/publishable-key', async (req: Request, res: Response) => {
    try {
      const publishableKey = await getStripePublishableKey();
      res.json({ publishableKey });
    } catch (error: any) {
      console.error('Error getting publishable key:', error);
      res.status(500).json({ error: 'Failed to get Stripe configuration' });
    }
  });

  app.get('/api/stripe/products', async (req: Request, res: Response) => {
    try {
      const products = await stripeStorage.listProducts();
      res.json({ data: products });
    } catch (error: any) {
      console.error('Error listing products:', error);
      res.status(500).json({ error: 'Failed to list products' });
    }
  });

  app.get('/api/stripe/products-with-prices', async (req: Request, res: Response) => {
    try {
      const rows = await stripeStorage.listProductsWithPrices();

      const productsMap = new Map();
      for (const row of rows as any[]) {
        if (!productsMap.has(row.product_id)) {
          productsMap.set(row.product_id, {
            id: row.product_id,
            name: row.product_name,
            description: row.product_description,
            active: row.product_active,
            metadata: row.product_metadata,
            prices: []
          });
        }
        if (row.price_id) {
          productsMap.get(row.product_id).prices.push({
            id: row.price_id,
            unit_amount: row.unit_amount,
            currency: row.currency,
            recurring: row.recurring,
            active: row.price_active,
            metadata: row.price_metadata,
          });
        }
      }

      res.json({ data: Array.from(productsMap.values()) });
    } catch (error: any) {
      console.error('Error listing products with prices:', error);
      res.status(500).json({ error: 'Failed to list products' });
    }
  });

  app.post('/api/stripe/create-checkout-session', async (req: Request, res: Response) => {
    try {
      const { priceId, orderId, successUrl, cancelUrl } = req.body;

      if (!priceId) {
        return res.status(400).json({ error: 'Price ID is required' });
      }

      const user = (req as any).user;
      if (!user) {
        return res.status(401).json({ error: 'Authentication required' });
      }

      const stripe = await getUncachableStripeClient();

      let customerId: string | undefined;
      const dbUser = await storage.getUser(user.claims.sub);
      if (dbUser?.stripeCustomerId) {
        customerId = dbUser.stripeCustomerId;
      } else {
        const customer = await stripe.customers.create({
          email: user.claims.email,
          name: user.claims.name || user.claims.email,
          metadata: { userId: user.claims.sub },
        });
        customerId = customer.id;
        await storage.updateUser(user.claims.sub, { stripeCustomerId: customer.id });
      }

      const baseUrl = `https://${process.env.REPLIT_DOMAINS?.split(',')[0]}`;
      const session = await stripe.checkout.sessions.create({
        customer: customerId,
        payment_method_types: ['card'],
        line_items: [{ price: priceId, quantity: 1 }],
        mode: 'payment',
        success_url: successUrl || `${baseUrl}/payment/success?session_id={CHECKOUT_SESSION_ID}`,
        cancel_url: cancelUrl || `${baseUrl}/payment/cancel`,
        metadata: { orderId: orderId || '' },
      });

      res.json({ url: session.url, sessionId: session.id });
    } catch (error: any) {
      console.error('Error creating checkout session:', error);
      res.status(500).json({ error: 'Failed to create checkout session' });
    }
  });

  app.post('/api/stripe/create-payment-intent', async (req: Request, res: Response) => {
    try {
      const { amount, currency = 'usd', orderId } = req.body;

      if (!amount) {
        return res.status(400).json({ error: 'Amount is required' });
      }

      const user = (req as any).user;
      if (!user) {
        return res.status(401).json({ error: 'Authentication required' });
      }

      const stripe = await getUncachableStripeClient();

      let customerId: string | undefined;
      const dbUser = await storage.getUser(user.claims.sub);
      if (dbUser?.stripeCustomerId) {
        customerId = dbUser.stripeCustomerId;
      }

      const paymentIntent = await stripe.paymentIntents.create({
        amount,
        currency,
        customer: customerId,
        metadata: { orderId: orderId || '', userId: user.claims.sub },
      });

      res.json({ clientSecret: paymentIntent.client_secret });
    } catch (error: any) {
      console.error('Error creating payment intent:', error);
      res.status(500).json({ error: 'Failed to create payment intent' });
    }
  });

  app.get('/api/stripe/checkout-session/:sessionId', async (req: Request, res: Response) => {
    try {
      const { sessionId } = req.params;
      const stripe = await getUncachableStripeClient();
      const session = await stripe.checkout.sessions.retrieve(sessionId);
      res.json({ session });
    } catch (error: any) {
      console.error('Error retrieving session:', error);
      res.status(500).json({ error: 'Failed to retrieve session' });
    }
  });
}


=== File: server/stripeService.ts ===

import { stripeStorage } from './stripeStorage';
import { getUncachableStripeClient } from './stripeClient';

export class StripeService {
  async createCustomer(email: string, userId: string, name?: string) {
    const stripe = await getUncachableStripeClient();
    return await stripe.customers.create({
      email,
      name,
      metadata: { userId },
    });
  }

  async createCheckoutSession(
    customerId: string, 
    priceId: string, 
    successUrl: string, 
    cancelUrl: string,
    metadata?: Record<string, string>
  ) {
    const stripe = await getUncachableStripeClient();
    return await stripe.checkout.sessions.create({
      customer: customerId,
      payment_method_types: ['card'],
      line_items: [{ price: priceId, quantity: 1 }],
      mode: 'payment',
      success_url: successUrl,
      cancel_url: cancelUrl,
      metadata,
    });
  }

  async createPaymentIntent(
    amount: number,
    currency: string,
    customerId?: string,
    metadata?: Record<string, string>
  ) {
    const stripe = await getUncachableStripeClient();
    return await stripe.paymentIntents.create({
      amount,
      currency,
      customer: customerId,
      metadata,
    });
  }

  async getProduct(productId: string) {
    return await stripeStorage.getProduct(productId);
  }

  async listProducts() {
    return await stripeStorage.listProducts();
  }

  async listProductsWithPrices() {
    return await stripeStorage.listProductsWithPrices();
  }

  async getSubscription(subscriptionId: string) {
    return await stripeStorage.getSubscription(subscriptionId);
  }
}

export const stripeService = new StripeService();


=== File: server/stripeStorage.ts ===

import { sql } from 'drizzle-orm';
import { db } from './db';

export class StripeStorage {
  async getProduct(productId: string) {
    const result = await db.execute(
      sql`SELECT * FROM stripe.products WHERE id = ${productId}`
    );
    return result.rows[0] || null;
  }

  async listProducts(active = true, limit = 20, offset = 0) {
    const result = await db.execute(
      sql`SELECT * FROM stripe.products WHERE active = ${active} LIMIT ${limit} OFFSET ${offset}`
    );
    return result.rows;
  }

  async listProductsWithPrices(active = true, limit = 20, offset = 0) {
    const result = await db.execute(
      sql`
        WITH paginated_products AS (
          SELECT id, name, description, metadata, active
          FROM stripe.products
          WHERE active = ${active}
          ORDER BY id
          LIMIT ${limit} OFFSET ${offset}
        )
        SELECT 
          p.id as product_id,
          p.name as product_name,
          p.description as product_description,
          p.active as product_active,
          p.metadata as product_metadata,
          pr.id as price_id,
          pr.unit_amount,
          pr.currency,
          pr.recurring,
          pr.active as price_active,
          pr.metadata as price_metadata
        FROM paginated_products p
        LEFT JOIN stripe.prices pr ON pr.product = p.id AND pr.active = true
        ORDER BY p.id, pr.unit_amount
      `
    );
    return result.rows;
  }

  async getPrice(priceId: string) {
    const result = await db.execute(
      sql`SELECT * FROM stripe.prices WHERE id = ${priceId}`
    );
    return result.rows[0] || null;
  }

  async listPrices(active = true, limit = 20, offset = 0) {
    const result = await db.execute(
      sql`SELECT * FROM stripe.prices WHERE active = ${active} LIMIT ${limit} OFFSET ${offset}`
    );
    return result.rows;
  }

  async getPricesForProduct(productId: string) {
    const result = await db.execute(
      sql`SELECT * FROM stripe.prices WHERE product = ${productId} AND active = true`
    );
    return result.rows;
  }

  async getSubscription(subscriptionId: string) {
    const result = await db.execute(
      sql`SELECT * FROM stripe.subscriptions WHERE id = ${subscriptionId}`
    );
    return result.rows[0] || null;
  }

  async getCustomer(customerId: string) {
    const result = await db.execute(
      sql`SELECT * FROM stripe.customers WHERE id = ${customerId}`
    );
    return result.rows[0] || null;
  }
}

export const stripeStorage = new StripeStorage();


=== File: server/vite.ts ===

import { type Express } from "express";
import { createServer as createViteServer, createLogger } from "vite";
import { type Server } from "http";
import viteConfig from "../vite.config";
import fs from "fs";
import path from "path";
import { nanoid } from "nanoid";

const viteLogger = createLogger();

export async function setupVite(server: Server, app: Express) {
  const serverOptions = {
    middlewareMode: true,
    hmr: { server, path: "/vite-hmr" },
    allowedHosts: true as const,
  };

  const vite = await createViteServer({
    ...viteConfig,
    configFile: false,
    customLogger: {
      ...viteLogger,
      error: (msg, options) => {
        viteLogger.error(msg, options);
        process.exit(1);
      },
    },
    server: serverOptions,
    appType: "custom",
  });

  app.use(vite.middlewares);

  app.use("*", async (req, res, next) => {
    const url = req.originalUrl;

    try {
      const clientTemplate = path.resolve(
        import.meta.dirname,
        "..",
        "client",
        "index.html",
      );

      // always reload the index.html file from disk incase it changes
      let template = await fs.promises.readFile(clientTemplate, "utf-8");
      template = template.replace(
        `src="/src/main.tsx"`,
        `src="/src/main.tsx?v=${nanoid()}"`,
      );
      const page = await vite.transformIndexHtml(url, template);
      res.status(200).set({ "Content-Type": "text/html" }).end(page);
    } catch (e) {
      vite.ssrFixStacktrace(e as Error);
      next(e);
    }
  });
}


=== File: server/webhookHandlers.ts ===

import { getStripeSync } from './stripeClient';

export class WebhookHandlers {
  static async processWebhook(payload: Buffer, signature: string, uuid: string): Promise<void> {
    if (!Buffer.isBuffer(payload)) {
      throw new Error(
        'STRIPE WEBHOOK ERROR: Payload must be a Buffer. ' +
        'Received type: ' + typeof payload + '. ' +
        'This usually means express.json() parsed the body before reaching this handler. ' +
        'FIX: Ensure webhook route is registered BEFORE app.use(express.json()).'
      );
    }

    const sync = await getStripeSync();
    await sync.processWebhook(payload, signature, uuid);
  }
}

